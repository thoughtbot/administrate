(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w2) {
            if (!w2.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w2);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf2 = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i2, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i2 in preservedScriptAttributes) {
              val = node[i2] || node.getAttribute && node.getAttribute(i2);
              if (val) {
                script.setAttribute(i2, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version = "3.7.0", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
          return new jQuery.fn.init(selector, context);
        };
        jQuery.fn = jQuery.prototype = {
          // The current version of jQuery being used
          jquery: version,
          constructor: jQuery,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i2) {
              return callback.call(elem, i2, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i2) {
              return (i2 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i2) {
              return i2 % 2;
            }));
          },
          eq: function(i2) {
            var len = this.length, j2 = +i2 + (i2 < 0 ? len : 0);
            return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery.extend = jQuery.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i2] || {};
            i2++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i2 === length) {
            target = this;
            i2--;
          }
          for (; i2 < length; i2++) {
            if ((options = arguments[i2]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i2 = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i2 < length; i2++) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            } else {
              for (i2 in obj) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // Retrieve the text value of an array of DOM nodes
          text: function(elem) {
            var node, ret = "", i2 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i2++]) {
                ret += jQuery.text(node);
              }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
              return elem.textContent;
            } else if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i2) {
            return arr2 == null ? -1 : indexOf2.call(arr2, elem, i2);
          },
          isXMLDoc: function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j2 = 0, i2 = first.length;
            for (; j2 < len; j2++) {
              first[i2++] = second[j2];
            }
            first.length = i2;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
            for (; i2 < length; i2++) {
              callbackInverse = !callback(elems[i2], i2);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i2]);
              }
            }
            return matches;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i2 = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i2 < length; i2++) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i2 in elems) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i2, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var pop = arr.pop;
        var sort = arr.sort;
        var splice = arr.splice;
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        jQuery.contains = function(a2, b2) {
          var bup = b2 && b2.parentNode;
          return a2 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
          // IE doesn't have `contains` on SVG.
          (a2.contains ? a2.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
        };
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }
        jQuery.escapeSelector = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        var preferredDoc = document2, pushNative = push;
        (function() {
          var i2, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
            }
            return 0;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 65536;
            if (nonHex) {
              return nonHex;
            }
            return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && nodeName(elem, "fieldset");
            },
            { dir: "parentNode", next: "legend" }
          );
          function safeActiveElement() {
            try {
              return document3.activeElement;
            } catch (err) {
            }
          }
          try {
            push2.apply(
              arr = slice.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr[preferredDoc.childNodes.length].nodeType;
          } catch (e2) {
            push2 = {
              apply: function(target, els) {
                pushNative.apply(target, slice.call(els));
              },
              call: function(target) {
                pushNative.apply(target, slice.call(arguments, 1));
              }
            };
          }
          function find(selector, context, results, seed) {
            var m2, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m2 = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m2)) {
                        if (elem.id === m2) {
                          push2.call(results, elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m2)) && find.contains(context, elem) && elem.id === m2) {
                        push2.call(results, elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m2 = match[3]) && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m2));
                    return results;
                  }
                }
                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext != context || !support.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = jQuery.escapeSelector(nid);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize2(selector);
                    i3 = groups.length;
                    while (i3--) {
                      groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache2(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache2[keys.shift()];
              }
              return cache2[key + " "] = value;
            }
            return cache2;
          }
          function markFunction(fn2) {
            fn2[expando] = true;
            return fn2;
          }
          function assert(fn2) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn2(el);
            } catch (e2) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function createInputPseudo(type) {
            return function(elem) {
              return nodeName(elem, "input") && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                  elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn2) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j2, matchIndexes = fn2([], seed.length, argument), i3 = matchIndexes.length;
                while (i3--) {
                  if (seed[j2 = matchIndexes[i3]]) {
                    seed[j2] = !(matches2[j2] = seed[j2]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          function setDocument(node) {
            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            documentElement2 = document3.documentElement;
            documentIsHTML = !jQuery.isXMLDoc(document3);
            matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
            if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              subWindow.addEventListener("unload", unloadHandler);
            }
            support.getById = assert(function(el) {
              documentElement2.appendChild(el).id = jQuery.expando;
              return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
            });
            support.disconnectedMatch = assert(function(el) {
              return matches.call(el, "*");
            });
            support.scope = assert(function() {
              return document3.querySelectorAll(":scope");
            });
            support.cssHas = assert(function() {
              try {
                document3.querySelector(":has(*,:jqfake)");
                return false;
              } catch (e2) {
                return true;
              }
            });
            if (support.getById) {
              Expr.filter.ID = function(id2) {
                var attrId = id2.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find.ID = function(id2, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id2);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter.ID = function(id2) {
                var attrId = id2.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find.ID = function(id2, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i3, elems, elem = context.getElementById(id2);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id2) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id2);
                    i3 = 0;
                    while (elem = elems[i3++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id2) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find.TAG = function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else {
                return context.querySelectorAll(tag);
              }
            };
            Expr.find.CLASS = function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyQSA = [];
            assert(function(el) {
              var input;
              documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              documentElement2.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
              }
            });
            if (!support.cssHas) {
              rbuggyQSA.push(":has");
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            sortOrder = function(a2, b2) {
              if (a2 === b2) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
                // Otherwise we know they are disconnected
                1
              );
              if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
                if (a2 === document3 || a2.ownerDocument == preferredDoc && find.contains(preferredDoc, a2)) {
                  return -1;
                }
                if (b2 === document3 || b2.ownerDocument == preferredDoc && find.contains(preferredDoc, b2)) {
                  return 1;
                }
                return sortInput ? indexOf2.call(sortInput, a2) - indexOf2.call(sortInput, b2) : 0;
              }
              return compare & 4 ? -1 : 1;
            };
            return document3;
          }
          find.matches = function(expr, elements) {
            return find(expr, null, null, elements);
          };
          find.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e2) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return find(expr, document3, null, [elem]).length > 0;
          };
          find.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return jQuery.contains(context, elem);
          };
          find.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
            if (val !== void 0) {
              return val;
            }
            return elem.getAttribute(name);
          };
          find.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          jQuery.uniqueSort = function(results) {
            var elem, duplicates = [], j2 = 0, i3 = 0;
            hasDuplicate = !support.sortStable;
            sortInput = !support.sortStable && slice.call(results, 0);
            sort.call(results, sortOrder);
            if (hasDuplicate) {
              while (elem = results[i3++]) {
                if (elem === results[i3]) {
                  j2 = duplicates.push(i3);
                }
              }
              while (j2--) {
                splice.call(results, duplicates[j2], 1);
              }
            }
            sortInput = null;
            return results;
          };
          jQuery.fn.uniqueSort = function() {
            return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
          };
          Expr = jQuery.expr = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              ATTR: function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              CHILD: function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    find.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  find.error(match[0]);
                }
                return match;
              },
              PSEUDO: function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr.CHILD.test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              TAG: function(nodeNameSelector) {
                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return nodeName(elem, expectedNodeName);
                };
              },
              CLASS: function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                });
              },
              ATTR: function(name, operator, check) {
                return function(elem) {
                  var result = find.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  if (operator === "=") {
                    return result === check;
                  }
                  if (operator === "!=") {
                    return result !== check;
                  }
                  if (operator === "^=") {
                    return check && result.indexOf(check) === 0;
                  }
                  if (operator === "*=") {
                    return check && result.indexOf(check) > -1;
                  }
                  if (operator === "$=") {
                    return check && result.slice(-check.length) === check;
                  }
                  if (operator === "~=") {
                    return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                  }
                  if (operator === "|=") {
                    return result === check || result.slice(0, check.length + 1) === check + "-";
                  }
                  return false;
                };
              },
              CHILD: function(type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? (
                  // Shortcut for :nth-*(n)
                  function(elem) {
                    return !!elem.parentNode;
                  }
                ) : function(elem, _context, xml) {
                  var cache2, outerCache, node, nodeIndex, start3, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start3 = dir2 = type === "only" && !start3 && "nextSibling";
                      }
                      return true;
                    }
                    start3 = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      outerCache = parent[expando] || (parent[expando] = {});
                      cache2 = outerCache[type] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex && cache2[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start3.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        cache2 = outerCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start3.pop()) {
                          if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              outerCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              PSEUDO: function(pseudo, argument) {
                var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                if (fn2[expando]) {
                  return fn2(argument);
                }
                if (fn2.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn2(seed, argument), i3 = matched.length;
                    while (i3--) {
                      idx = indexOf2.call(seed, matched[i3]);
                      seed[idx] = !(matches2[idx] = matched[i3]);
                    }
                  }) : function(elem) {
                    return fn2(elem, 0, args);
                  };
                }
                return fn2;
              }
            },
            pseudos: {
              // Potentially complex pseudos
              not: markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                  while (i3--) {
                    if (elem = unmatched[i3]) {
                      seed[i3] = !(matches2[i3] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              has: markFunction(function(selector) {
                return function(elem) {
                  return find(selector, elem).length > 0;
                };
              }),
              contains: markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
                };
              }),
              // "Whether an element is represented by a :lang() selector
              // is based solely on the element's language value
              // being equal to the identifier C,
              // or beginning with the identifier C immediately followed by "-".
              // The matching of C against the element's language value is performed case-insensitively.
              // The identifier C does not have to be a valid language name."
              // https://www.w3.org/TR/selectors/#lang-pseudo
              lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  find.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              // Miscellaneous
              target: function(elem) {
                var hash = window2.location && window2.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              root: function(elem) {
                return elem === documentElement2;
              },
              focus: function(elem) {
                return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              // Boolean properties
              enabled: createDisabledPseudo(false),
              disabled: createDisabledPseudo(true),
              checked: function(elem) {
                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
              },
              selected: function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              // Contents
              empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              parent: function(elem) {
                return !Expr.pseudos.empty(elem);
              },
              // Element/input types
              header: function(elem) {
                return rheader.test(elem.nodeName);
              },
              input: function(elem) {
                return rinputs.test(elem.nodeName);
              },
              button: function(elem) {
                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
              },
              text: function(elem) {
                var attr;
                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                // New HTML5 attribute values (e.g., "search") appear
                // with elem.type === "text"
                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              // Position-in-collection
              first: createPositionalPseudo(function() {
                return [0];
              }),
              last: createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              even: createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 0;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              odd: createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 1;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3;
                if (argument < 0) {
                  i3 = argument + length;
                } else if (argument > length) {
                  i3 = length;
                } else {
                  i3 = argument;
                }
                for (; --i3 >= 0; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; ++i3 < length; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos.nth = Expr.pseudos.eq;
          for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i2] = createInputPseudo(i2);
          }
          for (i2 in { submit: true, reset: true }) {
            Expr.pseudos[i2] = createButtonPseudo(i2);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          function tokenize2(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rleadingCombinator.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            if (parseOnly) {
              return soFar.length;
            }
            return soFar ? find.error(selector) : (
              // Cache the tokens
              tokenCache(selector, groups).slice(0)
            );
          }
          function toSelector(tokens) {
            var i3 = 0, len = tokens.length, selector = "";
            for (; i3 < len; i3++) {
              selector += tokens[i3].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? (
              // Check against closest ancestor/preceding element
              function(elem, context, xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    return matcher(elem, context, xml);
                  }
                }
                return false;
              }
            ) : (
              // Check against all ancestor/preceding elements
              function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      if (matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                } else {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      if (skip && nodeName(elem, skip)) {
                        elem = elem[dir2] || elem;
                      } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                        return newCache[2] = oldCache[2];
                      } else {
                        outerCache[key] = newCache;
                        if (newCache[2] = matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  }
                }
                return false;
              }
            );
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i3 = matchers.length;
              while (i3--) {
                if (!matchers[i3](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i3 = 0, len = contexts.length;
            for (; i3 < len; i3++) {
              find(selector, contexts[i3], results);
            }
            return results;
          }
          function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map != null;
            for (; i3 < len; i3++) {
              if (elem = unmatched[i3]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map.push(i3);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i3, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
              if (matcher) {
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                  // ...intermediate processing is necessary
                  []
                ) : (
                  // ...otherwise use results directly
                  results
                );
                matcher(matcherIn, matcherOut, context, xml);
              } else {
                matcherOut = matcherIn;
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i3 = temp.length;
                while (i3--) {
                  if (elem = temp[i3]) {
                    matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i3 = matcherOut.length;
                    while (i3--) {
                      if (elem = matcherOut[i3]) {
                        temp.push(matcherIn[i3] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i3 = matcherOut.length;
                  while (i3--) {
                    if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf2.call(seed, elem) : preMap[i3]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i3 < len; i3++) {
              if (matcher = Expr.relative[tokens[i3].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
                if (matcher[expando]) {
                  j2 = ++i3;
                  for (; j2 < len; j2++) {
                    if (Expr.relative[tokens[j2].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i3 > 1 && elementMatcher(matchers),
                    i3 > 1 && toSelector(
                      // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                      tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                    ).replace(rtrimCSS, "$1"),
                    matcher,
                    i3 < j2 && matcherFromTokens(tokens.slice(i3, j2)),
                    j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                    j2 < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j2, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
                if (byElement && elem) {
                  j2 = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j2++]) {
                    if (matcher(elem, context || document3, xml)) {
                      push2.call(results, elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i3;
              if (bySet && i3 !== matchedCount) {
                j2 = 0;
                while (matcher = setMatchers[j2++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i3--) {
                      if (!(unmatched[i3] || setMatched[i3])) {
                        setMatched[i3] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  jQuery.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          function compile(selector, match) {
            var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize2(selector);
              }
              i3 = match.length;
              while (i3--) {
                cached = matcherFromTokens(match[i3]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          }
          function select(selector, context, results, seed) {
            var i3, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize2(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find.ID(
                  token.matches[0].replace(runescape, funescape),
                  context
                ) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i3 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
              while (i3--) {
                token = tokens[i3];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find2 = Expr.find[type]) {
                  if (seed = find2(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i3, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          }
          support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          setDocument();
          support.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          jQuery.find = find;
          jQuery.expr[":"] = jQuery.expr.pseudos;
          jQuery.unique = jQuery.uniqueSort;
          find.compile = compile;
          find.select = select;
          find.setDocument = setDocument;
          find.escape = jQuery.escapeSelector;
          find.getText = jQuery.text;
          find.isXML = jQuery.isXMLDoc;
          find.selectors = jQuery.expr;
          find.support = jQuery.support;
          find.uniqueSort = jQuery.uniqueSort;
        })();
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n2, elem) {
          var matched = [];
          for (; n2; n2 = n2.nextSibling) {
            if (n2.nodeType === 1 && n2 !== elem) {
              matched.push(n2);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery.expr.match.needsContext;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i2) {
              return !!qualifier.call(elem, i2, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function(elem) {
              return indexOf2.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery.filter(qualifier, elements, not);
        }
        jQuery.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery.fn.extend({
          find: function(selector) {
            var i2, ret, len = this.length, self = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery(selector).filter(function() {
                for (i2 = 0; i2 < len; i2++) {
                  if (jQuery.contains(self[i2], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i2 = 0; i2 < len; i2++) {
              jQuery.find(selector, self[i2], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery ? context[0] : context;
                jQuery.merge(this, jQuery.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery)
            );
          }
          return jQuery.makeArray(selector, this);
        };
        init.prototype = jQuery.fn;
        rootjQuery = jQuery(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery.fn.extend({
          has: function(target) {
            var targets = jQuery(target, this), l2 = targets.length;
            return this.filter(function() {
              var i2 = 0;
              for (; i2 < l2; i2++) {
                if (jQuery.contains(this, targets[i2])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i2 = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i2 < l2; i2++) {
                for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to jQuery#find
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf2.call(jQuery(elem), this[0]);
            }
            return indexOf2.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery.uniqueSort(
                jQuery.merge(this.get(), jQuery(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i2, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i2, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i2, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery.merge([], elem.childNodes);
          }
        }, function(name, fn2) {
          jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn2, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery.each(options.match(rnothtmlwhite) || [], function(_3, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add2(args) {
                  jQuery.each(args, function(_3, arg) {
                    if (isFunction(arg)) {
                      if (!options.unique || !self.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add2(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery.each(arguments, function(_3, arg) {
                var index;
                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn2) {
              return fn2 ? jQuery.inArray(fn2, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self;
        };
        function Identity(v2) {
          return v2;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery.Callbacks("memory"),
                jQuery.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery.Callbacks("once memory"),
                jQuery.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery.Callbacks("once memory"),
                jQuery.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn2) {
                return promise.then(null, fn2);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery.Deferred(function(newDefer) {
                  jQuery.each(tuples, function(_i2, tuple) {
                    var fn2 = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn2 && fn2.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn2 ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e2) {
                        if (jQuery.Deferred.exceptionHook) {
                          jQuery.Deferred.exceptionHook(
                            e2,
                            process.error
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e2];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process();
                    } else {
                      if (jQuery.Deferred.getErrorHook) {
                        process.error = jQuery.Deferred.getErrorHook();
                      } else if (jQuery.Deferred.getStackHook) {
                        process.error = jQuery.Deferred.getStackHook();
                      }
                      window2.setTimeout(process);
                    }
                  };
                }
                return jQuery.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery.each(tuples, function(i2, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i2][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i2][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i3) {
              return function(value) {
                resolveContexts[i3] = this;
                resolveValues[i3] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i2)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i2] && resolveValues[i2].then)) {
                return primary.then();
              }
            }
            while (i2--) {
              adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function(error2, asyncError) {
          if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
            window2.console.warn(
              "jQuery.Deferred exception: " + error2.message,
              error2.stack,
              asyncError
            );
          }
        };
        jQuery.readyException = function(error2) {
          window2.setTimeout(function() {
            throw error2;
          });
        };
        var readyList = jQuery.Deferred();
        jQuery.fn.ready = function(fn2) {
          readyList.then(fn2).catch(function(error2) {
            jQuery.readyException(error2);
          });
          return this;
        };
        jQuery.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
              return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery]);
          }
        });
        jQuery.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
          var i2 = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i2 in key) {
              access(elems, fn2, i2, key[i2], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn2.call(elems, value);
                fn2 = null;
              } else {
                bulk = fn2;
                fn2 = function(elem, _key, value2) {
                  return bulk.call(jQuery(elem), value2);
                };
              }
            }
            if (fn2) {
              for (; i2 < len; i2++) {
                fn2(
                  elems[i2],
                  key,
                  raw ? value : value.call(elems[i2], i2, fn2(elems[i2], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn2.call(elems);
          }
          return len ? fn2(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache2 = this.cache(owner);
            if (typeof data === "string") {
              cache2[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache2[camelCase(prop)] = data[prop];
              }
            }
            return cache2;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i2, cache2 = owner[this.expando];
            if (cache2 === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
              }
              i2 = key.length;
              while (i2--) {
                delete cache2[key[i2]];
              }
            }
            if (key === void 0 || jQuery.isEmptyObject(cache2)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache2 = owner[this.expando];
            return cache2 !== void 0 && !jQuery.isEmptyObject(cache2);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e2) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery.fn.extend({
          data: function(key, value) {
            var i2, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2]) {
                      name = attrs[i2].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn2 = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
              jQuery.dequeue(elem, type);
            };
            if (fn2 === "inprogress") {
              fn2 = queue.shift();
              startLength--;
            }
            if (fn2) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn2.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery.queue(this, type, data);
              jQuery._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i2 = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i2--) {
              tmp = dataPriv.get(elements[i2], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery(this).show();
              } else {
                jQuery(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i2 = 0, l2 = elems.length;
          for (; i2 < l2; i2++) {
            dataPriv.set(
              elems[i2],
              "globalEval",
              !refElements || dataPriv.get(refElements[i2], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l2 = elems.length;
          for (; i2 < l2; i2++) {
            elem = elems[i2];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                j2 = wrap[0];
                while (j2--) {
                  tmp = tmp.lastChild;
                }
                jQuery.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i2 = 0;
          while (elem = nodes[i2++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j2 = 0;
              while (elem = tmp[j2++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function on2(elem, types, selector, data, fn2, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on2(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn2 == null) {
            fn2 = selector;
            data = selector = void 0;
          } else if (fn2 == null) {
            if (typeof selector === "string") {
              fn2 = data;
              data = void 0;
            } else {
              fn2 = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn2 === false) {
            fn2 = returnFalse;
          } else if (!fn2) {
            return elem;
          }
          if (one === 1) {
            origFn = fn2;
            fn2 = function(event) {
              jQuery().off(event);
              return origFn.apply(this, arguments);
            };
            fn2.guid = origFn.guid || (origFn.guid = jQuery.guid++);
          }
          return elem.each(function() {
            jQuery.event.add(this, types, fn2, data, selector);
          });
        }
        jQuery.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t3, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e2) {
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e2.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t3 = types.length;
            while (t3--) {
              tmp = rtypenamespace.exec(types[t3]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery.event.special[type] || {};
              handleObj = jQuery.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j2, origCount, tmp, events, t3, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t3 = types.length;
            while (t3--) {
              tmp = rtypenamespace.exec(types[t3]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery.event.remove(elem, type + types[t3], handler, selector, true);
                }
                continue;
              }
              special = jQuery.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j2 = handlers.length;
              while (j2--) {
                handleObj = handlers[j2];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j2, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i2, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i2 = 1; i2 < arguments.length; i2++) {
              args[i2] = arguments[i2];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i2 = 0;
            while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j2 = 0;
              while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i2 = 0; i2 < delegateCount; i2++) {
                    handleObj = handlers[i2];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", true);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, isSetup) {
          if (!isSetup) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  this[type]();
                  result = dataPriv.get(this, type);
                  dataPriv.set(this, type, false);
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result;
                  }
                } else if ((jQuery.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved) {
                dataPriv.set(this, type, jQuery.event.trigger(
                  saved[0],
                  saved.slice(1),
                  this
                ));
                event.stopPropagation();
                event.isImmediatePropagationStopped = returnTrue;
              }
            }
          });
        }
        jQuery.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery.Event = function(src, props) {
          if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery.expando] = true;
        };
        jQuery.Event.prototype = {
          constructor: jQuery.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e2 = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.preventDefault();
            }
          },
          stopPropagation: function() {
            var e2 = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e2 = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery.event.addProp);
        jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          function focusMappedHandler(nativeEvent) {
            if (document2.documentMode) {
              var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
              event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
              event.isSimulated = true;
              handle(nativeEvent);
              if (event.target === event.currentTarget) {
                handle(event);
              }
            } else {
              jQuery.event.simulate(
                delegateType,
                nativeEvent.target,
                jQuery.event.fix(nativeEvent)
              );
            }
          }
          jQuery.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              var attaches;
              leverageNative(this, type, true);
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType);
                if (!attaches) {
                  this.addEventListener(delegateType, focusMappedHandler);
                }
                dataPriv.set(this, delegateType, (attaches || 0) + 1);
              } else {
                return false;
              }
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            teardown: function() {
              var attaches;
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType) - 1;
                if (!attaches) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                  dataPriv.remove(this, delegateType);
                } else {
                  dataPriv.set(this, delegateType, attaches);
                }
              } else {
                return false;
              }
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
          jQuery.event.special[delegateType] = {
            setup: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
              if (!attaches) {
                if (document2.documentMode) {
                  this.addEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.addEventListener(type, focusMappedHandler, true);
                }
              }
              dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
              if (!attaches) {
                if (document2.documentMode) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.removeEventListener(type, focusMappedHandler, true);
                }
                dataPriv.remove(dataHolder, delegateType);
              } else {
                dataPriv.set(dataHolder, delegateType, attaches);
              }
            }
          };
        });
        jQuery.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery.fn.extend({
          on: function(types, selector, data, fn2) {
            return on2(this, types, selector, data, fn2);
          },
          one: function(types, selector, data, fn2) {
            return on2(this, types, selector, data, fn2, 1);
          },
          off: function(types, selector, fn2) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn2 = selector;
              selector = void 0;
            }
            if (fn2 === false) {
              fn2 = returnFalse;
            }
            return this.each(function() {
              jQuery.event.remove(this, types, fn2, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i2, l2, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i2 = 0, l2 = events[type].length; i2 < l2; i2++) {
                  jQuery.event.add(dest, type, events[type][i2]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i2 = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self.html());
              }
              domManip(self, args, callback, ignored);
            });
          }
          if (l2) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i2 < l2; i2++) {
                node = fragment;
                if (i2 !== iNoClone) {
                  node = jQuery.clone(node, true, true);
                  if (hasScripts) {
                    jQuery.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i2], node, i2);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery.map(scripts, restoreScript);
                for (i2 = 0; i2 < hasScripts; i2++) {
                  node = scripts[i2];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery._evalUrl && !node.noModule) {
                        jQuery._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i2 = 0;
          for (; (node = nodes[i2]) != null; i2++) {
            if (!keepData && node.nodeType === 1) {
              jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i2, l2, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
                fixInput(srcElements[i2], destElements[i2]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
                  cloneCopyEvent(srcElements[i2], destElements[i2]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i2 = 0;
            for (; (elem = elems[i2]) !== void 0; i2++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery.event.remove(elem, type);
                      } else {
                        jQuery.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i2 = 0;
            for (; (elem = this[i2]) != null; i2++) {
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i2 = 0, l2 = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery.htmlPrefilter(value2);
                try {
                  for (; i2 < l2; i2++) {
                    elem = this[i2] || {};
                    if (elem.nodeType === 1) {
                      jQuery.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e2) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery.inArray(this, ignored) < 0) {
                jQuery.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i2 = 0;
            for (; i2 <= last; i2++) {
              elems = i2 === last ? this : this.clone(true);
              jQuery(insert[i2])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table, tr2, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr2 = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr2.style.cssText = "border:1px solid";
                tr2.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr2).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr2);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr2.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i2 = cssPrefixes.length;
          while (i2--) {
            name = cssPrefixes[i2] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i2 < 4; i2 += 2) {
            if (box === "margin") {
              marginDelta += jQuery.css(elem, box + cssExpand[i2], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery.css(elem, "padding" + cssExpand[i2], true, styles);
              if (box !== "padding") {
                delta += jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              } else {
                extra += jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery.css(elem, "padding" + cssExpand[i2], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta + marginDelta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery.each(["height", "width"], function(_i2, dimension) {
          jQuery.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i2 < 4; i2++) {
                expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map = {}, i2 = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i2 < len; i2++) {
                  map[name2[i2]] = jQuery.css(elem, name2[i2], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end, easing) {
          return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery.fx.step[tween.prop]) {
                jQuery.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery.easing = {
          linear: function(p2) {
            return p2;
          },
          swing: function(p2) {
            return 0.5 - Math.cos(p2 * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery.fx.interval);
            }
            jQuery.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i2 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i2 < 4; i2 += 2 - includeWidth) {
            which = cssExpand[i2];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
          }
          propTween = !jQuery.isEmptyObject(props);
          if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
              specialEasing: {},
              easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery.fx.timer(
            jQuery.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery.Animation = jQuery.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery.speed = function(speed, easing, fn2) {
          var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn2 || !fn2 && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn2 && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery.fx.speeds) {
                opt.duration = jQuery.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery.fn.extend({
          fadeTo: function(speed, to2, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to2 }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery.each(["toggle", "show", "hide"], function(_i2, name) {
          var cssFn = jQuery.fn[name];
          jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery.timers = [];
        jQuery.fx.tick = function() {
          var timer, i2 = 0, timers = jQuery.timers;
          fxNow = Date.now();
          for (; i2 < timers.length; i2++) {
            timer = timers[i2];
            if (!timer() && timers[i2] === timer) {
              timers.splice(i2--, 1);
            }
          }
          if (!timers.length) {
            jQuery.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery.fx.timer = function(timer) {
          jQuery.timers.push(timer);
          jQuery.fx.start();
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery.fx.stop = function() {
          inProgress = null;
        };
        jQuery.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery.fn.delay = function(time, type) {
          time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery.removeAttr(this, name);
            });
          }
        });
        jQuery.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
              hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i2++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i2, name) {
          var getter = attrHandle[name] || jQuery.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery.propFix[name] || name];
            });
          }
        });
        jQuery.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
              name = jQuery.propFix[name] || name;
              hooks = jQuery.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className, i2, finalValue;
            if (isFunction(value)) {
              return this.each(function(j2) {
                jQuery(this).addClass(value.call(this, j2, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className = classNames[i2];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className, i2, finalValue;
            if (isFunction(value)) {
              return this.each(function(j2) {
                jQuery(this).removeClass(value.call(this, j2, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className = classNames[i2];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className, i2, self, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) {
              return this.each(function(i3) {
                jQuery(this).toggleClass(
                  value.call(this, i3, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self = jQuery(this);
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  if (self.hasClass(className)) {
                    self.removeClass(className);
                  } else {
                    self.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i2 = 0;
            className = " " + selector + " ";
            while (elem = this[i2++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i2) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i2, jQuery(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i2, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                if (index < 0) {
                  i2 = max;
                } else {
                  i2 = one ? index : 0;
                }
                for (; i2 < max; i2++) {
                  option = options[i2];
                  if ((option.selected || i2 === index) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i2 = options.length;
                while (i2--) {
                  option = options[i2];
                  if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery.each(["radio", "checkbox"], function() {
          jQuery.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e2) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
          e2.stopPropagation();
        };
        jQuery.extend(jQuery.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i2 = 0;
            while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i2 > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e2 = jQuery.extend(
              new jQuery.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery.event.trigger(e2, null, elem);
          }
        });
        jQuery.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery.event.trigger(type, data, elem, true);
            }
          }
        });
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add2) {
          var name;
          if (Array.isArray(obj)) {
            jQuery.each(obj, function(i2, v2) {
              if (traditional || rbracket.test(prefix)) {
                add2(prefix, v2);
              } else {
                buildParams(
                  prefix + "[" + (typeof v2 === "object" && v2 != null ? i2 : "") + "]",
                  v2,
                  traditional,
                  add2
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
            }
          } else {
            add2(prefix, obj);
          }
        }
        jQuery.param = function(a2, traditional) {
          var prefix, s2 = [], add2 = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a2 == null) {
            return "";
          }
          if (Array.isArray(a2) || a2.jquery && !jQuery.isPlainObject(a2)) {
            jQuery.each(a2, function() {
              add2(this.name, this.value);
            });
          } else {
            for (prefix in a2) {
              buildParams(prefix, a2[prefix], traditional, add2);
            }
          }
          return s2.join("&");
        };
        jQuery.fn.extend({
          serialize: function() {
            return jQuery.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery.prop(this, "elements");
              return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i2, elem) {
              var val = jQuery(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i2++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_3, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s2, jqXHR, responses) {
          var ct2, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct2 === void 0) {
              ct2 = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct2) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct2)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s2, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s2.converters) {
              converters[conv.toLowerCase()] = s2.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s2.responseFields[current]) {
              jqXHR[s2.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s2.dataFilter) {
              response = s2.dataFilter(response, s2.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s2.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e2) {
                      return {
                        state: "parsererror",
                        error: conv ? e2 : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s2 = jQuery.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s2.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map) {
                var code;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code in map) {
                      statusCode[code] = [statusCode[code], map[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s2.url = ((url || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s2.type = options.method || options.type || s2.method || s2.type;
            s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s2.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s2.url;
                urlAnchor.href = urlAnchor.href;
                s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e2) {
                s2.crossDomain = true;
              }
            }
            if (s2.data && s2.processData && typeof s2.data !== "string") {
              s2.data = jQuery.param(s2.data, s2.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery.event && s2.global;
            if (fireGlobals && jQuery.active++ === 0) {
              jQuery.event.trigger("ajaxStart");
            }
            s2.type = s2.type.toUpperCase();
            s2.hasContent = !rnoContent.test(s2.type);
            cacheURL = s2.url.replace(rhash, "");
            if (!s2.hasContent) {
              uncached = s2.url.slice(cacheURL.length);
              if (s2.data && (s2.processData || typeof s2.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
                delete s2.data;
              }
              if (s2.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s2.url = cacheURL + uncached;
            } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s2.data = s2.data.replace(r20, "+");
            }
            if (s2.ifModified) {
              if (jQuery.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
              }
              if (jQuery.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
              }
            }
            if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s2.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
            );
            for (i2 in s2.headers) {
              jqXHR.setRequestHeader(i2, s2.headers[i2]);
            }
            if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s2.complete);
            jqXHR.done(s2.success);
            jqXHR.fail(s2.error);
            transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s2.async && s2.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s2.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e2) {
                if (completed2) {
                  throw e2;
                }
                done(-1, e2);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s2, jqXHR, responses);
              }
              if (!isSuccess && jQuery.inArray("script", s2.dataTypes) > -1 && jQuery.inArray("json", s2.dataTypes) < 0) {
                s2.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s2, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s2.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s2.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error2 = response.error;
                  isSuccess = !error2;
                }
              } else {
                error2 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s2, isSuccess ? success : error2]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
                if (!--jQuery.active) {
                  jQuery.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
          }
        });
        jQuery.each(["get", "post"], function(_i2, method) {
          jQuery[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery.ajax(jQuery.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery.isPlainObject(url) && url));
          };
        });
        jQuery.ajaxPrefilter(function(s2) {
          var i2;
          for (i2 in s2.headers) {
            if (i2.toLowerCase() === "content-type") {
              s2.contentType = s2.headers[i2] || "";
            }
          }
        });
        jQuery._evalUrl = function(url, options, doc) {
          return jQuery.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery.globalEval(response, options, doc);
            }
          });
        };
        jQuery.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i2) {
                jQuery(this).wrapInner(html.call(this, i2));
              });
            }
            return this.each(function() {
              var self = jQuery(this), contents = self.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i2) {
              jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i2) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery.expr.pseudos.hidden = function(elem) {
          return !jQuery.expr.pseudos.visible(elem);
        };
        jQuery.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e2) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i2, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i2 in options.xhrFields) {
                    xhr[i2] = options.xhrFields[i2];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i2 in headers) {
                  xhr.setRequestHeader(i2, headers[i2]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e2) {
                  if (callback) {
                    throw e2;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery.ajaxPrefilter(function(s2) {
          if (s2.crossDomain) {
            s2.contents.script = false;
          }
        });
        jQuery.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery.globalEval(text);
              return text;
            }
          }
        });
        jQuery.ajaxPrefilter("script", function(s2) {
          if (s2.cache === void 0) {
            s2.cache = false;
          }
          if (s2.crossDomain) {
            s2.type = "GET";
          }
        });
        jQuery.ajaxTransport("script", function(s2) {
          if (s2.crossDomain || s2.scriptAttrs) {
            var script, callback;
            return {
              send: function(_3, complete) {
                script = jQuery("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
          if (jsonProp || s2.dataTypes[0] === "jsonp") {
            callbackName = s2.jsonpCallback = isFunction(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
            if (jsonProp) {
              s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s2.jsonp !== false) {
              s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
            }
            s2.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s2.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s2[callbackName]) {
                s2.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery(scripts).remove();
          }
          return jQuery.merge([], parsed.childNodes);
        };
        jQuery.fn.load = function(url, params, callback) {
          var selector, type, response, self = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self.length > 0) {
            jQuery.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery.expr.pseudos.animated = function(elem) {
          return jQuery.grep(jQuery.timers, function(fn2) {
            return elem === fn2.elem;
          }).length;
        };
        jQuery.offset = {
          setOffset: function(elem, options, i2) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
              options = options.call(elem, i2, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i2) {
                jQuery.offset.setOffset(this, options, i2);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offset = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery(offsetParent).offset();
                parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : win.pageXOffset,
                  top ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery.each(["top", "left"], function(_i2, prop) {
          jQuery.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i2, type) {
          jQuery.fn[type] = function(fn2) {
            return this.on(type, fn2);
          };
        });
        jQuery.fn.extend({
          bind: function(types, data, fn2) {
            return this.on(types, null, data, fn2);
          },
          unbind: function(types, fn2) {
            return this.off(types, null, fn2);
          },
          delegate: function(selector, types, data, fn2) {
            return this.on(types, selector, data, fn2);
          },
          undelegate: function(selector, types, fn2) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
          },
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          }
        });
        jQuery.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i2, name) {
            jQuery.fn[name] = function(data, fn2) {
              return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery.proxy = function(fn2, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn2[context];
            context = fn2;
            fn2 = tmp;
          }
          if (!isFunction(fn2)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn2.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn2.guid = fn2.guid || jQuery.guid++;
          return proxy;
        };
        jQuery.holdReady = function(hold) {
          if (hold) {
            jQuery.readyWait++;
          } else {
            jQuery.ready(true);
          }
        };
        jQuery.isArray = Array.isArray;
        jQuery.parseJSON = JSON.parse;
        jQuery.nodeName = nodeName;
        jQuery.isFunction = isFunction;
        jQuery.isWindow = isWindow;
        jQuery.camelCase = camelCase;
        jQuery.type = toType;
        jQuery.now = Date.now;
        jQuery.isNumeric = function(obj) {
          var type = jQuery.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery.noConflict = function(deep) {
          if (window2.$ === jQuery) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery) {
            window2.jQuery = _jQuery;
          }
          return jQuery;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery;
        }
        return jQuery;
      });
    }
  });

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s2) => s2 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s2) => s2 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s2) => s2.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a2 = document.createElement("a");
      a2.href = url;
      a2.href = a2.href;
      a2.protocol = a2.protocol.replace("http", "ws");
      return a2.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/sifter/sifter.js
  var require_sifter = __commonJS({
    "node_modules/sifter/sifter.js"(exports, module) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.Sifter = factory();
        }
      })(exports, function() {
        var Sifter = function(items, settings) {
          this.items = items;
          this.settings = settings || { diacritics: true };
        };
        Sifter.prototype.tokenize = function(query) {
          query = trim(String(query || "").toLowerCase());
          if (!query || !query.length) return [];
          var i2, n2, regex, letter;
          var tokens = [];
          var words = query.split(/ +/);
          for (i2 = 0, n2 = words.length; i2 < n2; i2++) {
            regex = escape_regex(words[i2]);
            if (this.settings.diacritics) {
              for (letter in DIACRITICS) {
                if (DIACRITICS.hasOwnProperty(letter)) {
                  regex = regex.replace(new RegExp(letter, "g"), DIACRITICS[letter]);
                }
              }
            }
            tokens.push({
              string: words[i2],
              regex: new RegExp(regex, "i")
            });
          }
          return tokens;
        };
        Sifter.prototype.iterator = function(object, callback) {
          var iterator;
          if (is_array(object)) {
            iterator = Array.prototype.forEach || function(callback2) {
              for (var i2 = 0, n2 = this.length; i2 < n2; i2++) {
                callback2(this[i2], i2, this);
              }
            };
          } else {
            iterator = function(callback2) {
              for (var key in this) {
                if (this.hasOwnProperty(key)) {
                  callback2(this[key], key, this);
                }
              }
            };
          }
          iterator.apply(object, [callback]);
        };
        Sifter.prototype.getScoreFunction = function(search, options) {
          var self, fields, tokens, token_count, nesting;
          self = this;
          search = self.prepareSearch(search, options);
          tokens = search.tokens;
          fields = search.options.fields;
          token_count = tokens.length;
          nesting = search.options.nesting;
          var scoreValue = function(value, token) {
            var score, pos;
            if (!value) return 0;
            value = String(value || "");
            pos = value.search(token.regex);
            if (pos === -1) return 0;
            score = token.string.length / value.length;
            if (pos === 0) score += 0.5;
            return score;
          };
          var scoreObject = function() {
            var field_count = fields.length;
            if (!field_count) {
              return function() {
                return 0;
              };
            }
            if (field_count === 1) {
              return function(token, data) {
                return scoreValue(getattr(data, fields[0], nesting), token);
              };
            }
            return function(token, data) {
              for (var i2 = 0, sum = 0; i2 < field_count; i2++) {
                sum += scoreValue(getattr(data, fields[i2], nesting), token);
              }
              return sum / field_count;
            };
          }();
          if (!token_count) {
            return function() {
              return 0;
            };
          }
          if (token_count === 1) {
            return function(data) {
              return scoreObject(tokens[0], data);
            };
          }
          if (search.options.conjunction === "and") {
            return function(data) {
              var score;
              for (var i2 = 0, sum = 0; i2 < token_count; i2++) {
                score = scoreObject(tokens[i2], data);
                if (score <= 0) return 0;
                sum += score;
              }
              return sum / token_count;
            };
          } else {
            return function(data) {
              for (var i2 = 0, sum = 0; i2 < token_count; i2++) {
                sum += scoreObject(tokens[i2], data);
              }
              return sum / token_count;
            };
          }
        };
        Sifter.prototype.getSortFunction = function(search, options) {
          var i2, n2, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;
          self = this;
          search = self.prepareSearch(search, options);
          sort = !search.query && options.sort_empty || options.sort;
          get_field = function(name, result) {
            if (name === "$score") return result.score;
            return getattr(self.items[result.id], name, options.nesting);
          };
          fields = [];
          if (sort) {
            for (i2 = 0, n2 = sort.length; i2 < n2; i2++) {
              if (search.query || sort[i2].field !== "$score") {
                fields.push(sort[i2]);
              }
            }
          }
          if (search.query) {
            implicit_score = true;
            for (i2 = 0, n2 = fields.length; i2 < n2; i2++) {
              if (fields[i2].field === "$score") {
                implicit_score = false;
                break;
              }
            }
            if (implicit_score) {
              fields.unshift({ field: "$score", direction: "desc" });
            }
          } else {
            for (i2 = 0, n2 = fields.length; i2 < n2; i2++) {
              if (fields[i2].field === "$score") {
                fields.splice(i2, 1);
                break;
              }
            }
          }
          multipliers = [];
          for (i2 = 0, n2 = fields.length; i2 < n2; i2++) {
            multipliers.push(fields[i2].direction === "desc" ? -1 : 1);
          }
          fields_count = fields.length;
          if (!fields_count) {
            return null;
          } else if (fields_count === 1) {
            field = fields[0].field;
            multiplier = multipliers[0];
            return function(a2, b2) {
              return multiplier * cmp(
                get_field(field, a2),
                get_field(field, b2)
              );
            };
          } else {
            return function(a2, b2) {
              var i3, result, a_value, b_value, field2;
              for (i3 = 0; i3 < fields_count; i3++) {
                field2 = fields[i3].field;
                result = multipliers[i3] * cmp(
                  get_field(field2, a2),
                  get_field(field2, b2)
                );
                if (result) return result;
              }
              return 0;
            };
          }
        };
        Sifter.prototype.prepareSearch = function(query, options) {
          if (typeof query === "object") return query;
          options = extend3({}, options);
          var option_fields = options.fields;
          var option_sort = options.sort;
          var option_sort_empty = options.sort_empty;
          if (option_fields && !is_array(option_fields)) options.fields = [option_fields];
          if (option_sort && !is_array(option_sort)) options.sort = [option_sort];
          if (option_sort_empty && !is_array(option_sort_empty)) options.sort_empty = [option_sort_empty];
          return {
            options,
            query: String(query || "").toLowerCase(),
            tokens: this.tokenize(query),
            total: 0,
            items: []
          };
        };
        Sifter.prototype.search = function(query, options) {
          var self = this, value, score, search, calculateScore;
          var fn_sort;
          var fn_score;
          search = this.prepareSearch(query, options);
          options = search.options;
          query = search.query;
          fn_score = options.score || self.getScoreFunction(search);
          if (query.length) {
            self.iterator(self.items, function(item, id2) {
              score = fn_score(item);
              if (options.filter === false || score > 0) {
                search.items.push({ "score": score, "id": id2 });
              }
            });
          } else {
            self.iterator(self.items, function(item, id2) {
              search.items.push({ "score": 1, "id": id2 });
            });
          }
          fn_sort = self.getSortFunction(search, options);
          if (fn_sort) search.items.sort(fn_sort);
          search.total = search.items.length;
          if (typeof options.limit === "number") {
            search.items = search.items.slice(0, options.limit);
          }
          return search;
        };
        var cmp = function(a2, b2) {
          if (typeof a2 === "number" && typeof b2 === "number") {
            return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
          }
          a2 = asciifold(String(a2 || ""));
          b2 = asciifold(String(b2 || ""));
          if (a2 > b2) return 1;
          if (b2 > a2) return -1;
          return 0;
        };
        var extend3 = function(a2, b2) {
          var i2, n2, k2, object;
          for (i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            object = arguments[i2];
            if (!object) continue;
            for (k2 in object) {
              if (object.hasOwnProperty(k2)) {
                a2[k2] = object[k2];
              }
            }
          }
          return a2;
        };
        var getattr = function(obj, name, nesting) {
          if (!obj || !name) return;
          if (!nesting) return obj[name];
          var names = name.split(".");
          while (names.length && (obj = obj[names.shift()])) ;
          return obj;
        };
        var trim = function(str) {
          return (str + "").replace(/^\s+|\s+$|/g, "");
        };
        var escape_regex = function(str) {
          return (str + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        };
        var is_array = Array.isArray || typeof $ !== "undefined" && $.isArray || function(object) {
          return Object.prototype.toString.call(object) === "[object Array]";
        };
        var DIACRITICS = {
          "a": "[a\u1E00\u1E01\u0102\u0103\xC2\xE2\u01CD\u01CE\u023A\u2C65\u0226\u0227\u1EA0\u1EA1\xC4\xE4\xC0\xE0\xC1\xE1\u0100\u0101\xC3\xE3\xC5\xE5\u0105\u0104\xC3\u0105\u0104]",
          "b": "[b\u2422\u03B2\u0392B\u0E3F\u{10301}\u16D2]",
          "c": "[c\u0106\u0107\u0108\u0109\u010C\u010D\u010A\u010BC\u0304c\u0304\xC7\xE7\u1E08\u1E09\u023B\u023C\u0187\u0188\u0255\u1D04\uFF23\uFF43]",
          "d": "[d\u010E\u010F\u1E0A\u1E0B\u1E10\u1E11\u1E0C\u1E0D\u1E12\u1E13\u1E0E\u1E0F\u0110\u0111D\u0326d\u0326\u0189\u0256\u018A\u0257\u018B\u018C\u1D6D\u1D81\u1D91\u0221\u1D05\uFF24\uFF44\xF0]",
          "e": "[e\xC9\xE9\xC8\xE8\xCA\xEA\u1E18\u1E19\u011A\u011B\u0114\u0115\u1EBC\u1EBD\u1E1A\u1E1B\u1EBA\u1EBB\u0116\u0117\xCB\xEB\u0112\u0113\u0228\u0229\u0118\u0119\u1D92\u0246\u0247\u0204\u0205\u1EBE\u1EBF\u1EC0\u1EC1\u1EC4\u1EC5\u1EC2\u1EC3\u1E1C\u1E1D\u1E16\u1E17\u1E14\u1E15\u0206\u0207\u1EB8\u1EB9\u1EC6\u1EC7\u2C78\u1D07\uFF25\uFF45\u0258\u01DD\u018F\u0190\u03B5]",
          "f": "[f\u0191\u0192\u1E1E\u1E1F]",
          "g": "[g\u0262\u20B2\u01E4\u01E5\u011C\u011D\u011E\u011F\u0122\u0123\u0193\u0260\u0120\u0121]",
          "h": "[h\u0124\u0125\u0126\u0127\u1E28\u1E29\u1E96\u1E96\u1E24\u1E25\u1E22\u1E23\u0266\u02B0\u01F6\u0195]",
          "i": "[i\xCD\xED\xCC\xEC\u012C\u012D\xCE\xEE\u01CF\u01D0\xCF\xEF\u1E2E\u1E2F\u0128\u0129\u012E\u012F\u012A\u012B\u1EC8\u1EC9\u0208\u0209\u020A\u020B\u1ECA\u1ECB\u1E2C\u1E2D\u0197\u0268\u0268\u0306\u1D7B\u1D96\u0130iI\u0131\u026A\uFF29\uFF49]",
          "j": "[j\u0237\u0134\u0135\u0248\u0249\u029D\u025F\u02B2]",
          "k": "[k\u0198\u0199\uA740\uA741\u1E30\u1E31\u01E8\u01E9\u1E32\u1E33\u1E34\u1E35\u03BA\u03F0\u20AD]",
          "l": "[l\u0141\u0142\u013D\u013E\u013B\u013C\u0139\u013A\u1E36\u1E37\u1E38\u1E39\u1E3C\u1E3D\u1E3A\u1E3B\u013F\u0140\u023D\u019A\u2C60\u2C61\u2C62\u026B\u026C\u1D85\u026D\u0234\u029F\uFF2C\uFF4C]",
          "n": "[n\u0143\u0144\u01F8\u01F9\u0147\u0148\xD1\xF1\u1E44\u1E45\u0145\u0146\u1E46\u1E47\u1E4A\u1E4B\u1E48\u1E49N\u0308n\u0308\u019D\u0272\u0220\u019E\u1D70\u1D87\u0273\u0235\u0274\uFF2E\uFF4E\u014A\u014B]",
          "o": "[o\xD8\xF8\xD6\xF6\xD3\xF3\xD2\xF2\xD4\xF4\u01D1\u01D2\u0150\u0151\u014E\u014F\u022E\u022F\u1ECC\u1ECD\u019F\u0275\u01A0\u01A1\u1ECE\u1ECF\u014C\u014D\xD5\xF5\u01EA\u01EB\u020C\u020D\u0555\u0585]",
          "p": "[p\u1E54\u1E55\u1E56\u1E57\u2C63\u1D7D\u01A4\u01A5\u1D71]",
          "q": "[q\uA756\uA757\u02A0\u024A\u024B\uA758\uA759q\u0303]",
          "r": "[r\u0154\u0155\u024C\u024D\u0158\u0159\u0156\u0157\u1E58\u1E59\u0210\u0211\u0212\u0213\u1E5A\u1E5B\u2C64\u027D]",
          "s": "[s\u015A\u015B\u1E60\u1E61\u1E62\u1E63\uA7A8\uA7A9\u015C\u015D\u0160\u0161\u015E\u015F\u0218\u0219S\u0308s\u0308]",
          "t": "[t\u0164\u0165\u1E6A\u1E6B\u0162\u0163\u1E6C\u1E6D\u01AE\u0288\u021A\u021B\u1E70\u1E71\u1E6E\u1E6F\u01AC\u01AD]",
          "u": "[u\u016C\u016D\u0244\u0289\u1EE4\u1EE5\xDC\xFC\xDA\xFA\xD9\xF9\xDB\xFB\u01D3\u01D4\u0170\u0171\u016C\u016D\u01AF\u01B0\u1EE6\u1EE7\u016A\u016B\u0168\u0169\u0172\u0173\u0214\u0215\u222A]",
          "v": "[v\u1E7C\u1E7D\u1E7E\u1E7F\u01B2\u028B\uA75E\uA75F\u2C71\u028B]",
          "w": "[w\u1E82\u1E83\u1E80\u1E81\u0174\u0175\u1E84\u1E85\u1E86\u1E87\u1E88\u1E89]",
          "x": "[x\u1E8C\u1E8D\u1E8A\u1E8B\u03C7]",
          "y": "[y\xDD\xFD\u1EF2\u1EF3\u0176\u0177\u0178\xFF\u1EF8\u1EF9\u1E8E\u1E8F\u1EF4\u1EF5\u024E\u024F\u01B3\u01B4]",
          "z": "[z\u0179\u017A\u1E90\u1E91\u017D\u017E\u017B\u017C\u1E92\u1E93\u1E94\u1E95\u01B5\u01B6]"
        };
        var asciifold = function() {
          var i2, n2, k2, chunk;
          var foreignletters = "";
          var lookup = {};
          for (k2 in DIACRITICS) {
            if (DIACRITICS.hasOwnProperty(k2)) {
              chunk = DIACRITICS[k2].substring(2, DIACRITICS[k2].length - 1);
              foreignletters += chunk;
              for (i2 = 0, n2 = chunk.length; i2 < n2; i2++) {
                lookup[chunk.charAt(i2)] = k2;
              }
            }
          }
          var regexp = new RegExp("[" + foreignletters + "]", "g");
          return function(str) {
            return str.replace(regexp, function(foreignletter) {
              return lookup[foreignletter];
            }).toLowerCase();
          };
        }();
        return Sifter;
      });
    }
  });

  // node_modules/microplugin/src/microplugin.js
  var require_microplugin = __commonJS({
    "node_modules/microplugin/src/microplugin.js"(exports, module) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.MicroPlugin = factory();
        }
      })(exports, function() {
        var MicroPlugin = {};
        MicroPlugin.mixin = function(Interface) {
          Interface.plugins = {};
          Interface.prototype.initializePlugins = function(plugins) {
            var i2, n2, key;
            var self = this;
            var queue = [];
            self.plugins = {
              names: [],
              settings: {},
              requested: {},
              loaded: {}
            };
            if (utils.isArray(plugins)) {
              for (i2 = 0, n2 = plugins.length; i2 < n2; i2++) {
                if (typeof plugins[i2] === "string") {
                  queue.push(plugins[i2]);
                } else {
                  self.plugins.settings[plugins[i2].name] = plugins[i2].options;
                  queue.push(plugins[i2].name);
                }
              }
            } else if (plugins) {
              for (key in plugins) {
                if (plugins.hasOwnProperty(key)) {
                  self.plugins.settings[key] = plugins[key];
                  queue.push(key);
                }
              }
            }
            while (queue.length) {
              self.require(queue.shift());
            }
          };
          Interface.prototype.loadPlugin = function(name) {
            var self = this;
            var plugins = self.plugins;
            var plugin = Interface.plugins[name];
            if (!Interface.plugins.hasOwnProperty(name)) {
              throw new Error('Unable to find "' + name + '" plugin');
            }
            plugins.requested[name] = true;
            plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
            plugins.names.push(name);
          };
          Interface.prototype.require = function(name) {
            var self = this;
            var plugins = self.plugins;
            if (!self.plugins.loaded.hasOwnProperty(name)) {
              if (plugins.requested[name]) {
                throw new Error('Plugin has circular dependency ("' + name + '")');
              }
              self.loadPlugin(name);
            }
            return plugins.loaded[name];
          };
          Interface.define = function(name, fn2) {
            Interface.plugins[name] = {
              "name": name,
              "fn": fn2
            };
          };
        };
        var utils = {
          isArray: Array.isArray || function(vArg) {
            return Object.prototype.toString.call(vArg) === "[object Array]";
          }
        };
        return MicroPlugin;
      });
    }
  });

  // node_modules/selectize/dist/js/selectize.min.js
  var require_selectize_min = __commonJS({
    "node_modules/selectize/dist/js/selectize.min.js"(exports, module) {
      !function(a2, b2) {
        "function" == typeof define && define.amd ? define(["jquery", "sifter", "microplugin"], b2) : "object" == typeof exports ? module.exports = b2(require_jquery(), require_sifter(), require_microplugin()) : a2.Selectize = b2(a2.jQuery, a2.Sifter, a2.MicroPlugin);
      }(exports, function(a2, b2, c2) {
        "use strict";
        var d2 = function(a3, b3) {
          if ("string" != typeof b3 || b3.length) {
            var c3 = "string" == typeof b3 ? new RegExp(b3, "i") : b3, d3 = function(a4) {
              var b4 = 0;
              if (3 === a4.nodeType) {
                var e3 = a4.data.search(c3);
                if (e3 >= 0 && a4.data.length > 0) {
                  var f3 = a4.data.match(c3), g3 = document.createElement("span");
                  g3.className = "highlight";
                  var h3 = a4.splitText(e3), i3 = (h3.splitText(f3[0].length), h3.cloneNode(true));
                  g3.appendChild(i3), h3.parentNode.replaceChild(g3, h3), b4 = 1;
                }
              } else if (1 === a4.nodeType && a4.childNodes && !/(script|style)/i.test(a4.tagName) && ("highlight" !== a4.className || "SPAN" !== a4.tagName)) for (var j3 = 0; j3 < a4.childNodes.length; ++j3) j3 += d3(a4.childNodes[j3]);
              return b4;
            };
            return a3.each(function() {
              d3(this);
            });
          }
        };
        a2.fn.removeHighlight = function() {
          return this.find("span.highlight").each(function() {
            this.parentNode.firstChild.nodeName;
            var a3 = this.parentNode;
            a3.replaceChild(this.firstChild, this), a3.normalize();
          }).end();
        };
        var e2 = function() {
        };
        e2.prototype = { on: function(a3, b3) {
          this._events = this._events || {}, this._events[a3] = this._events[a3] || [], this._events[a3].push(b3);
        }, off: function(a3, b3) {
          var c3 = arguments.length;
          return 0 === c3 ? delete this._events : 1 === c3 ? delete this._events[a3] : (this._events = this._events || {}, void (a3 in this._events != false && this._events[a3].splice(this._events[a3].indexOf(b3), 1)));
        }, trigger: function(a3) {
          if (this._events = this._events || {}, a3 in this._events != false) for (var b3 = 0; b3 < this._events[a3].length; b3++) this._events[a3][b3].apply(this, Array.prototype.slice.call(arguments, 1));
        } }, e2.mixin = function(a3) {
          for (var b3 = ["on", "off", "trigger"], c3 = 0; c3 < b3.length; c3++) a3.prototype[b3[c3]] = e2.prototype[b3[c3]];
        };
        var f2 = /Mac/.test(navigator.userAgent), g2 = f2 ? 91 : 17, h2 = f2 ? 18 : 17, i2 = !/android/i.test(window.navigator.userAgent) && !!document.createElement("input").validity, j2 = function(a3) {
          return void 0 !== a3;
        }, k2 = function(a3) {
          return void 0 === a3 || null === a3 ? null : "boolean" == typeof a3 ? a3 ? "1" : "0" : a3 + "";
        }, l2 = function(a3) {
          return (a3 + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        }, m2 = {};
        m2.before = function(a3, b3, c3) {
          var d3 = a3[b3];
          a3[b3] = function() {
            return c3.apply(a3, arguments), d3.apply(a3, arguments);
          };
        }, m2.after = function(a3, b3, c3) {
          var d3 = a3[b3];
          a3[b3] = function() {
            var b4 = d3.apply(a3, arguments);
            return c3.apply(a3, arguments), b4;
          };
        };
        var n2 = function(a3) {
          var b3 = false;
          return function() {
            b3 || (b3 = true, a3.apply(this, arguments));
          };
        }, o2 = function(a3, b3) {
          var c3;
          return function() {
            var d3 = this, e3 = arguments;
            window.clearTimeout(c3), c3 = window.setTimeout(function() {
              a3.apply(d3, e3);
            }, b3);
          };
        }, p2 = function(a3, b3, c3) {
          var d3, e3 = a3.trigger, f3 = {};
          a3.trigger = function() {
            var c4 = arguments[0];
            if (-1 === b3.indexOf(c4)) return e3.apply(a3, arguments);
            f3[c4] = arguments;
          }, c3.apply(a3, []), a3.trigger = e3;
          for (d3 in f3) f3.hasOwnProperty(d3) && e3.apply(a3, f3[d3]);
        }, q2 = function(a3, b3, c3, d3) {
          a3.on(b3, c3, function(b4) {
            for (var c4 = b4.target; c4 && c4.parentNode !== a3[0]; ) c4 = c4.parentNode;
            return b4.currentTarget = c4, d3.apply(this, [b4]);
          });
        }, r2 = function(a3) {
          var b3 = {};
          if ("selectionStart" in a3) b3.start = a3.selectionStart, b3.length = a3.selectionEnd - b3.start;
          else if (document.selection) {
            a3.focus();
            var c3 = document.selection.createRange(), d3 = document.selection.createRange().text.length;
            c3.moveStart("character", -a3.value.length), b3.start = c3.text.length - d3, b3.length = d3;
          }
          return b3;
        }, s2 = function(a3, b3, c3) {
          var d3, e3, f3 = {};
          if (c3) for (d3 = 0, e3 = c3.length; d3 < e3; d3++) f3[c3[d3]] = a3.css(c3[d3]);
          else f3 = a3.css();
          b3.css(f3);
        }, t3 = function(b3, c3) {
          return b3 ? (w2.$testInput || (w2.$testInput = a2("<span />").css({ position: "absolute", top: -99999, left: -99999, width: "auto", padding: 0, whiteSpace: "pre" }).appendTo("body")), w2.$testInput.text(b3), s2(c3, w2.$testInput, ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"]), w2.$testInput.width()) : 0;
        }, u2 = function(a3) {
          var b3 = null, c3 = function(c4, d3) {
            var e3, f3, g3, h3, i3, j3, k3, l3;
            c4 = c4 || window.event || {}, d3 = d3 || {}, c4.metaKey || c4.altKey || (d3.force || false !== a3.data("grow")) && (e3 = a3.val(), c4.type && "keydown" === c4.type.toLowerCase() && (f3 = c4.keyCode, g3 = f3 >= 48 && f3 <= 57 || f3 >= 65 && f3 <= 90 || f3 >= 96 && f3 <= 111 || f3 >= 186 && f3 <= 222 || 32 === f3, 46 === f3 || 8 === f3 ? (l3 = r2(a3[0]), l3.length ? e3 = e3.substring(0, l3.start) + e3.substring(l3.start + l3.length) : 8 === f3 && l3.start ? e3 = e3.substring(0, l3.start - 1) + e3.substring(l3.start + 1) : 46 === f3 && void 0 !== l3.start && (e3 = e3.substring(0, l3.start) + e3.substring(l3.start + 1))) : g3 && (j3 = c4.shiftKey, k3 = String.fromCharCode(c4.keyCode), k3 = j3 ? k3.toUpperCase() : k3.toLowerCase(), e3 += k3)), h3 = a3.attr("placeholder"), !e3 && h3 && (e3 = h3), (i3 = t3(e3, a3) + 4) !== b3 && (b3 = i3, a3.width(i3), a3.triggerHandler("resize")));
          };
          a3.on("keydown keyup update blur", c3), c3();
        }, v2 = function(a3) {
          var b3 = document.createElement("div");
          return b3.appendChild(a3.cloneNode(true)), b3.innerHTML;
        }, w2 = function(c3, d3) {
          var e3, f3, g3, h3, i3 = this;
          h3 = c3[0], h3.selectize = i3;
          var j3 = window.getComputedStyle && window.getComputedStyle(h3, null);
          if (g3 = j3 ? j3.getPropertyValue("direction") : h3.currentStyle && h3.currentStyle.direction, g3 = g3 || c3.parents("[dir]:first").attr("dir") || "", a2.extend(i3, { order: 0, settings: d3, $input: c3, tabIndex: c3.attr("tabindex") || "", tagType: "select" === h3.tagName.toLowerCase() ? 1 : 2, rtl: /rtl/i.test(g3), eventNS: ".selectize" + ++w2.count, highlightedValue: null, isBlurring: false, isOpen: false, isDisabled: false, isRequired: c3.is("[required]"), isInvalid: false, isLocked: false, isFocused: false, isInputHidden: false, isSetup: false, isShiftDown: false, isCmdDown: false, isCtrlDown: false, ignoreFocus: false, ignoreBlur: false, ignoreHover: false, hasOptions: false, currentResults: null, lastValue: "", caretPos: 0, loading: 0, loadedSearches: {}, $activeOption: null, $activeItems: [], optgroups: {}, options: {}, userOptions: {}, items: [], renderCache: {}, onSearchChange: null === d3.loadThrottle ? i3.onSearchChange : o2(i3.onSearchChange, d3.loadThrottle) }), i3.sifter = new b2(this.options, { diacritics: d3.diacritics }), i3.settings.options) {
            for (e3 = 0, f3 = i3.settings.options.length; e3 < f3; e3++) i3.registerOption(i3.settings.options[e3]);
            delete i3.settings.options;
          }
          if (i3.settings.optgroups) {
            for (e3 = 0, f3 = i3.settings.optgroups.length; e3 < f3; e3++) i3.registerOptionGroup(i3.settings.optgroups[e3]);
            delete i3.settings.optgroups;
          }
          i3.settings.mode = i3.settings.mode || (1 === i3.settings.maxItems ? "single" : "multi"), "boolean" != typeof i3.settings.hideSelected && (i3.settings.hideSelected = "multi" === i3.settings.mode), i3.initializePlugins(i3.settings.plugins), i3.setupCallbacks(), i3.setupTemplates(), i3.setup();
        };
        return e2.mixin(w2), void 0 !== c2 ? c2.mixin(w2) : function(a3, b3) {
          b3 || (b3 = {});
          console.error("Selectize: " + a3), b3.explanation && (console.group && console.group(), console.error(b3.explanation), console.group && console.groupEnd());
        }("Dependency MicroPlugin is missing", { explanation: 'Make sure you either: (1) are using the "standalone" version of Selectize, or (2) require MicroPlugin before you load Selectize.' }), a2.extend(w2.prototype, { setup: function() {
          var b3, c3, d3, e3, j3, k3, l3, m3, n3, o3, p3 = this, r3 = p3.settings, s3 = p3.eventNS, t4 = a2(window), v3 = a2(document), w3 = p3.$input;
          if (l3 = p3.settings.mode, m3 = w3.attr("class") || "", b3 = a2("<div>").addClass(r3.wrapperClass).addClass(m3).addClass(l3), c3 = a2("<div>").addClass(r3.inputClass).addClass("items").appendTo(b3), d3 = a2('<input type="text" autocomplete="off" />').appendTo(c3).attr("tabindex", w3.is(":disabled") ? "-1" : p3.tabIndex), k3 = a2(r3.dropdownParent || b3), e3 = a2("<div>").addClass(r3.dropdownClass).addClass(l3).hide().appendTo(k3), j3 = a2("<div>").addClass(r3.dropdownContentClass).appendTo(e3), (o3 = w3.attr("id")) && (d3.attr("id", o3 + "-selectized"), a2("label[for='" + o3 + "']").attr("for", o3 + "-selectized")), p3.settings.copyClassesToDropdown && e3.addClass(m3), b3.css({ width: w3[0].style.width }), p3.plugins.names.length && (n3 = "plugin-" + p3.plugins.names.join(" plugin-"), b3.addClass(n3), e3.addClass(n3)), (null === r3.maxItems || r3.maxItems > 1) && 1 === p3.tagType && w3.attr("multiple", "multiple"), p3.settings.placeholder && d3.attr("placeholder", r3.placeholder), !p3.settings.splitOn && p3.settings.delimiter) {
            var x2 = p3.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
            p3.settings.splitOn = new RegExp("\\s*" + x2 + "+\\s*");
          }
          w3.attr("autocorrect") && d3.attr("autocorrect", w3.attr("autocorrect")), w3.attr("autocapitalize") && d3.attr("autocapitalize", w3.attr("autocapitalize")), d3[0].type = w3[0].type, p3.$wrapper = b3, p3.$control = c3, p3.$control_input = d3, p3.$dropdown = e3, p3.$dropdown_content = j3, e3.on("mouseenter mousedown click", "[data-disabled]>[data-selectable]", function(a3) {
            a3.stopImmediatePropagation();
          }), e3.on("mouseenter", "[data-selectable]", function() {
            return p3.onOptionHover.apply(p3, arguments);
          }), e3.on("mousedown click", "[data-selectable]", function() {
            return p3.onOptionSelect.apply(p3, arguments);
          }), q2(c3, "mousedown", "*:not(input)", function() {
            return p3.onItemSelect.apply(p3, arguments);
          }), u2(d3), c3.on({ mousedown: function() {
            return p3.onMouseDown.apply(p3, arguments);
          }, click: function() {
            return p3.onClick.apply(p3, arguments);
          } }), d3.on({ mousedown: function(a3) {
            a3.stopPropagation();
          }, keydown: function() {
            return p3.onKeyDown.apply(p3, arguments);
          }, keyup: function() {
            return p3.onKeyUp.apply(p3, arguments);
          }, keypress: function() {
            return p3.onKeyPress.apply(p3, arguments);
          }, resize: function() {
            p3.positionDropdown.apply(p3, []);
          }, blur: function() {
            return p3.onBlur.apply(p3, arguments);
          }, focus: function() {
            return p3.ignoreBlur = false, p3.onFocus.apply(p3, arguments);
          }, paste: function() {
            return p3.onPaste.apply(p3, arguments);
          } }), v3.on("keydown" + s3, function(a3) {
            p3.isCmdDown = a3[f2 ? "metaKey" : "ctrlKey"], p3.isCtrlDown = a3[f2 ? "altKey" : "ctrlKey"], p3.isShiftDown = a3.shiftKey;
          }), v3.on("keyup" + s3, function(a3) {
            a3.keyCode === h2 && (p3.isCtrlDown = false), 16 === a3.keyCode && (p3.isShiftDown = false), a3.keyCode === g2 && (p3.isCmdDown = false);
          }), v3.on("mousedown" + s3, function(a3) {
            if (p3.isFocused) {
              if (a3.target === p3.$dropdown[0] || a3.target.parentNode === p3.$dropdown[0]) return false;
              p3.$control.has(a3.target).length || a3.target === p3.$control[0] || p3.blur(a3.target);
            }
          }), t4.on(["scroll" + s3, "resize" + s3].join(" "), function() {
            p3.isOpen && p3.positionDropdown.apply(p3, arguments);
          }), t4.on("mousemove" + s3, function() {
            p3.ignoreHover = false;
          }), this.revertSettings = { $children: w3.children().detach(), tabindex: w3.attr("tabindex") }, w3.attr("tabindex", -1).hide().after(p3.$wrapper), a2.isArray(r3.items) && (p3.setValue(r3.items), delete r3.items), i2 && w3.on("invalid" + s3, function(a3) {
            a3.preventDefault(), p3.isInvalid = true, p3.refreshState();
          }), p3.updateOriginalInput(), p3.refreshItems(), p3.refreshState(), p3.updatePlaceholder(), p3.isSetup = true, w3.is(":disabled") && p3.disable(), p3.on("change", this.onChange), w3.data("selectize", p3), w3.addClass("selectized"), p3.trigger("initialize"), true === r3.preload && p3.onSearchChange("");
        }, setupTemplates: function() {
          var b3 = this, c3 = b3.settings.labelField, d3 = b3.settings.optgroupLabelField, e3 = { optgroup: function(a3) {
            return '<div class="optgroup">' + a3.html + "</div>";
          }, optgroup_header: function(a3, b4) {
            return '<div class="optgroup-header">' + b4(a3[d3]) + "</div>";
          }, option: function(a3, b4) {
            return '<div class="option">' + b4(a3[c3]) + "</div>";
          }, item: function(a3, b4) {
            return '<div class="item">' + b4(a3[c3]) + "</div>";
          }, option_create: function(a3, b4) {
            return '<div class="create">Add <strong>' + b4(a3.input) + "</strong>&hellip;</div>";
          } };
          b3.settings.render = a2.extend({}, e3, b3.settings.render);
        }, setupCallbacks: function() {
          var a3, b3, c3 = { initialize: "onInitialize", change: "onChange", item_add: "onItemAdd", item_remove: "onItemRemove", clear: "onClear", option_add: "onOptionAdd", option_remove: "onOptionRemove", option_clear: "onOptionClear", optgroup_add: "onOptionGroupAdd", optgroup_remove: "onOptionGroupRemove", optgroup_clear: "onOptionGroupClear", dropdown_open: "onDropdownOpen", dropdown_close: "onDropdownClose", type: "onType", load: "onLoad", focus: "onFocus", blur: "onBlur" };
          for (a3 in c3) c3.hasOwnProperty(a3) && (b3 = this.settings[c3[a3]]) && this.on(a3, b3);
        }, onClick: function(a3) {
          var b3 = this;
          b3.isFocused && b3.isOpen || (b3.focus(), a3.preventDefault());
        }, onMouseDown: function(b3) {
          var c3 = this, d3 = b3.isDefaultPrevented();
          a2(b3.target);
          if (c3.isFocused) {
            if (b3.target !== c3.$control_input[0]) return "single" === c3.settings.mode ? c3.isOpen ? c3.close() : c3.open() : d3 || c3.setActiveItem(null), false;
          } else d3 || window.setTimeout(function() {
            c3.focus();
          }, 0);
        }, onChange: function() {
          this.$input.trigger("change");
        }, onPaste: function(b3) {
          var c3 = this;
          if (c3.isFull() || c3.isInputHidden || c3.isLocked) return void b3.preventDefault();
          c3.settings.splitOn && setTimeout(function() {
            var b4 = c3.$control_input.val();
            if (b4.match(c3.settings.splitOn)) for (var d3 = a2.trim(b4).split(c3.settings.splitOn), e3 = 0, f3 = d3.length; e3 < f3; e3++) c3.createItem(d3[e3]);
          }, 0);
        }, onKeyPress: function(a3) {
          if (this.isLocked) return a3 && a3.preventDefault();
          var b3 = String.fromCharCode(a3.keyCode || a3.which);
          return this.settings.create && "multi" === this.settings.mode && b3 === this.settings.delimiter ? (this.createItem(), a3.preventDefault(), false) : void 0;
        }, onKeyDown: function(a3) {
          var b3 = (a3.target, this.$control_input[0], this);
          if (b3.isLocked) return void (9 !== a3.keyCode && a3.preventDefault());
          switch (a3.keyCode) {
            case 65:
              if (b3.isCmdDown) return void b3.selectAll();
              break;
            case 27:
              return void (b3.isOpen && (a3.preventDefault(), a3.stopPropagation(), b3.close()));
            case 78:
              if (!a3.ctrlKey || a3.altKey) break;
            case 40:
              if (!b3.isOpen && b3.hasOptions) b3.open();
              else if (b3.$activeOption) {
                b3.ignoreHover = true;
                var c3 = b3.getAdjacentOption(b3.$activeOption, 1);
                c3.length && b3.setActiveOption(c3, true, true);
              }
              return void a3.preventDefault();
            case 80:
              if (!a3.ctrlKey || a3.altKey) break;
            case 38:
              if (b3.$activeOption) {
                b3.ignoreHover = true;
                var d3 = b3.getAdjacentOption(b3.$activeOption, -1);
                d3.length && b3.setActiveOption(d3, true, true);
              }
              return void a3.preventDefault();
            case 13:
              return void (b3.isOpen && b3.$activeOption && (b3.onOptionSelect({ currentTarget: b3.$activeOption }), a3.preventDefault()));
            case 37:
              return void b3.advanceSelection(-1, a3);
            case 39:
              return void b3.advanceSelection(1, a3);
            case 9:
              return b3.settings.selectOnTab && b3.isOpen && b3.$activeOption && (b3.onOptionSelect({ currentTarget: b3.$activeOption }), b3.isFull() || a3.preventDefault()), void (b3.settings.create && b3.createItem() && a3.preventDefault());
            case 8:
            case 46:
              return void b3.deleteSelection(a3);
          }
          return !b3.isFull() && !b3.isInputHidden || (f2 ? a3.metaKey : a3.ctrlKey) ? void 0 : void a3.preventDefault();
        }, onKeyUp: function(a3) {
          var b3 = this;
          if (b3.isLocked) return a3 && a3.preventDefault();
          var c3 = b3.$control_input.val() || "";
          b3.lastValue !== c3 && (b3.lastValue = c3, b3.onSearchChange(c3), b3.refreshOptions(), b3.trigger("type", c3));
        }, onSearchChange: function(a3) {
          var b3 = this, c3 = b3.settings.load;
          c3 && (b3.loadedSearches.hasOwnProperty(a3) || (b3.loadedSearches[a3] = true, b3.load(function(d3) {
            c3.apply(b3, [a3, d3]);
          })));
        }, onFocus: function(a3) {
          var b3 = this, c3 = b3.isFocused;
          if (b3.isDisabled) return b3.blur(), a3 && a3.preventDefault(), false;
          b3.ignoreFocus || (b3.isFocused = true, "focus" === b3.settings.preload && b3.onSearchChange(""), c3 || b3.trigger("focus"), b3.$activeItems.length || (b3.showInput(), b3.setActiveItem(null), b3.refreshOptions(!!b3.settings.openOnFocus)), b3.refreshState());
        }, onBlur: function(a3, b3) {
          var c3 = this;
          if (c3.isFocused && (c3.isFocused = false, !c3.ignoreFocus)) {
            if (!c3.ignoreBlur && document.activeElement === c3.$dropdown_content[0]) return c3.ignoreBlur = true, void c3.onFocus(a3);
            var d3 = function() {
              c3.close(), c3.setTextboxValue(""), c3.setActiveItem(null), c3.setActiveOption(null), c3.setCaret(c3.items.length), c3.refreshState(), b3 && b3.focus && b3.focus(), c3.isBlurring = false, c3.ignoreFocus = false, c3.trigger("blur");
            };
            c3.isBlurring = true, c3.ignoreFocus = true, c3.settings.create && c3.settings.createOnBlur ? c3.createItem(null, false, d3) : d3();
          }
        }, onOptionHover: function(a3) {
          this.ignoreHover || this.setActiveOption(a3.currentTarget, false);
        }, onOptionSelect: function(b3) {
          var c3, d3, e3 = this;
          b3.preventDefault && (b3.preventDefault(), b3.stopPropagation()), d3 = a2(b3.currentTarget), d3.hasClass("create") ? e3.createItem(null, function() {
            e3.settings.closeAfterSelect && e3.close();
          }) : void 0 !== (c3 = d3.attr("data-value")) && (e3.lastQuery = null, e3.setTextboxValue(""), e3.addItem(c3), e3.settings.closeAfterSelect ? e3.close() : !e3.settings.hideSelected && b3.type && /mouse/.test(b3.type) && e3.setActiveOption(e3.getOption(c3)));
        }, onItemSelect: function(a3) {
          var b3 = this;
          b3.isLocked || "multi" === b3.settings.mode && (a3.preventDefault(), b3.setActiveItem(a3.currentTarget, a3));
        }, load: function(a3) {
          var b3 = this, c3 = b3.$wrapper.addClass(b3.settings.loadingClass);
          b3.loading++, a3.apply(b3, [function(a4) {
            b3.loading = Math.max(b3.loading - 1, 0), a4 && a4.length && (b3.addOption(a4), b3.refreshOptions(b3.isFocused && !b3.isInputHidden)), b3.loading || c3.removeClass(b3.settings.loadingClass), b3.trigger("load", a4);
          }]);
        }, setTextboxValue: function(a3) {
          var b3 = this.$control_input;
          b3.val() !== a3 && (b3.val(a3).triggerHandler("update"), this.lastValue = a3);
        }, getValue: function() {
          return 1 === this.tagType && this.$input.attr("multiple") ? this.items : this.items.join(this.settings.delimiter);
        }, setValue: function(a3, b3) {
          p2(this, b3 ? [] : ["change"], function() {
            this.clear(b3), this.addItems(a3, b3);
          });
        }, setActiveItem: function(b3, c3) {
          var d3, e3, f3, g3, h3, i3, j3, k3, l3 = this;
          if ("single" !== l3.settings.mode) {
            if (b3 = a2(b3), !b3.length) return a2(l3.$activeItems).removeClass("active"), l3.$activeItems = [], void (l3.isFocused && l3.showInput());
            if ("mousedown" === (d3 = c3 && c3.type.toLowerCase()) && l3.isShiftDown && l3.$activeItems.length) {
              for (k3 = l3.$control.children(".active:last"), g3 = Array.prototype.indexOf.apply(l3.$control[0].childNodes, [k3[0]]), h3 = Array.prototype.indexOf.apply(l3.$control[0].childNodes, [b3[0]]), g3 > h3 && (j3 = g3, g3 = h3, h3 = j3), e3 = g3; e3 <= h3; e3++) i3 = l3.$control[0].childNodes[e3], -1 === l3.$activeItems.indexOf(i3) && (a2(i3).addClass("active"), l3.$activeItems.push(i3));
              c3.preventDefault();
            } else "mousedown" === d3 && l3.isCtrlDown || "keydown" === d3 && this.isShiftDown ? b3.hasClass("active") ? (f3 = l3.$activeItems.indexOf(b3[0]), l3.$activeItems.splice(f3, 1), b3.removeClass("active")) : l3.$activeItems.push(b3.addClass("active")[0]) : (a2(l3.$activeItems).removeClass("active"), l3.$activeItems = [b3.addClass("active")[0]]);
            l3.hideInput(), this.isFocused || l3.focus();
          }
        }, setActiveOption: function(b3, c3, d3) {
          var e3, f3, g3, h3, i3, k3 = this;
          k3.$activeOption && k3.$activeOption.removeClass("active"), k3.$activeOption = null, b3 = a2(b3), b3.length && (k3.$activeOption = b3.addClass("active"), !c3 && j2(c3) || (e3 = k3.$dropdown_content.height(), f3 = k3.$activeOption.outerHeight(true), c3 = k3.$dropdown_content.scrollTop() || 0, g3 = k3.$activeOption.offset().top - k3.$dropdown_content.offset().top + c3, h3 = g3, i3 = g3 - e3 + f3, g3 + f3 > e3 + c3 ? k3.$dropdown_content.stop().animate({ scrollTop: i3 }, d3 ? k3.settings.scrollDuration : 0) : g3 < c3 && k3.$dropdown_content.stop().animate({ scrollTop: h3 }, d3 ? k3.settings.scrollDuration : 0)));
        }, selectAll: function() {
          var a3 = this;
          "single" !== a3.settings.mode && (a3.$activeItems = Array.prototype.slice.apply(a3.$control.children(":not(input)").addClass("active")), a3.$activeItems.length && (a3.hideInput(), a3.close()), a3.focus());
        }, hideInput: function() {
          var a3 = this;
          a3.setTextboxValue(""), a3.$control_input.css({ opacity: 0, position: "absolute", left: a3.rtl ? 1e4 : -1e4 }), a3.isInputHidden = true;
        }, showInput: function() {
          this.$control_input.css({ opacity: 1, position: "relative", left: 0 }), this.isInputHidden = false;
        }, focus: function() {
          var a3 = this;
          a3.isDisabled || (a3.ignoreFocus = true, a3.$control_input[0].focus(), window.setTimeout(function() {
            a3.ignoreFocus = false, a3.onFocus();
          }, 0));
        }, blur: function(a3) {
          this.$control_input[0].blur(), this.onBlur(null, a3);
        }, getScoreFunction: function(a3) {
          return this.sifter.getScoreFunction(a3, this.getSearchOptions());
        }, getSearchOptions: function() {
          var a3 = this.settings, b3 = a3.sortField;
          return "string" == typeof b3 && (b3 = [{ field: b3 }]), { fields: a3.searchField, conjunction: a3.searchConjunction, sort: b3, nesting: a3.nesting };
        }, search: function(b3) {
          var c3, d3, e3, f3 = this, g3 = f3.settings, h3 = this.getSearchOptions();
          if (g3.score && "function" != typeof (e3 = f3.settings.score.apply(this, [b3]))) throw new Error('Selectize "score" setting must be a function that returns a function');
          if (b3 !== f3.lastQuery ? (f3.lastQuery = b3, d3 = f3.sifter.search(b3, a2.extend(h3, { score: e3 })), f3.currentResults = d3) : d3 = a2.extend(true, {}, f3.currentResults), g3.hideSelected) for (c3 = d3.items.length - 1; c3 >= 0; c3--) -1 !== f3.items.indexOf(k2(d3.items[c3].id)) && d3.items.splice(c3, 1);
          return d3;
        }, refreshOptions: function(b3) {
          var c3, e3, f3, g3, h3, i3, j3, l3, m3, n3, o3, p3, q3, r3, s3, t4;
          void 0 === b3 && (b3 = true);
          var u3 = this, w3 = a2.trim(u3.$control_input.val()), x2 = u3.search(w3), y2 = u3.$dropdown_content, z2 = u3.$activeOption && k2(u3.$activeOption.attr("data-value"));
          for (g3 = x2.items.length, "number" == typeof u3.settings.maxOptions && (g3 = Math.min(g3, u3.settings.maxOptions)), h3 = {}, i3 = [], c3 = 0; c3 < g3; c3++) for (j3 = u3.options[x2.items[c3].id], l3 = u3.render("option", j3), m3 = j3[u3.settings.optgroupField] || "", n3 = a2.isArray(m3) ? m3 : [m3], e3 = 0, f3 = n3 && n3.length; e3 < f3; e3++) m3 = n3[e3], u3.optgroups.hasOwnProperty(m3) || (m3 = ""), h3.hasOwnProperty(m3) || (h3[m3] = document.createDocumentFragment(), i3.push(m3)), h3[m3].appendChild(l3);
          for (this.settings.lockOptgroupOrder && i3.sort(function(a3, b4) {
            return (u3.optgroups[a3].$order || 0) - (u3.optgroups[b4].$order || 0);
          }), o3 = document.createDocumentFragment(), c3 = 0, g3 = i3.length; c3 < g3; c3++) m3 = i3[c3], u3.optgroups.hasOwnProperty(m3) && h3[m3].childNodes.length ? (p3 = document.createDocumentFragment(), p3.appendChild(u3.render("optgroup_header", u3.optgroups[m3])), p3.appendChild(h3[m3]), o3.appendChild(u3.render("optgroup", a2.extend({}, u3.optgroups[m3], { html: v2(p3), dom: p3 })))) : o3.appendChild(h3[m3]);
          if (y2.html(o3), u3.settings.highlight && (y2.removeHighlight(), x2.query.length && x2.tokens.length)) for (c3 = 0, g3 = x2.tokens.length; c3 < g3; c3++) d2(y2, x2.tokens[c3].regex);
          if (!u3.settings.hideSelected) for (c3 = 0, g3 = u3.items.length; c3 < g3; c3++) u3.getOption(u3.items[c3]).addClass("selected");
          q3 = u3.canCreate(w3), q3 && (y2.prepend(u3.render("option_create", { input: w3 })), t4 = a2(y2[0].childNodes[0])), u3.hasOptions = x2.items.length > 0 || q3, u3.hasOptions ? (x2.items.length > 0 ? (s3 = z2 && u3.getOption(z2), s3 && s3.length ? r3 = s3 : "single" === u3.settings.mode && u3.items.length && (r3 = u3.getOption(u3.items[0])), r3 && r3.length || (r3 = t4 && !u3.settings.addPrecedence ? u3.getAdjacentOption(t4, 1) : y2.find("[data-selectable]:first"))) : r3 = t4, u3.setActiveOption(r3), b3 && !u3.isOpen && u3.open()) : (u3.setActiveOption(null), b3 && u3.isOpen && u3.close());
        }, addOption: function(b3) {
          var c3, d3, e3, f3 = this;
          if (a2.isArray(b3)) for (c3 = 0, d3 = b3.length; c3 < d3; c3++) f3.addOption(b3[c3]);
          else (e3 = f3.registerOption(b3)) && (f3.userOptions[e3] = true, f3.lastQuery = null, f3.trigger("option_add", e3, b3));
        }, registerOption: function(a3) {
          var b3 = k2(a3[this.settings.valueField]);
          return void 0 !== b3 && null !== b3 && !this.options.hasOwnProperty(b3) && (a3.$order = a3.$order || ++this.order, this.options[b3] = a3, b3);
        }, registerOptionGroup: function(a3) {
          var b3 = k2(a3[this.settings.optgroupValueField]);
          return !!b3 && (a3.$order = a3.$order || ++this.order, this.optgroups[b3] = a3, b3);
        }, addOptionGroup: function(a3, b3) {
          b3[this.settings.optgroupValueField] = a3, (a3 = this.registerOptionGroup(b3)) && this.trigger("optgroup_add", a3, b3);
        }, removeOptionGroup: function(a3) {
          this.optgroups.hasOwnProperty(a3) && (delete this.optgroups[a3], this.renderCache = {}, this.trigger("optgroup_remove", a3));
        }, clearOptionGroups: function() {
          this.optgroups = {}, this.renderCache = {}, this.trigger("optgroup_clear");
        }, updateOption: function(b3, c3) {
          var d3, e3, f3, g3, h3, i3, j3, l3 = this;
          if (b3 = k2(b3), f3 = k2(c3[l3.settings.valueField]), null !== b3 && l3.options.hasOwnProperty(b3)) {
            if ("string" != typeof f3) throw new Error("Value must be set in option data");
            j3 = l3.options[b3].$order, f3 !== b3 && (delete l3.options[b3], -1 !== (g3 = l3.items.indexOf(b3)) && l3.items.splice(g3, 1, f3)), c3.$order = c3.$order || j3, l3.options[f3] = c3, h3 = l3.renderCache.item, i3 = l3.renderCache.option, h3 && (delete h3[b3], delete h3[f3]), i3 && (delete i3[b3], delete i3[f3]), -1 !== l3.items.indexOf(f3) && (d3 = l3.getItem(b3), e3 = a2(l3.render("item", c3)), d3.hasClass("active") && e3.addClass("active"), d3.replaceWith(e3)), l3.lastQuery = null, l3.isOpen && l3.refreshOptions(false);
          }
        }, removeOption: function(a3, b3) {
          var c3 = this;
          a3 = k2(a3);
          var d3 = c3.renderCache.item, e3 = c3.renderCache.option;
          d3 && delete d3[a3], e3 && delete e3[a3], delete c3.userOptions[a3], delete c3.options[a3], c3.lastQuery = null, c3.trigger("option_remove", a3), c3.removeItem(a3, b3);
        }, clearOptions: function() {
          var b3 = this;
          b3.loadedSearches = {}, b3.userOptions = {}, b3.renderCache = {};
          var c3 = b3.options;
          a2.each(b3.options, function(a3, d3) {
            -1 == b3.items.indexOf(a3) && delete c3[a3];
          }), b3.options = b3.sifter.items = c3, b3.lastQuery = null, b3.trigger("option_clear");
        }, getOption: function(a3) {
          return this.getElementWithValue(a3, this.$dropdown_content.find("[data-selectable]"));
        }, getAdjacentOption: function(b3, c3) {
          var d3 = this.$dropdown.find("[data-selectable]"), e3 = d3.index(b3) + c3;
          return e3 >= 0 && e3 < d3.length ? d3.eq(e3) : a2();
        }, getElementWithValue: function(b3, c3) {
          if (void 0 !== (b3 = k2(b3)) && null !== b3) {
            for (var d3 = 0, e3 = c3.length; d3 < e3; d3++) if (c3[d3].getAttribute("data-value") === b3) return a2(c3[d3]);
          }
          return a2();
        }, getItem: function(a3) {
          return this.getElementWithValue(a3, this.$control.children());
        }, addItems: function(b3, c3) {
          this.buffer = document.createDocumentFragment();
          for (var d3 = this.$control[0].childNodes, e3 = 0; e3 < d3.length; e3++) this.buffer.appendChild(d3[e3]);
          for (var f3 = a2.isArray(b3) ? b3 : [b3], e3 = 0, g3 = f3.length; e3 < g3; e3++) this.isPending = e3 < g3 - 1, this.addItem(f3[e3], c3);
          var h3 = this.$control[0];
          h3.insertBefore(this.buffer, h3.firstChild), this.buffer = null;
        }, addItem: function(b3, c3) {
          p2(this, c3 ? [] : ["change"], function() {
            var d3, e3, f3, g3, h3, i3 = this, j3 = i3.settings.mode;
            if (b3 = k2(b3), -1 !== i3.items.indexOf(b3)) return void ("single" === j3 && i3.close());
            i3.options.hasOwnProperty(b3) && ("single" === j3 && i3.clear(c3), "multi" === j3 && i3.isFull() || (d3 = a2(i3.render("item", i3.options[b3])), h3 = i3.isFull(), i3.items.splice(i3.caretPos, 0, b3), i3.insertAtCaret(d3), (!i3.isPending || !h3 && i3.isFull()) && i3.refreshState(), i3.isSetup && (f3 = i3.$dropdown_content.find("[data-selectable]"), i3.isPending || (e3 = i3.getOption(b3), g3 = i3.getAdjacentOption(e3, 1).attr("data-value"), i3.refreshOptions(i3.isFocused && "single" !== j3), g3 && i3.setActiveOption(i3.getOption(g3))), !f3.length || i3.isFull() ? i3.close() : i3.isPending || i3.positionDropdown(), i3.updatePlaceholder(), i3.trigger("item_add", b3, d3), i3.isPending || i3.updateOriginalInput({ silent: c3 }))));
          });
        }, removeItem: function(b3, c3) {
          var d3, e3, f3, g3 = this;
          d3 = b3 instanceof a2 ? b3 : g3.getItem(b3), b3 = k2(d3.attr("data-value")), -1 !== (e3 = g3.items.indexOf(b3)) && (d3.remove(), d3.hasClass("active") && (f3 = g3.$activeItems.indexOf(d3[0]), g3.$activeItems.splice(f3, 1)), g3.items.splice(e3, 1), g3.lastQuery = null, !g3.settings.persist && g3.userOptions.hasOwnProperty(b3) && g3.removeOption(b3, c3), e3 < g3.caretPos && g3.setCaret(g3.caretPos - 1), g3.refreshState(), g3.updatePlaceholder(), g3.updateOriginalInput({ silent: c3 }), g3.positionDropdown(), g3.trigger("item_remove", b3, d3));
        }, createItem: function(b3, c3) {
          var d3 = this, e3 = d3.caretPos;
          b3 = b3 || a2.trim(d3.$control_input.val() || "");
          var f3 = arguments[arguments.length - 1];
          if ("function" != typeof f3 && (f3 = function() {
          }), "boolean" != typeof c3 && (c3 = true), !d3.canCreate(b3)) return f3(), false;
          d3.lock();
          var g3 = "function" == typeof d3.settings.create ? this.settings.create : function(a3) {
            var b4 = {};
            return b4[d3.settings.labelField] = a3, b4[d3.settings.valueField] = a3, b4;
          }, h3 = n2(function(a3) {
            if (d3.unlock(), !a3 || "object" != typeof a3) return f3();
            var b4 = k2(a3[d3.settings.valueField]);
            if ("string" != typeof b4) return f3();
            d3.setTextboxValue(""), d3.addOption(a3), d3.setCaret(e3), d3.addItem(b4), d3.refreshOptions(c3 && "single" !== d3.settings.mode), f3(a3);
          }), i3 = g3.apply(this, [b3, h3]);
          return void 0 !== i3 && h3(i3), true;
        }, refreshItems: function() {
          this.lastQuery = null, this.isSetup && this.addItem(this.items), this.refreshState(), this.updateOriginalInput();
        }, refreshState: function() {
          this.refreshValidityState(), this.refreshClasses();
        }, refreshValidityState: function() {
          if (!this.isRequired) return false;
          var a3 = !this.items.length;
          this.isInvalid = a3, this.$control_input.prop("required", a3), this.$input.prop("required", !a3);
        }, refreshClasses: function() {
          var b3 = this, c3 = b3.isFull(), d3 = b3.isLocked;
          b3.$wrapper.toggleClass("rtl", b3.rtl), b3.$control.toggleClass("focus", b3.isFocused).toggleClass("disabled", b3.isDisabled).toggleClass("required", b3.isRequired).toggleClass("invalid", b3.isInvalid).toggleClass("locked", d3).toggleClass("full", c3).toggleClass("not-full", !c3).toggleClass("input-active", b3.isFocused && !b3.isInputHidden).toggleClass("dropdown-active", b3.isOpen).toggleClass("has-options", !a2.isEmptyObject(b3.options)).toggleClass("has-items", b3.items.length > 0), b3.$control_input.data("grow", !c3 && !d3);
        }, isFull: function() {
          return null !== this.settings.maxItems && this.items.length >= this.settings.maxItems;
        }, updateOriginalInput: function(a3) {
          var b3, c3, d3, e3, f3 = this;
          if (a3 = a3 || {}, 1 === f3.tagType) {
            for (d3 = [], b3 = 0, c3 = f3.items.length; b3 < c3; b3++) e3 = f3.options[f3.items[b3]][f3.settings.labelField] || "", d3.push('<option value="' + l2(f3.items[b3]) + '" selected="selected">' + l2(e3) + "</option>");
            d3.length || this.$input.attr("multiple") || d3.push('<option value="" selected="selected"></option>'), f3.$input.html(d3.join(""));
          } else f3.$input.val(f3.getValue()), f3.$input.attr("value", f3.$input.val());
          f3.isSetup && (a3.silent || f3.trigger("change", f3.$input.val()));
        }, updatePlaceholder: function() {
          if (this.settings.placeholder) {
            var a3 = this.$control_input;
            this.items.length ? a3.removeAttr("placeholder") : a3.attr("placeholder", this.settings.placeholder), a3.triggerHandler("update", { force: true });
          }
        }, open: function() {
          var a3 = this;
          a3.isLocked || a3.isOpen || "multi" === a3.settings.mode && a3.isFull() || (a3.focus(), a3.isOpen = true, a3.refreshState(), a3.$dropdown.css({ visibility: "hidden", display: "block" }), a3.positionDropdown(), a3.$dropdown.css({ visibility: "visible" }), a3.trigger("dropdown_open", a3.$dropdown));
        }, close: function() {
          var a3 = this, b3 = a3.isOpen;
          "single" === a3.settings.mode && a3.items.length && (a3.hideInput(), a3.isBlurring || a3.$control_input.blur()), a3.isOpen = false, a3.$dropdown.hide(), a3.setActiveOption(null), a3.refreshState(), b3 && a3.trigger("dropdown_close", a3.$dropdown);
        }, positionDropdown: function() {
          var a3 = this.$control, b3 = "body" === this.settings.dropdownParent ? a3.offset() : a3.position();
          b3.top += a3.outerHeight(true), this.$dropdown.css({ width: a3[0].getBoundingClientRect().width, top: b3.top, left: b3.left });
        }, clear: function(a3) {
          var b3 = this;
          b3.items.length && (b3.$control.children(":not(input)").remove(), b3.items = [], b3.lastQuery = null, b3.setCaret(0), b3.setActiveItem(null), b3.updatePlaceholder(), b3.updateOriginalInput({ silent: a3 }), b3.refreshState(), b3.showInput(), b3.trigger("clear"));
        }, insertAtCaret: function(a3) {
          var b3 = Math.min(this.caretPos, this.items.length), c3 = a3[0], d3 = this.buffer || this.$control[0];
          0 === b3 ? d3.insertBefore(c3, d3.firstChild) : d3.insertBefore(c3, d3.childNodes[b3]), this.setCaret(b3 + 1);
        }, deleteSelection: function(b3) {
          var c3, d3, e3, f3, g3, h3, i3, j3, k3, l3 = this;
          if (e3 = b3 && 8 === b3.keyCode ? -1 : 1, f3 = r2(l3.$control_input[0]), l3.$activeOption && !l3.settings.hideSelected && (i3 = l3.getAdjacentOption(l3.$activeOption, -1).attr("data-value")), g3 = [], l3.$activeItems.length) {
            for (k3 = l3.$control.children(".active:" + (e3 > 0 ? "last" : "first")), h3 = l3.$control.children(":not(input)").index(k3), e3 > 0 && h3++, c3 = 0, d3 = l3.$activeItems.length; c3 < d3; c3++) g3.push(a2(l3.$activeItems[c3]).attr("data-value"));
            b3 && (b3.preventDefault(), b3.stopPropagation());
          } else (l3.isFocused || "single" === l3.settings.mode) && l3.items.length && (e3 < 0 && 0 === f3.start && 0 === f3.length ? g3.push(l3.items[l3.caretPos - 1]) : e3 > 0 && f3.start === l3.$control_input.val().length && g3.push(l3.items[l3.caretPos]));
          if (!g3.length || "function" == typeof l3.settings.onDelete && false === l3.settings.onDelete.apply(l3, [g3])) return false;
          for (void 0 !== h3 && l3.setCaret(h3); g3.length; ) l3.removeItem(g3.pop());
          return l3.showInput(), l3.positionDropdown(), l3.refreshOptions(true), i3 && (j3 = l3.getOption(i3), j3.length && l3.setActiveOption(j3)), true;
        }, advanceSelection: function(a3, b3) {
          var c3, d3, e3, f3, g3, h3 = this;
          0 !== a3 && (h3.rtl && (a3 *= -1), c3 = a3 > 0 ? "last" : "first", d3 = r2(h3.$control_input[0]), h3.isFocused && !h3.isInputHidden ? (f3 = h3.$control_input.val().length, (a3 < 0 ? 0 === d3.start && 0 === d3.length : d3.start === f3) && !f3 && h3.advanceCaret(a3, b3)) : (g3 = h3.$control.children(".active:" + c3), g3.length && (e3 = h3.$control.children(":not(input)").index(g3), h3.setActiveItem(null), h3.setCaret(a3 > 0 ? e3 + 1 : e3))));
        }, advanceCaret: function(a3, b3) {
          var c3, d3, e3 = this;
          0 !== a3 && (c3 = a3 > 0 ? "next" : "prev", e3.isShiftDown ? (d3 = e3.$control_input[c3](), d3.length && (e3.hideInput(), e3.setActiveItem(d3), b3 && b3.preventDefault())) : e3.setCaret(e3.caretPos + a3));
        }, setCaret: function(b3) {
          var c3 = this;
          if (b3 = "single" === c3.settings.mode ? c3.items.length : Math.max(0, Math.min(c3.items.length, b3)), !c3.isPending) {
            var d3, e3, f3, g3;
            for (f3 = c3.$control.children(":not(input)"), d3 = 0, e3 = f3.length; d3 < e3; d3++) g3 = a2(f3[d3]).detach(), d3 < b3 ? c3.$control_input.before(g3) : c3.$control.append(g3);
          }
          c3.caretPos = b3;
        }, lock: function() {
          this.close(), this.isLocked = true, this.refreshState();
        }, unlock: function() {
          this.isLocked = false, this.refreshState();
        }, disable: function() {
          var a3 = this;
          a3.$input.prop("disabled", true), a3.$control_input.prop("disabled", true).prop("tabindex", -1), a3.isDisabled = true, a3.lock();
        }, enable: function() {
          var a3 = this;
          a3.$input.prop("disabled", false), a3.$control_input.prop("disabled", false).prop("tabindex", a3.tabIndex), a3.isDisabled = false, a3.unlock();
        }, destroy: function() {
          var b3 = this, c3 = b3.eventNS, d3 = b3.revertSettings;
          b3.trigger("destroy"), b3.off(), b3.$wrapper.remove(), b3.$dropdown.remove(), b3.$input.html("").append(d3.$children).removeAttr("tabindex").removeClass("selectized").attr({ tabindex: d3.tabindex }).show(), b3.$control_input.removeData("grow"), b3.$input.removeData("selectize"), 0 == --w2.count && w2.$testInput && (w2.$testInput.remove(), w2.$testInput = void 0), a2(window).off(c3), a2(document).off(c3), a2(document.body).off(c3), delete b3.$input[0].selectize;
        }, render: function(b3, c3) {
          var d3, e3, f3 = "", g3 = false, h3 = this;
          return "option" !== b3 && "item" !== b3 || (d3 = k2(c3[h3.settings.valueField]), g3 = !!d3), g3 && (j2(h3.renderCache[b3]) || (h3.renderCache[b3] = {}), h3.renderCache[b3].hasOwnProperty(d3)) ? h3.renderCache[b3][d3] : (f3 = a2(h3.settings.render[b3].apply(this, [c3, l2])), "option" === b3 || "option_create" === b3 ? c3[h3.settings.disabledField] || f3.attr("data-selectable", "") : "optgroup" === b3 && (e3 = c3[h3.settings.optgroupValueField] || "", f3.attr("data-group", e3), c3[h3.settings.disabledField] && f3.attr("data-disabled", "")), "option" !== b3 && "item" !== b3 || f3.attr("data-value", d3 || ""), g3 && (h3.renderCache[b3][d3] = f3[0]), f3[0]);
        }, clearCache: function(a3) {
          var b3 = this;
          void 0 === a3 ? b3.renderCache = {} : delete b3.renderCache[a3];
        }, canCreate: function(a3) {
          var b3 = this;
          if (!b3.settings.create) return false;
          var c3 = b3.settings.createFilter;
          return a3.length && ("function" != typeof c3 || c3.apply(b3, [a3])) && ("string" != typeof c3 || new RegExp(c3).test(a3)) && (!(c3 instanceof RegExp) || c3.test(a3));
        } }), w2.count = 0, w2.defaults = {
          options: [],
          optgroups: [],
          plugins: [],
          delimiter: ",",
          splitOn: null,
          persist: true,
          diacritics: true,
          create: false,
          createOnBlur: false,
          createFilter: null,
          highlight: true,
          openOnFocus: true,
          maxOptions: 1e3,
          maxItems: null,
          hideSelected: null,
          addPrecedence: false,
          selectOnTab: false,
          preload: false,
          allowEmptyOption: false,
          closeAfterSelect: false,
          scrollDuration: 60,
          loadThrottle: 300,
          loadingClass: "loading",
          dataAttr: "data-data",
          optgroupField: "optgroup",
          valueField: "value",
          labelField: "text",
          disabledField: "disabled",
          optgroupLabelField: "label",
          optgroupValueField: "value",
          lockOptgroupOrder: false,
          sortField: "$order",
          searchField: ["text"],
          searchConjunction: "and",
          mode: null,
          wrapperClass: "selectize-control",
          inputClass: "selectize-input",
          dropdownClass: "selectize-dropdown",
          dropdownContentClass: "selectize-dropdown-content",
          dropdownParent: null,
          copyClassesToDropdown: true,
          render: {}
        }, a2.fn.selectize = function(b3) {
          var c3 = a2.fn.selectize.defaults, d3 = a2.extend({}, c3, b3), e3 = d3.dataAttr, f3 = d3.labelField, g3 = d3.valueField, h3 = d3.disabledField, i3 = d3.optgroupField, j3 = d3.optgroupLabelField, l3 = d3.optgroupValueField, m3 = function(b4, c4) {
            var h4, i4, j4, k3, l4 = b4.attr(e3);
            if (l4) for (c4.options = JSON.parse(l4), h4 = 0, i4 = c4.options.length; h4 < i4; h4++) c4.items.push(c4.options[h4][g3]);
            else {
              var m4 = a2.trim(b4.val() || "");
              if (!d3.allowEmptyOption && !m4.length) return;
              for (j4 = m4.split(d3.delimiter), h4 = 0, i4 = j4.length; h4 < i4; h4++) k3 = {}, k3[f3] = j4[h4], k3[g3] = j4[h4], c4.options.push(k3);
              c4.items = j4;
            }
          }, n3 = function(b4, c4) {
            var m4, n4, o3, p3, q3 = c4.options, r3 = {}, s3 = function(a3) {
              var b5 = e3 && a3.attr(e3);
              return "string" == typeof b5 && b5.length ? JSON.parse(b5) : null;
            }, t4 = function(b5, e4) {
              b5 = a2(b5);
              var j4 = k2(b5.val());
              if (j4 || d3.allowEmptyOption) if (r3.hasOwnProperty(j4)) {
                if (e4) {
                  var l4 = r3[j4][i3];
                  l4 ? a2.isArray(l4) ? l4.push(e4) : r3[j4][i3] = [l4, e4] : r3[j4][i3] = e4;
                }
              } else {
                var m5 = s3(b5) || {};
                m5[f3] = m5[f3] || b5.text(), m5[g3] = m5[g3] || j4, m5[h3] = m5[h3] || b5.prop("disabled"), m5[i3] = m5[i3] || e4, r3[j4] = m5, q3.push(m5), b5.is(":selected") && c4.items.push(j4);
              }
            };
            for (c4.maxItems = b4.attr("multiple") ? null : 1, p3 = b4.children(), m4 = 0, n4 = p3.length; m4 < n4; m4++) o3 = p3[m4].tagName.toLowerCase(), "optgroup" === o3 ? function(b5) {
              var d4, e4, f4, g4, i4;
              for (b5 = a2(b5), f4 = b5.attr("label"), f4 && (g4 = s3(b5) || {}, g4[j3] = f4, g4[l3] = f4, g4[h3] = b5.prop("disabled"), c4.optgroups.push(g4)), i4 = a2("option", b5), d4 = 0, e4 = i4.length; d4 < e4; d4++) t4(i4[d4], f4);
            }(p3[m4]) : "option" === o3 && t4(p3[m4]);
          };
          return this.each(function() {
            if (!this.selectize) {
              var e4 = a2(this), f4 = this.tagName.toLowerCase(), g4 = e4.attr("placeholder") || e4.attr("data-placeholder");
              g4 || d3.allowEmptyOption || (g4 = e4.children('option[value=""]').text());
              var h4 = { placeholder: g4, options: [], optgroups: [], items: [] };
              "select" === f4 ? n3(e4, h4) : m3(e4, h4), new w2(e4, a2.extend(true, {}, c3, h4, b3));
            }
          });
        }, a2.fn.selectize.defaults = w2.defaults, a2.fn.selectize.support = { validity: i2 }, w2.define("drag_drop", function(b3) {
          if (!a2.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
          if ("multi" === this.settings.mode) {
            var c3 = this;
            c3.lock = function() {
              var a3 = c3.lock;
              return function() {
                var b4 = c3.$control.data("sortable");
                return b4 && b4.disable(), a3.apply(c3, arguments);
              };
            }(), c3.unlock = function() {
              var a3 = c3.unlock;
              return function() {
                var b4 = c3.$control.data("sortable");
                return b4 && b4.enable(), a3.apply(c3, arguments);
              };
            }(), c3.setup = function() {
              var b4 = c3.setup;
              return function() {
                b4.apply(this, arguments);
                var d3 = c3.$control.sortable({ items: "[data-value]", forcePlaceholderSize: true, disabled: c3.isLocked, start: function(a3, b5) {
                  b5.placeholder.css("width", b5.helper.css("width")), d3.css({ overflow: "visible" });
                }, stop: function() {
                  d3.css({ overflow: "hidden" });
                  var b5 = c3.$activeItems ? c3.$activeItems.slice() : null, e3 = [];
                  d3.children("[data-value]").each(function() {
                    e3.push(a2(this).attr("data-value"));
                  }), c3.setValue(e3), c3.setActiveItem(b5);
                } });
              };
            }();
          }
        }), w2.define("dropdown_header", function(b3) {
          var c3 = this;
          b3 = a2.extend({ title: "Untitled", headerClass: "selectize-dropdown-header", titleRowClass: "selectize-dropdown-header-title", labelClass: "selectize-dropdown-header-label", closeClass: "selectize-dropdown-header-close", html: function(a3) {
            return '<div class="' + a3.headerClass + '"><div class="' + a3.titleRowClass + '"><span class="' + a3.labelClass + '">' + a3.title + '</span><a href="javascript:void(0)" class="' + a3.closeClass + '">&times;</a></div></div>';
          } }, b3), c3.setup = function() {
            var d3 = c3.setup;
            return function() {
              d3.apply(c3, arguments), c3.$dropdown_header = a2(b3.html(b3)), c3.$dropdown.prepend(c3.$dropdown_header);
            };
          }();
        }), w2.define("optgroup_columns", function(b3) {
          var c3 = this;
          b3 = a2.extend({ equalizeWidth: true, equalizeHeight: true }, b3), this.getAdjacentOption = function(b4, c4) {
            var d4 = b4.closest("[data-group]").find("[data-selectable]"), e4 = d4.index(b4) + c4;
            return e4 >= 0 && e4 < d4.length ? d4.eq(e4) : a2();
          }, this.onKeyDown = function() {
            var a3 = c3.onKeyDown;
            return function(b4) {
              var d4, e4, f3, g3;
              return !this.isOpen || 37 !== b4.keyCode && 39 !== b4.keyCode ? a3.apply(this, arguments) : (c3.ignoreHover = true, g3 = this.$activeOption.closest("[data-group]"), d4 = g3.find("[data-selectable]").index(this.$activeOption), g3 = 37 === b4.keyCode ? g3.prev("[data-group]") : g3.next("[data-group]"), f3 = g3.find("[data-selectable]"), e4 = f3.eq(Math.min(f3.length - 1, d4)), void (e4.length && this.setActiveOption(e4)));
            };
          }();
          var d3 = function() {
            var a3, b4 = d3.width, c4 = document;
            return void 0 === b4 && (a3 = c4.createElement("div"), a3.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>', a3 = a3.firstChild, c4.body.appendChild(a3), b4 = d3.width = a3.offsetWidth - a3.clientWidth, c4.body.removeChild(a3)), b4;
          }, e3 = function() {
            var e4, f3, g3, h3, i3, j3, k3;
            if (k3 = a2("[data-group]", c3.$dropdown_content), (f3 = k3.length) && c3.$dropdown_content.width()) {
              if (b3.equalizeHeight) {
                for (g3 = 0, e4 = 0; e4 < f3; e4++) g3 = Math.max(g3, k3.eq(e4).height());
                k3.css({ height: g3 });
              }
              b3.equalizeWidth && (j3 = c3.$dropdown_content.innerWidth() - d3(), h3 = Math.round(j3 / f3), k3.css({ width: h3 }), f3 > 1 && (i3 = j3 - h3 * (f3 - 1), k3.eq(f3 - 1).css({ width: i3 })));
            }
          };
          (b3.equalizeHeight || b3.equalizeWidth) && (m2.after(this, "positionDropdown", e3), m2.after(this, "refreshOptions", e3));
        }), w2.define("remove_button", function(b3) {
          b3 = a2.extend({ label: "&times;", title: "Remove", className: "remove", append: true }, b3);
          if ("single" === this.settings.mode) return void function(b4, c3) {
            c3.className = "remove-single";
            var d3 = b4, e3 = '<a href="javascript:void(0)" class="' + c3.className + '" tabindex="-1" title="' + l2(c3.title) + '">' + c3.label + "</a>", f3 = function(b5, c4) {
              return a2("<span>").append(b5).append(c4);
            };
            b4.setup = function() {
              var g3 = d3.setup;
              return function() {
                if (c3.append) {
                  var h3 = a2(d3.$input.context).attr("id"), i3 = (a2("#" + h3), d3.settings.render.item);
                  d3.settings.render.item = function(a3) {
                    return f3(i3.apply(b4, arguments), e3);
                  };
                }
                g3.apply(b4, arguments), b4.$control.on("click", "." + c3.className, function(a3) {
                  a3.preventDefault(), d3.isLocked || d3.clear();
                });
              };
            }();
          }(this, b3);
          !function(b4, c3) {
            var d3 = b4, e3 = '<a href="javascript:void(0)" class="' + c3.className + '" tabindex="-1" title="' + l2(c3.title) + '">' + c3.label + "</a>", f3 = function(a3, b5) {
              var c4 = a3.search(/(<\/[^>]+>\s*)$/);
              return a3.substring(0, c4) + b5 + a3.substring(c4);
            };
            b4.setup = function() {
              var g3 = d3.setup;
              return function() {
                if (c3.append) {
                  var h3 = d3.settings.render.item;
                  d3.settings.render.item = function(a3) {
                    return f3(h3.apply(b4, arguments), e3);
                  };
                }
                g3.apply(b4, arguments), b4.$control.on("click", "." + c3.className, function(b5) {
                  if (b5.preventDefault(), !d3.isLocked) {
                    var c4 = a2(b5.currentTarget).parent();
                    d3.setActiveItem(c4), d3.deleteSelection() && d3.setCaret(d3.items.length);
                  }
                });
              };
            }();
          }(this, b3);
        }), w2.define("restore_on_backspace", function(a3) {
          var b3 = this;
          a3.text = a3.text || function(a4) {
            return a4[this.settings.labelField];
          }, this.onKeyDown = function() {
            var c3 = b3.onKeyDown;
            return function(b4) {
              var d3, e3;
              return 8 === b4.keyCode && "" === this.$control_input.val() && !this.$activeItems.length && (d3 = this.caretPos - 1) >= 0 && d3 < this.items.length ? (e3 = this.options[this.items[d3]], this.deleteSelection(b4) && (this.setTextboxValue(a3.text.apply(this, [e3])), this.refreshOptions(true)), void b4.preventDefault()) : c3.apply(this, arguments);
            };
          }();
        }), w2;
      });
    }
  });

  // app/assets/javascripts/administrate/add_jquery.js
  var import_jquery = __toESM(require_jquery());
  window.jQuery = import_jquery.default;
  window.$ = import_jquery.default;

  // node_modules/trix/dist/trix.esm.min.js
  var t = "2.1.15";
  var e = "[data-trix-attachment]";
  var i = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
  var n = { default: { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, htmlAttributes: ["language"], text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test(t3) {
    return r(t3.parentNode) === n[this.listAttribute].tagName;
  } }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test(t3) {
    return r(t3.parentNode) === n[this.listAttribute].tagName;
  } }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
  var r = (t3) => {
    var e2;
    return null == t3 || null === (e2 = t3.tagName) || void 0 === e2 ? void 0 : e2.toLowerCase();
  };
  var o = navigator.userAgent.match(/android\s([0-9]+.*Chrome)/i);
  var s = o && parseInt(o[1]);
  var a = { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), recentAndroid: s && s > 12, samsungAndroid: s && navigator.userAgent.match(/Android.*SM-/), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: "undefined" != typeof InputEvent && ["data", "getTargetRanges", "inputType"].every((t3) => t3 in InputEvent.prototype) };
  var l = { ADD_ATTR: ["language"], SAFE_FOR_XML: false, RETURN_DOM: true };
  var c = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
  var u = [c.bytes, c.KB, c.MB, c.GB, c.TB, c.PB];
  var h = { prefix: "IEC", precision: 2, formatter(t3) {
    switch (t3) {
      case 0:
        return "0 ".concat(c.bytes);
      case 1:
        return "1 ".concat(c.byte);
      default:
        let e2;
        "SI" === this.prefix ? e2 = 1e3 : "IEC" === this.prefix && (e2 = 1024);
        const i2 = Math.floor(Math.log(t3) / Math.log(e2)), n2 = (t3 / Math.pow(e2, i2)).toFixed(this.precision).replace(/0*$/, "").replace(/\.$/, "");
        return "".concat(n2, " ").concat(u[i2]);
    }
  } };
  var d = "\uFEFF";
  var g = "\xA0";
  var m = function(t3) {
    for (const e2 in t3) {
      const i2 = t3[e2];
      this[e2] = i2;
    }
    return this;
  };
  var p = document.documentElement;
  var f = p.matches;
  var b = function(t3) {
    let { onElement: e2, matchingSelector: i2, withCallback: n2, inPhase: r2, preventDefault: o2, times: s2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const a2 = e2 || p, l2 = i2, c2 = "capturing" === r2, u2 = function(t4) {
      null != s2 && 0 == --s2 && u2.destroy();
      const e3 = y(t4.target, { matchingSelector: l2 });
      null != e3 && (null == n2 || n2.call(e3, t4, e3), o2 && t4.preventDefault());
    };
    return u2.destroy = () => a2.removeEventListener(t3, u2, c2), a2.addEventListener(t3, u2, c2), u2;
  };
  var v = function(t3) {
    let { onElement: e2, bubbles: i2, cancelable: n2, attributes: r2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const o2 = null != e2 ? e2 : p;
    i2 = false !== i2, n2 = false !== n2;
    const s2 = document.createEvent("Events");
    return s2.initEvent(t3, i2, n2), null != r2 && m.call(s2, r2), o2.dispatchEvent(s2);
  };
  var A = function(t3, e2) {
    if (1 === (null == t3 ? void 0 : t3.nodeType)) return f.call(t3, e2);
  };
  var y = function(t3) {
    let { matchingSelector: e2, untilNode: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (; t3 && t3.nodeType !== Node.ELEMENT_NODE; ) t3 = t3.parentNode;
    if (null != t3) {
      if (null == e2) return t3;
      if (t3.closest && null == i2) return t3.closest(e2);
      for (; t3 && t3 !== i2; ) {
        if (A(t3, e2)) return t3;
        t3 = t3.parentNode;
      }
    }
  };
  var x = (t3) => document.activeElement !== t3 && C(t3, document.activeElement);
  var C = function(t3, e2) {
    if (t3 && e2) for (; e2; ) {
      if (e2 === t3) return true;
      e2 = e2.parentNode;
    }
  };
  var E = function(t3) {
    var e2;
    if (null === (e2 = t3) || void 0 === e2 || !e2.parentNode) return;
    let i2 = 0;
    for (t3 = t3.previousSibling; t3; ) i2++, t3 = t3.previousSibling;
    return i2;
  };
  var S = (t3) => {
    var e2;
    return null == t3 || null === (e2 = t3.parentNode) || void 0 === e2 ? void 0 : e2.removeChild(t3);
  };
  var R = function(t3) {
    let { onlyNodesOfType: e2, usingFilter: i2, expandEntityReferences: n2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r2 = (() => {
      switch (e2) {
        case "element":
          return NodeFilter.SHOW_ELEMENT;
        case "text":
          return NodeFilter.SHOW_TEXT;
        case "comment":
          return NodeFilter.SHOW_COMMENT;
        default:
          return NodeFilter.SHOW_ALL;
      }
    })();
    return document.createTreeWalker(t3, r2, null != i2 ? i2 : null, true === n2);
  };
  var k = (t3) => {
    var e2;
    return null == t3 || null === (e2 = t3.tagName) || void 0 === e2 ? void 0 : e2.toLowerCase();
  };
  var T = function(t3) {
    let e2, i2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    "object" == typeof t3 ? (n2 = t3, t3 = n2.tagName) : n2 = { attributes: n2 };
    const r2 = document.createElement(t3);
    if (null != n2.editable && (null == n2.attributes && (n2.attributes = {}), n2.attributes.contenteditable = n2.editable), n2.attributes) for (e2 in n2.attributes) i2 = n2.attributes[e2], r2.setAttribute(e2, i2);
    if (n2.style) for (e2 in n2.style) i2 = n2.style[e2], r2.style[e2] = i2;
    if (n2.data) for (e2 in n2.data) i2 = n2.data[e2], r2.dataset[e2] = i2;
    return n2.className && n2.className.split(" ").forEach((t4) => {
      r2.classList.add(t4);
    }), n2.textContent && (r2.textContent = n2.textContent), n2.childNodes && [].concat(n2.childNodes).forEach((t4) => {
      r2.appendChild(t4);
    }), r2;
  };
  var w;
  var L = function() {
    if (null != w) return w;
    w = [];
    for (const t3 in n) {
      const e2 = n[t3];
      e2.tagName && w.push(e2.tagName);
    }
    return w;
  };
  var D = (t3) => I(null == t3 ? void 0 : t3.firstChild);
  var N = function(t3) {
    let { strict: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { strict: true };
    return e2 ? I(t3) : I(t3) || !I(t3.firstChild) && function(t4) {
      return L().includes(k(t4)) && !L().includes(k(t4.firstChild));
    }(t3);
  };
  var I = (t3) => O(t3) && "block" === (null == t3 ? void 0 : t3.data);
  var O = (t3) => (null == t3 ? void 0 : t3.nodeType) === Node.COMMENT_NODE;
  var F = function(t3) {
    let { name: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t3) return B(t3) ? t3.data === d ? !e2 || t3.parentNode.dataset.trixCursorTarget === e2 : void 0 : F(t3.firstChild);
  };
  var P = (t3) => A(t3, e);
  var M = (t3) => B(t3) && "" === (null == t3 ? void 0 : t3.data);
  var B = (t3) => (null == t3 ? void 0 : t3.nodeType) === Node.TEXT_NODE;
  var _ = { level2Enabled: true, getLevel() {
    return this.level2Enabled && a.supportsInputEvents ? 2 : 0;
  }, pickFiles(t3) {
    const e2 = T("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId });
    e2.addEventListener("change", () => {
      t3(e2.files), S(e2);
    }), S(document.getElementById(this.fileInputId)), document.body.appendChild(e2), e2.click();
  } };
  var j = { removeBlankTableCells: false, tableCellSeparator: " | ", tableRowSeparator: "\n" };
  var W = { bold: { tagName: "strong", inheritable: true, parser(t3) {
    const e2 = window.getComputedStyle(t3);
    return "bold" === e2.fontWeight || e2.fontWeight >= 600;
  } }, italic: { tagName: "em", inheritable: true, parser: (t3) => "italic" === window.getComputedStyle(t3).fontStyle }, href: { groupTagName: "a", parser(t3) {
    const i2 = "a:not(".concat(e, ")"), n2 = t3.closest(i2);
    if (n2) return n2.getAttribute("href");
  } }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
  var U = { getDefaultHTML: () => '<div class="trix-button-row">\n      <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="'.concat(c.bold, '" tabindex="-1">').concat(c.bold, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="').concat(c.italic, '" tabindex="-1">').concat(c.italic, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="').concat(c.strike, '" tabindex="-1">').concat(c.strike, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="').concat(c.link, '" tabindex="-1">').concat(c.link, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="').concat(c.heading1, '" tabindex="-1">').concat(c.heading1, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="').concat(c.quote, '" tabindex="-1">').concat(c.quote, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="').concat(c.code, '" tabindex="-1">').concat(c.code, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="').concat(c.bullets, '" tabindex="-1">').concat(c.bullets, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="').concat(c.numbers, '" tabindex="-1">').concat(c.numbers, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="').concat(c.outdent, '" tabindex="-1">').concat(c.outdent, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="').concat(c.indent, '" tabindex="-1">').concat(c.indent, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="').concat(c.attachFiles, '" tabindex="-1">').concat(c.attachFiles, '</button>\n      </span>\n\n      <span class="trix-button-group-spacer"></span>\n\n      <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="').concat(c.undo, '" tabindex="-1">').concat(c.undo, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="').concat(c.redo, '" tabindex="-1">').concat(c.redo, '</button>\n      </span>\n    </div>\n\n    <div class="trix-dialogs" data-trix-dialogs>\n      <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n        <div class="trix-dialog__link-fields">\n          <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="').concat(c.urlPlaceholder, '" aria-label="').concat(c.url, '" data-trix-validate-href required data-trix-input>\n          <div class="trix-button-group">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c.link, '" data-trix-method="setAttribute">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c.unlink, '" data-trix-method="removeAttribute">\n          </div>\n        </div>\n      </div>\n    </div>') };
  var V = { interval: 5e3 };
  var z = Object.freeze({ __proto__: null, attachments: i, blockAttributes: n, browser: a, css: { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" }, dompurify: l, fileSize: h, input: _, keyNames: { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" }, lang: c, parser: j, textAttributes: W, toolbar: U, undo: V });
  var q = class {
    static proxyMethod(t3) {
      const { name: e2, toMethod: i2, toProperty: n2, optional: r2 } = H(t3);
      this.prototype[e2] = function() {
        let t4, o2;
        var s2, a2;
        i2 ? o2 = r2 ? null === (s2 = this[i2]) || void 0 === s2 ? void 0 : s2.call(this) : this[i2]() : n2 && (o2 = this[n2]);
        return r2 ? (t4 = null === (a2 = o2) || void 0 === a2 ? void 0 : a2[e2], t4 ? J.call(t4, o2, arguments) : void 0) : (t4 = o2[e2], J.call(t4, o2, arguments));
      };
    }
  };
  var H = function(t3) {
    const e2 = t3.match(K);
    if (!e2) throw new Error("can't parse @proxyMethod expression: ".concat(t3));
    const i2 = { name: e2[4] };
    return null != e2[2] ? i2.toMethod = e2[1] : i2.toProperty = e2[1], null != e2[3] && (i2.optional = true), i2;
  };
  var { apply: J } = Function.prototype;
  var K = new RegExp("^(.+?)(\\(\\))?(\\?)?\\.(.+?)$");
  var G;
  var Y;
  var X;
  var $2 = class extends q {
    static box() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      return t3 instanceof this ? t3 : this.fromUCS2String(null == t3 ? void 0 : t3.toString());
    }
    static fromUCS2String(t3) {
      return new this(t3, et(t3));
    }
    static fromCodepoints(t3) {
      return new this(it(t3), t3);
    }
    constructor(t3, e2) {
      super(...arguments), this.ucs2String = t3, this.codepoints = e2, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
    }
    offsetToUCS2Offset(t3) {
      return it(this.codepoints.slice(0, Math.max(0, t3))).length;
    }
    offsetFromUCS2Offset(t3) {
      return et(this.ucs2String.slice(0, Math.max(0, t3))).length;
    }
    slice() {
      return this.constructor.fromCodepoints(this.codepoints.slice(...arguments));
    }
    charAt(t3) {
      return this.slice(t3, t3 + 1);
    }
    isEqualTo(t3) {
      return this.constructor.box(t3).ucs2String === this.ucs2String;
    }
    toJSON() {
      return this.ucs2String;
    }
    getCacheKey() {
      return this.ucs2String;
    }
    toString() {
      return this.ucs2String;
    }
  };
  var Z = 1 === (null === (G = Array.from) || void 0 === G ? void 0 : G.call(Array, "\u{1F47C}").length);
  var Q = null != (null === (Y = " ".codePointAt) || void 0 === Y ? void 0 : Y.call(" ", 0));
  var tt = " \u{1F47C}" === (null === (X = String.fromCodePoint) || void 0 === X ? void 0 : X.call(String, 32, 128124));
  var et;
  var it;
  et = Z && Q ? (t3) => Array.from(t3).map((t4) => t4.codePointAt(0)) : function(t3) {
    const e2 = [];
    let i2 = 0;
    const { length: n2 } = t3;
    for (; i2 < n2; ) {
      let r2 = t3.charCodeAt(i2++);
      if (55296 <= r2 && r2 <= 56319 && i2 < n2) {
        const e3 = t3.charCodeAt(i2++);
        56320 == (64512 & e3) ? r2 = ((1023 & r2) << 10) + (1023 & e3) + 65536 : i2--;
      }
      e2.push(r2);
    }
    return e2;
  }, it = tt ? (t3) => String.fromCodePoint(...Array.from(t3 || [])) : function(t3) {
    return (() => {
      const e2 = [];
      return Array.from(t3).forEach((t4) => {
        let i2 = "";
        t4 > 65535 && (t4 -= 65536, i2 += String.fromCharCode(t4 >>> 10 & 1023 | 55296), t4 = 56320 | 1023 & t4), e2.push(i2 + String.fromCharCode(t4));
      }), e2;
    })().join("");
  };
  var nt = 0;
  var rt = class extends q {
    static fromJSONString(t3) {
      return this.fromJSON(JSON.parse(t3));
    }
    constructor() {
      super(...arguments), this.id = ++nt;
    }
    hasSameConstructorAs(t3) {
      return this.constructor === (null == t3 ? void 0 : t3.constructor);
    }
    isEqualTo(t3) {
      return this === t3;
    }
    inspect() {
      const t3 = [], e2 = this.contentsForInspection() || {};
      for (const i2 in e2) {
        const n2 = e2[i2];
        t3.push("".concat(i2, "=").concat(n2));
      }
      return "#<".concat(this.constructor.name, ":").concat(this.id).concat(t3.length ? " ".concat(t3.join(", ")) : "", ">");
    }
    contentsForInspection() {
    }
    toJSONString() {
      return JSON.stringify(this);
    }
    toUTF16String() {
      return $2.box(this);
    }
    getCacheKey() {
      return this.id.toString();
    }
  };
  var ot = function() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (t3.length !== e2.length) return false;
    for (let i2 = 0; i2 < t3.length; i2++) {
      if (t3[i2] !== e2[i2]) return false;
    }
    return true;
  };
  var st = function(t3) {
    const e2 = t3.slice(0);
    for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
    return e2.splice(...n2), e2;
  };
  var at = /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/;
  var lt = function() {
    const t3 = T("input", { dir: "auto", name: "x", dirName: "x.dir" }), e2 = T("textarea", { dir: "auto", name: "y", dirName: "y.dir" }), i2 = T("form");
    i2.appendChild(t3), i2.appendChild(e2);
    const n2 = function() {
      try {
        return new FormData(i2).has(e2.dirName);
      } catch (t4) {
        return false;
      }
    }(), r2 = function() {
      try {
        return t3.matches(":dir(ltr),:dir(rtl)");
      } catch (t4) {
        return false;
      }
    }();
    return n2 ? function(t4) {
      return e2.value = t4, new FormData(i2).get(e2.dirName);
    } : r2 ? function(e3) {
      return t3.value = e3, t3.matches(":dir(rtl)") ? "rtl" : "ltr";
    } : function(t4) {
      const e3 = t4.trim().charAt(0);
      return at.test(e3) ? "rtl" : "ltr";
    };
  }();
  var ct = null;
  var ut = null;
  var ht = null;
  var dt = null;
  var gt = () => (ct || (ct = bt().concat(pt())), ct);
  var mt = (t3) => n[t3];
  var pt = () => (ut || (ut = Object.keys(n)), ut);
  var ft = (t3) => W[t3];
  var bt = () => (ht || (ht = Object.keys(W)), ht);
  var vt = function(t3, e2) {
    At(t3).textContent = e2.replace(/%t/g, t3);
  };
  var At = function(t3) {
    const e2 = document.createElement("style");
    e2.setAttribute("type", "text/css"), e2.setAttribute("data-tag-name", t3.toLowerCase());
    const i2 = yt();
    return i2 && e2.setAttribute("nonce", i2), document.head.insertBefore(e2, document.head.firstChild), e2;
  };
  var yt = function() {
    const t3 = xt("trix-csp-nonce") || xt("csp-nonce");
    if (t3) {
      const { nonce: e2, content: i2 } = t3;
      return "" == e2 ? i2 : e2;
    }
  };
  var xt = (t3) => document.head.querySelector("meta[name=".concat(t3, "]"));
  var Ct = { "application/x-trix-feature-detection": "test" };
  var Et = function(t3) {
    const e2 = t3.getData("text/plain"), i2 = t3.getData("text/html");
    if (!e2 || !i2) return null == e2 ? void 0 : e2.length;
    {
      const { body: t4 } = new DOMParser().parseFromString(i2, "text/html");
      if (t4.textContent === e2) return !t4.querySelector("*");
    }
  };
  var St = /Mac|^iP/.test(navigator.platform) ? (t3) => t3.metaKey : (t3) => t3.ctrlKey;
  var Rt = (t3) => setTimeout(t3, 1);
  var kt = function() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const e2 = {};
    for (const i2 in t3) {
      const n2 = t3[i2];
      e2[i2] = n2;
    }
    return e2;
  };
  var Tt = function() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (Object.keys(t3).length !== Object.keys(e2).length) return false;
    for (const i2 in t3) {
      if (t3[i2] !== e2[i2]) return false;
    }
    return true;
  };
  var wt = function(t3) {
    if (null != t3) return Array.isArray(t3) || (t3 = [t3, t3]), [Nt(t3[0]), Nt(null != t3[1] ? t3[1] : t3[0])];
  };
  var Lt = function(t3) {
    if (null == t3) return;
    const [e2, i2] = wt(t3);
    return It(e2, i2);
  };
  var Dt = function(t3, e2) {
    if (null == t3 || null == e2) return;
    const [i2, n2] = wt(t3), [r2, o2] = wt(e2);
    return It(i2, r2) && It(n2, o2);
  };
  var Nt = function(t3) {
    return "number" == typeof t3 ? t3 : kt(t3);
  };
  var It = function(t3, e2) {
    return "number" == typeof t3 ? t3 === e2 : Tt(t3, e2);
  };
  var Ot = class extends q {
    constructor() {
      super(...arguments), this.update = this.update.bind(this), this.selectionManagers = [];
    }
    start() {
      this.started || (this.started = true, document.addEventListener("selectionchange", this.update, true));
    }
    stop() {
      if (this.started) return this.started = false, document.removeEventListener("selectionchange", this.update, true);
    }
    registerSelectionManager(t3) {
      if (!this.selectionManagers.includes(t3)) return this.selectionManagers.push(t3), this.start();
    }
    unregisterSelectionManager(t3) {
      if (this.selectionManagers = this.selectionManagers.filter((e2) => e2 !== t3), 0 === this.selectionManagers.length) return this.stop();
    }
    notifySelectionManagersOfSelectionChange() {
      return this.selectionManagers.map((t3) => t3.selectionDidChange());
    }
    update() {
      this.notifySelectionManagersOfSelectionChange();
    }
    reset() {
      this.update();
    }
  };
  var Ft = new Ot();
  var Pt = function() {
    const t3 = window.getSelection();
    if (t3.rangeCount > 0) return t3;
  };
  var Mt = function() {
    var t3;
    const e2 = null === (t3 = Pt()) || void 0 === t3 ? void 0 : t3.getRangeAt(0);
    if (e2 && !_t(e2)) return e2;
  };
  var Bt = function(t3) {
    const e2 = window.getSelection();
    return e2.removeAllRanges(), e2.addRange(t3), Ft.update();
  };
  var _t = (t3) => jt(t3.startContainer) || jt(t3.endContainer);
  var jt = (t3) => !Object.getPrototypeOf(t3);
  var Wt = (t3) => t3.replace(new RegExp("".concat(d), "g"), "").replace(new RegExp("".concat(g), "g"), " ");
  var Ut = new RegExp("[^\\S".concat(g, "]"));
  var Vt = (t3) => t3.replace(new RegExp("".concat(Ut.source), "g"), " ").replace(/\ {2,}/g, " ");
  var zt = function(t3, e2) {
    if (t3.isEqualTo(e2)) return ["", ""];
    const i2 = qt(t3, e2), { length: n2 } = i2.utf16String;
    let r2;
    if (n2) {
      const { offset: o2 } = i2, s2 = t3.codepoints.slice(0, o2).concat(t3.codepoints.slice(o2 + n2));
      r2 = qt(e2, $2.fromCodepoints(s2));
    } else r2 = qt(e2, t3);
    return [i2.utf16String.toString(), r2.utf16String.toString()];
  };
  var qt = function(t3, e2) {
    let i2 = 0, n2 = t3.length, r2 = e2.length;
    for (; i2 < n2 && t3.charAt(i2).isEqualTo(e2.charAt(i2)); ) i2++;
    for (; n2 > i2 + 1 && t3.charAt(n2 - 1).isEqualTo(e2.charAt(r2 - 1)); ) n2--, r2--;
    return { utf16String: t3.slice(i2, n2), offset: i2 };
  };
  var Ht = class _Ht extends rt {
    static fromCommonAttributesOfObjects() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      if (!t3.length) return new this();
      let e2 = Yt(t3[0]), i2 = e2.getKeys();
      return t3.slice(1).forEach((t4) => {
        i2 = e2.getKeysCommonToHash(Yt(t4)), e2 = e2.slice(i2);
      }), e2;
    }
    static box(t3) {
      return Yt(t3);
    }
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(...arguments), this.values = Gt(t3);
    }
    add(t3, e2) {
      return this.merge(Jt(t3, e2));
    }
    remove(t3) {
      return new _Ht(Gt(this.values, t3));
    }
    get(t3) {
      return this.values[t3];
    }
    has(t3) {
      return t3 in this.values;
    }
    merge(t3) {
      return new _Ht(Kt(this.values, Xt(t3)));
    }
    slice(t3) {
      const e2 = {};
      return Array.from(t3).forEach((t4) => {
        this.has(t4) && (e2[t4] = this.values[t4]);
      }), new _Ht(e2);
    }
    getKeys() {
      return Object.keys(this.values);
    }
    getKeysCommonToHash(t3) {
      return t3 = Yt(t3), this.getKeys().filter((e2) => this.values[e2] === t3.values[e2]);
    }
    isEqualTo(t3) {
      return ot(this.toArray(), Yt(t3).toArray());
    }
    isEmpty() {
      return 0 === this.getKeys().length;
    }
    toArray() {
      if (!this.array) {
        const t3 = [];
        for (const e2 in this.values) {
          const i2 = this.values[e2];
          t3.push(t3.push(e2, i2));
        }
        this.array = t3.slice(0);
      }
      return this.array;
    }
    toObject() {
      return Gt(this.values);
    }
    toJSON() {
      return this.toObject();
    }
    contentsForInspection() {
      return { values: JSON.stringify(this.values) };
    }
  };
  var Jt = function(t3, e2) {
    const i2 = {};
    return i2[t3] = e2, i2;
  };
  var Kt = function(t3, e2) {
    const i2 = Gt(t3);
    for (const t4 in e2) {
      const n2 = e2[t4];
      i2[t4] = n2;
    }
    return i2;
  };
  var Gt = function(t3, e2) {
    const i2 = {};
    return Object.keys(t3).sort().forEach((n2) => {
      n2 !== e2 && (i2[n2] = t3[n2]);
    }), i2;
  };
  var Yt = function(t3) {
    return t3 instanceof Ht ? t3 : new Ht(t3);
  };
  var Xt = function(t3) {
    return t3 instanceof Ht ? t3.values : t3;
  };
  var $t = class {
    static groupObjects() {
      let t3, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: i2, asTree: n2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      n2 && null == i2 && (i2 = 0);
      const r2 = [];
      return Array.from(e2).forEach((e3) => {
        var o2;
        if (t3) {
          var s2, a2, l2;
          if (null !== (s2 = e3.canBeGrouped) && void 0 !== s2 && s2.call(e3, i2) && null !== (a2 = (l2 = t3[t3.length - 1]).canBeGroupedWith) && void 0 !== a2 && a2.call(l2, e3, i2)) return void t3.push(e3);
          r2.push(new this(t3, { depth: i2, asTree: n2 })), t3 = null;
        }
        null !== (o2 = e3.canBeGrouped) && void 0 !== o2 && o2.call(e3, i2) ? t3 = [e3] : r2.push(e3);
      }), t3 && r2.push(new this(t3, { depth: i2, asTree: n2 })), r2;
    }
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: e2, asTree: i2 } = arguments.length > 1 ? arguments[1] : void 0;
      this.objects = t3, i2 && (this.depth = e2, this.objects = this.constructor.groupObjects(this.objects, { asTree: i2, depth: this.depth + 1 }));
    }
    getObjects() {
      return this.objects;
    }
    getDepth() {
      return this.depth;
    }
    getCacheKey() {
      const t3 = ["objectGroup"];
      return Array.from(this.getObjects()).forEach((e2) => {
        t3.push(e2.getCacheKey());
      }), t3.join("/");
    }
  };
  var Zt = class extends q {
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.objects = {}, Array.from(t3).forEach((t4) => {
        const e2 = JSON.stringify(t4);
        null == this.objects[e2] && (this.objects[e2] = t4);
      });
    }
    find(t3) {
      const e2 = JSON.stringify(t3);
      return this.objects[e2];
    }
  };
  var Qt = class {
    constructor(t3) {
      this.reset(t3);
    }
    add(t3) {
      const e2 = te(t3);
      this.elements[e2] = t3;
    }
    remove(t3) {
      const e2 = te(t3), i2 = this.elements[e2];
      if (i2) return delete this.elements[e2], i2;
    }
    reset() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      return this.elements = {}, Array.from(t3).forEach((t4) => {
        this.add(t4);
      }), t3;
    }
  };
  var te = (t3) => t3.dataset.trixStoreKey;
  var ee = class extends q {
    isPerforming() {
      return true === this.performing;
    }
    hasPerformed() {
      return true === this.performed;
    }
    hasSucceeded() {
      return this.performed && this.succeeded;
    }
    hasFailed() {
      return this.performed && !this.succeeded;
    }
    getPromise() {
      return this.promise || (this.promise = new Promise((t3, e2) => (this.performing = true, this.perform((i2, n2) => {
        this.succeeded = i2, this.performing = false, this.performed = true, this.succeeded ? t3(n2) : e2(n2);
      })))), this.promise;
    }
    perform(t3) {
      return t3(false);
    }
    release() {
      var t3, e2;
      null === (t3 = this.promise) || void 0 === t3 || null === (e2 = t3.cancel) || void 0 === e2 || e2.call(t3), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
    }
  };
  ee.proxyMethod("getPromise().then"), ee.proxyMethod("getPromise().catch");
  var ie = class extends q {
    constructor(t3) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.object = t3, this.options = e2, this.childViews = [], this.rootView = this;
    }
    getNodes() {
      return this.nodes || (this.nodes = this.createNodes()), this.nodes.map((t3) => t3.cloneNode(true));
    }
    invalidate() {
      var t3;
      return this.nodes = null, this.childViews = [], null === (t3 = this.parentView) || void 0 === t3 ? void 0 : t3.invalidate();
    }
    invalidateViewForObject(t3) {
      var e2;
      return null === (e2 = this.findViewForObject(t3)) || void 0 === e2 ? void 0 : e2.invalidate();
    }
    findOrCreateCachedChildView(t3, e2, i2) {
      let n2 = this.getCachedViewForObject(e2);
      return n2 ? this.recordChildView(n2) : (n2 = this.createChildView(...arguments), this.cacheViewForObject(n2, e2)), n2;
    }
    createChildView(t3, e2) {
      let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      e2 instanceof $t && (i2.viewClass = t3, t3 = ne);
      const n2 = new t3(e2, i2);
      return this.recordChildView(n2);
    }
    recordChildView(t3) {
      return t3.parentView = this, t3.rootView = this.rootView, this.childViews.push(t3), t3;
    }
    getAllChildViews() {
      let t3 = [];
      return this.childViews.forEach((e2) => {
        t3.push(e2), t3 = t3.concat(e2.getAllChildViews());
      }), t3;
    }
    findElement() {
      return this.findElementForObject(this.object);
    }
    findElementForObject(t3) {
      const e2 = null == t3 ? void 0 : t3.id;
      if (e2) return this.rootView.element.querySelector("[data-trix-id='".concat(e2, "']"));
    }
    findViewForObject(t3) {
      for (const e2 of this.getAllChildViews()) if (e2.object === t3) return e2;
    }
    getViewCache() {
      return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? (this.viewCache || (this.viewCache = {}), this.viewCache) : void 0;
    }
    isViewCachingEnabled() {
      return false !== this.shouldCacheViews;
    }
    enableViewCaching() {
      this.shouldCacheViews = true;
    }
    disableViewCaching() {
      this.shouldCacheViews = false;
    }
    getCachedViewForObject(t3) {
      var e2;
      return null === (e2 = this.getViewCache()) || void 0 === e2 ? void 0 : e2[t3.getCacheKey()];
    }
    cacheViewForObject(t3, e2) {
      const i2 = this.getViewCache();
      i2 && (i2[e2.getCacheKey()] = t3);
    }
    garbageCollectCachedViews() {
      const t3 = this.getViewCache();
      if (t3) {
        const e2 = this.getAllChildViews().concat(this).map((t4) => t4.object.getCacheKey());
        for (const i2 in t3) e2.includes(i2) || delete t3[i2];
      }
    }
  };
  var ne = class extends ie {
    constructor() {
      super(...arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
    }
    getChildViews() {
      return this.childViews.length || Array.from(this.objectGroup.getObjects()).forEach((t3) => {
        this.findOrCreateCachedChildView(this.viewClass, t3, this.options);
      }), this.childViews;
    }
    createNodes() {
      const t3 = this.createContainerElement();
      return this.getChildViews().forEach((e2) => {
        Array.from(e2.getNodes()).forEach((e3) => {
          t3.appendChild(e3);
        });
      }), [t3];
    }
    createContainerElement() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.objectGroup.getDepth();
      return this.getChildViews()[0].createContainerElement(t3);
    }
  };
  var { entries: re, setPrototypeOf: oe, isFrozen: se, getPrototypeOf: ae, getOwnPropertyDescriptor: le } = Object;
  var { freeze: ce, seal: ue, create: he } = Object;
  var { apply: de, construct: ge } = "undefined" != typeof Reflect && Reflect;
  ce || (ce = function(t3) {
    return t3;
  }), ue || (ue = function(t3) {
    return t3;
  }), de || (de = function(t3, e2, i2) {
    return t3.apply(e2, i2);
  }), ge || (ge = function(t3, e2) {
    return new t3(...e2);
  });
  var me = Le(Array.prototype.forEach);
  var pe = Le(Array.prototype.lastIndexOf);
  var fe = Le(Array.prototype.pop);
  var be = Le(Array.prototype.push);
  var ve = Le(Array.prototype.splice);
  var Ae = Le(String.prototype.toLowerCase);
  var ye = Le(String.prototype.toString);
  var xe = Le(String.prototype.match);
  var Ce = Le(String.prototype.replace);
  var Ee = Le(String.prototype.indexOf);
  var Se = Le(String.prototype.trim);
  var Re = Le(Object.prototype.hasOwnProperty);
  var ke = Le(RegExp.prototype.test);
  var Te = (we = TypeError, function() {
    for (var t3 = arguments.length, e2 = new Array(t3), i2 = 0; i2 < t3; i2++) e2[i2] = arguments[i2];
    return ge(we, e2);
  });
  var we;
  function Le(t3) {
    return function(e2) {
      e2 instanceof RegExp && (e2.lastIndex = 0);
      for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
      return de(t3, e2, n2);
    };
  }
  function De(t3, e2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ae;
    oe && oe(t3, null);
    let n2 = e2.length;
    for (; n2--; ) {
      let r2 = e2[n2];
      if ("string" == typeof r2) {
        const t4 = i2(r2);
        t4 !== r2 && (se(e2) || (e2[n2] = t4), r2 = t4);
      }
      t3[r2] = true;
    }
    return t3;
  }
  function Ne(t3) {
    for (let e2 = 0; e2 < t3.length; e2++) {
      Re(t3, e2) || (t3[e2] = null);
    }
    return t3;
  }
  function Ie(t3) {
    const e2 = he(null);
    for (const [i2, n2] of re(t3)) {
      Re(t3, i2) && (Array.isArray(n2) ? e2[i2] = Ne(n2) : n2 && "object" == typeof n2 && n2.constructor === Object ? e2[i2] = Ie(n2) : e2[i2] = n2);
    }
    return e2;
  }
  function Oe(t3, e2) {
    for (; null !== t3; ) {
      const i2 = le(t3, e2);
      if (i2) {
        if (i2.get) return Le(i2.get);
        if ("function" == typeof i2.value) return Le(i2.value);
      }
      t3 = ae(t3);
    }
    return function() {
      return null;
    };
  }
  var Fe = ce(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var Pe = ce(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var Me = ce(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var Be = ce(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var _e = ce(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  var je = ce(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var We = ce(["#text"]);
  var Ue = ce(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  var Ve = ce(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var ze = ce(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var qe = ce(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var He = ue(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var Je = ue(/<%[\w\W]*|[\w\W]*%>/gm);
  var Ke = ue(/\$\{[\w\W]*/gm);
  var Ge = ue(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  var Ye = ue(/^aria-[\-\w]+$/);
  var Xe = ue(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  var $e = ue(/^(?:\w+script|data):/i);
  var Ze = ue(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  var Qe = ue(/^html$/i);
  var ti = ue(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var ei = Object.freeze({ __proto__: null, ARIA_ATTR: Ye, ATTR_WHITESPACE: Ze, CUSTOM_ELEMENT: ti, DATA_ATTR: Ge, DOCTYPE_NAME: Qe, ERB_EXPR: Je, IS_ALLOWED_URI: Xe, IS_SCRIPT_OR_DATA: $e, MUSTACHE_EXPR: He, TMPLIT_EXPR: Ke });
  var ii = 1;
  var ni = 3;
  var ri = 7;
  var oi = 8;
  var si = 9;
  var ai = function() {
    return "undefined" == typeof window ? null : window;
  };
  var li = function t2() {
    let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ai();
    const i2 = (e3) => t2(e3);
    if (i2.version = "3.2.5", i2.removed = [], !e2 || !e2.document || e2.document.nodeType !== si || !e2.Element) return i2.isSupported = false, i2;
    let { document: n2 } = e2;
    const r2 = n2, o2 = r2.currentScript, { DocumentFragment: s2, HTMLTemplateElement: a2, Node: l2, Element: c2, NodeFilter: u2, NamedNodeMap: h2 = e2.NamedNodeMap || e2.MozNamedAttrMap, HTMLFormElement: d2, DOMParser: g2, trustedTypes: m2 } = e2, p2 = c2.prototype, f2 = Oe(p2, "cloneNode"), b2 = Oe(p2, "remove"), v2 = Oe(p2, "nextSibling"), A2 = Oe(p2, "childNodes"), y2 = Oe(p2, "parentNode");
    if ("function" == typeof a2) {
      const t3 = n2.createElement("template");
      t3.content && t3.content.ownerDocument && (n2 = t3.content.ownerDocument);
    }
    let x2, C2 = "";
    const { implementation: E2, createNodeIterator: S2, createDocumentFragment: R2, getElementsByTagName: k2 } = n2, { importNode: T2 } = r2;
    let w2 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
    i2.isSupported = "function" == typeof re && "function" == typeof y2 && E2 && void 0 !== E2.createHTMLDocument;
    const { MUSTACHE_EXPR: L2, ERB_EXPR: D2, TMPLIT_EXPR: N2, DATA_ATTR: I2, ARIA_ATTR: O2, IS_SCRIPT_OR_DATA: F2, ATTR_WHITESPACE: P2, CUSTOM_ELEMENT: M2 } = ei;
    let { IS_ALLOWED_URI: B2 } = ei, _3 = null;
    const j2 = De({}, [...Fe, ...Pe, ...Me, ..._e, ...We]);
    let W2 = null;
    const U2 = De({}, [...Ue, ...Ve, ...ze, ...qe]);
    let V2 = Object.seal(he(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), z2 = null, q2 = null, H3 = true, J2 = true, K2 = false, G2 = true, Y2 = false, X2 = true, $5 = false, Z3 = false, Q2 = false, tt2 = false, et2 = false, it2 = false, nt2 = true, rt2 = false, ot2 = true, st2 = false, at2 = {}, lt2 = null;
    const ct2 = De({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let ut2 = null;
    const ht2 = De({}, ["audio", "video", "img", "source", "image", "track"]);
    let dt2 = null;
    const gt2 = De({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mt2 = "http://www.w3.org/1998/Math/MathML", pt2 = "http://www.w3.org/2000/svg", ft2 = "http://www.w3.org/1999/xhtml";
    let bt2 = ft2, vt2 = false, At2 = null;
    const yt2 = De({}, [mt2, pt2, ft2], ye);
    let xt2 = De({}, ["mi", "mo", "mn", "ms", "mtext"]), Ct2 = De({}, ["annotation-xml"]);
    const Et2 = De({}, ["title", "style", "font", "a", "script"]);
    let St2 = null;
    const Rt2 = ["application/xhtml+xml", "text/html"];
    let kt2 = null, Tt2 = null;
    const wt2 = n2.createElement("form"), Lt2 = function(t3) {
      return t3 instanceof RegExp || t3 instanceof Function;
    }, Dt2 = function() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (!Tt2 || Tt2 !== t3) {
        if (t3 && "object" == typeof t3 || (t3 = {}), t3 = Ie(t3), St2 = -1 === Rt2.indexOf(t3.PARSER_MEDIA_TYPE) ? "text/html" : t3.PARSER_MEDIA_TYPE, kt2 = "application/xhtml+xml" === St2 ? ye : Ae, _3 = Re(t3, "ALLOWED_TAGS") ? De({}, t3.ALLOWED_TAGS, kt2) : j2, W2 = Re(t3, "ALLOWED_ATTR") ? De({}, t3.ALLOWED_ATTR, kt2) : U2, At2 = Re(t3, "ALLOWED_NAMESPACES") ? De({}, t3.ALLOWED_NAMESPACES, ye) : yt2, dt2 = Re(t3, "ADD_URI_SAFE_ATTR") ? De(Ie(gt2), t3.ADD_URI_SAFE_ATTR, kt2) : gt2, ut2 = Re(t3, "ADD_DATA_URI_TAGS") ? De(Ie(ht2), t3.ADD_DATA_URI_TAGS, kt2) : ht2, lt2 = Re(t3, "FORBID_CONTENTS") ? De({}, t3.FORBID_CONTENTS, kt2) : ct2, z2 = Re(t3, "FORBID_TAGS") ? De({}, t3.FORBID_TAGS, kt2) : {}, q2 = Re(t3, "FORBID_ATTR") ? De({}, t3.FORBID_ATTR, kt2) : {}, at2 = !!Re(t3, "USE_PROFILES") && t3.USE_PROFILES, H3 = false !== t3.ALLOW_ARIA_ATTR, J2 = false !== t3.ALLOW_DATA_ATTR, K2 = t3.ALLOW_UNKNOWN_PROTOCOLS || false, G2 = false !== t3.ALLOW_SELF_CLOSE_IN_ATTR, Y2 = t3.SAFE_FOR_TEMPLATES || false, X2 = false !== t3.SAFE_FOR_XML, $5 = t3.WHOLE_DOCUMENT || false, tt2 = t3.RETURN_DOM || false, et2 = t3.RETURN_DOM_FRAGMENT || false, it2 = t3.RETURN_TRUSTED_TYPE || false, Q2 = t3.FORCE_BODY || false, nt2 = false !== t3.SANITIZE_DOM, rt2 = t3.SANITIZE_NAMED_PROPS || false, ot2 = false !== t3.KEEP_CONTENT, st2 = t3.IN_PLACE || false, B2 = t3.ALLOWED_URI_REGEXP || Xe, bt2 = t3.NAMESPACE || ft2, xt2 = t3.MATHML_TEXT_INTEGRATION_POINTS || xt2, Ct2 = t3.HTML_INTEGRATION_POINTS || Ct2, V2 = t3.CUSTOM_ELEMENT_HANDLING || {}, t3.CUSTOM_ELEMENT_HANDLING && Lt2(t3.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (V2.tagNameCheck = t3.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t3.CUSTOM_ELEMENT_HANDLING && Lt2(t3.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (V2.attributeNameCheck = t3.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t3.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof t3.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (V2.allowCustomizedBuiltInElements = t3.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y2 && (J2 = false), et2 && (tt2 = true), at2 && (_3 = De({}, We), W2 = [], true === at2.html && (De(_3, Fe), De(W2, Ue)), true === at2.svg && (De(_3, Pe), De(W2, Ve), De(W2, qe)), true === at2.svgFilters && (De(_3, Me), De(W2, Ve), De(W2, qe)), true === at2.mathMl && (De(_3, _e), De(W2, ze), De(W2, qe))), t3.ADD_TAGS && (_3 === j2 && (_3 = Ie(_3)), De(_3, t3.ADD_TAGS, kt2)), t3.ADD_ATTR && (W2 === U2 && (W2 = Ie(W2)), De(W2, t3.ADD_ATTR, kt2)), t3.ADD_URI_SAFE_ATTR && De(dt2, t3.ADD_URI_SAFE_ATTR, kt2), t3.FORBID_CONTENTS && (lt2 === ct2 && (lt2 = Ie(lt2)), De(lt2, t3.FORBID_CONTENTS, kt2)), ot2 && (_3["#text"] = true), $5 && De(_3, ["html", "head", "body"]), _3.table && (De(_3, ["tbody"]), delete z2.tbody), t3.TRUSTED_TYPES_POLICY) {
          if ("function" != typeof t3.TRUSTED_TYPES_POLICY.createHTML) throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if ("function" != typeof t3.TRUSTED_TYPES_POLICY.createScriptURL) throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          x2 = t3.TRUSTED_TYPES_POLICY, C2 = x2.createHTML("");
        } else void 0 === x2 && (x2 = function(t4, e3) {
          if ("object" != typeof t4 || "function" != typeof t4.createPolicy) return null;
          let i3 = null;
          const n3 = "data-tt-policy-suffix";
          e3 && e3.hasAttribute(n3) && (i3 = e3.getAttribute(n3));
          const r3 = "dompurify" + (i3 ? "#" + i3 : "");
          try {
            return t4.createPolicy(r3, { createHTML: (t5) => t5, createScriptURL: (t5) => t5 });
          } catch (t5) {
            return console.warn("TrustedTypes policy " + r3 + " could not be created."), null;
          }
        }(m2, o2)), null !== x2 && "string" == typeof C2 && (C2 = x2.createHTML(""));
        ce && ce(t3), Tt2 = t3;
      }
    }, Nt2 = De({}, [...Pe, ...Me, ...Be]), It2 = De({}, [..._e, ...je]), Ot2 = function(t3) {
      be(i2.removed, { element: t3 });
      try {
        y2(t3).removeChild(t3);
      } catch (e3) {
        b2(t3);
      }
    }, Ft2 = function(t3, e3) {
      try {
        be(i2.removed, { attribute: e3.getAttributeNode(t3), from: e3 });
      } catch (t4) {
        be(i2.removed, { attribute: null, from: e3 });
      }
      if (e3.removeAttribute(t3), "is" === t3) if (tt2 || et2) try {
        Ot2(e3);
      } catch (t4) {
      }
      else try {
        e3.setAttribute(t3, "");
      } catch (t4) {
      }
    }, Pt2 = function(t3) {
      let e3 = null, i3 = null;
      if (Q2) t3 = "<remove></remove>" + t3;
      else {
        const e4 = xe(t3, /^[\r\n\t ]+/);
        i3 = e4 && e4[0];
      }
      "application/xhtml+xml" === St2 && bt2 === ft2 && (t3 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t3 + "</body></html>");
      const r3 = x2 ? x2.createHTML(t3) : t3;
      if (bt2 === ft2) try {
        e3 = new g2().parseFromString(r3, St2);
      } catch (t4) {
      }
      if (!e3 || !e3.documentElement) {
        e3 = E2.createDocument(bt2, "template", null);
        try {
          e3.documentElement.innerHTML = vt2 ? C2 : r3;
        } catch (t4) {
        }
      }
      const o3 = e3.body || e3.documentElement;
      return t3 && i3 && o3.insertBefore(n2.createTextNode(i3), o3.childNodes[0] || null), bt2 === ft2 ? k2.call(e3, $5 ? "html" : "body")[0] : $5 ? e3.documentElement : o3;
    }, Mt2 = function(t3) {
      return S2.call(t3.ownerDocument || t3, t3, u2.SHOW_ELEMENT | u2.SHOW_COMMENT | u2.SHOW_TEXT | u2.SHOW_PROCESSING_INSTRUCTION | u2.SHOW_CDATA_SECTION, null);
    }, Bt2 = function(t3) {
      return t3 instanceof d2 && ("string" != typeof t3.nodeName || "string" != typeof t3.textContent || "function" != typeof t3.removeChild || !(t3.attributes instanceof h2) || "function" != typeof t3.removeAttribute || "function" != typeof t3.setAttribute || "string" != typeof t3.namespaceURI || "function" != typeof t3.insertBefore || "function" != typeof t3.hasChildNodes);
    }, _t2 = function(t3) {
      return "function" == typeof l2 && t3 instanceof l2;
    };
    function jt2(t3, e3, n3) {
      me(t3, (t4) => {
        t4.call(i2, e3, n3, Tt2);
      });
    }
    const Wt2 = function(t3) {
      let e3 = null;
      if (jt2(w2.beforeSanitizeElements, t3, null), Bt2(t3)) return Ot2(t3), true;
      const n3 = kt2(t3.nodeName);
      if (jt2(w2.uponSanitizeElement, t3, { tagName: n3, allowedTags: _3 }), t3.hasChildNodes() && !_t2(t3.firstElementChild) && ke(/<[/\w!]/g, t3.innerHTML) && ke(/<[/\w!]/g, t3.textContent)) return Ot2(t3), true;
      if (t3.nodeType === ri) return Ot2(t3), true;
      if (X2 && t3.nodeType === oi && ke(/<[/\w]/g, t3.data)) return Ot2(t3), true;
      if (!_3[n3] || z2[n3]) {
        if (!z2[n3] && Vt2(n3)) {
          if (V2.tagNameCheck instanceof RegExp && ke(V2.tagNameCheck, n3)) return false;
          if (V2.tagNameCheck instanceof Function && V2.tagNameCheck(n3)) return false;
        }
        if (ot2 && !lt2[n3]) {
          const e4 = y2(t3) || t3.parentNode, i3 = A2(t3) || t3.childNodes;
          if (i3 && e4) {
            for (let n4 = i3.length - 1; n4 >= 0; --n4) {
              const r3 = f2(i3[n4], true);
              r3.__removalCount = (t3.__removalCount || 0) + 1, e4.insertBefore(r3, v2(t3));
            }
          }
        }
        return Ot2(t3), true;
      }
      return t3 instanceof c2 && !function(t4) {
        let e4 = y2(t4);
        e4 && e4.tagName || (e4 = { namespaceURI: bt2, tagName: "template" });
        const i3 = Ae(t4.tagName), n4 = Ae(e4.tagName);
        return !!At2[t4.namespaceURI] && (t4.namespaceURI === pt2 ? e4.namespaceURI === ft2 ? "svg" === i3 : e4.namespaceURI === mt2 ? "svg" === i3 && ("annotation-xml" === n4 || xt2[n4]) : Boolean(Nt2[i3]) : t4.namespaceURI === mt2 ? e4.namespaceURI === ft2 ? "math" === i3 : e4.namespaceURI === pt2 ? "math" === i3 && Ct2[n4] : Boolean(It2[i3]) : t4.namespaceURI === ft2 ? !(e4.namespaceURI === pt2 && !Ct2[n4]) && !(e4.namespaceURI === mt2 && !xt2[n4]) && !It2[i3] && (Et2[i3] || !Nt2[i3]) : !("application/xhtml+xml" !== St2 || !At2[t4.namespaceURI]));
      }(t3) ? (Ot2(t3), true) : "noscript" !== n3 && "noembed" !== n3 && "noframes" !== n3 || !ke(/<\/no(script|embed|frames)/i, t3.innerHTML) ? (Y2 && t3.nodeType === ni && (e3 = t3.textContent, me([L2, D2, N2], (t4) => {
        e3 = Ce(e3, t4, " ");
      }), t3.textContent !== e3 && (be(i2.removed, { element: t3.cloneNode() }), t3.textContent = e3)), jt2(w2.afterSanitizeElements, t3, null), false) : (Ot2(t3), true);
    }, Ut2 = function(t3, e3, i3) {
      if (nt2 && ("id" === e3 || "name" === e3) && (i3 in n2 || i3 in wt2)) return false;
      if (J2 && !q2[e3] && ke(I2, e3)) ;
      else if (H3 && ke(O2, e3)) ;
      else if (!W2[e3] || q2[e3]) {
        if (!(Vt2(t3) && (V2.tagNameCheck instanceof RegExp && ke(V2.tagNameCheck, t3) || V2.tagNameCheck instanceof Function && V2.tagNameCheck(t3)) && (V2.attributeNameCheck instanceof RegExp && ke(V2.attributeNameCheck, e3) || V2.attributeNameCheck instanceof Function && V2.attributeNameCheck(e3)) || "is" === e3 && V2.allowCustomizedBuiltInElements && (V2.tagNameCheck instanceof RegExp && ke(V2.tagNameCheck, i3) || V2.tagNameCheck instanceof Function && V2.tagNameCheck(i3)))) return false;
      } else if (dt2[e3]) ;
      else if (ke(B2, Ce(i3, P2, ""))) ;
      else if ("src" !== e3 && "xlink:href" !== e3 && "href" !== e3 || "script" === t3 || 0 !== Ee(i3, "data:") || !ut2[t3]) {
        if (K2 && !ke(F2, Ce(i3, P2, ""))) ;
        else if (i3) return false;
      } else ;
      return true;
    }, Vt2 = function(t3) {
      return "annotation-xml" !== t3 && xe(t3, M2);
    }, zt2 = function(t3) {
      jt2(w2.beforeSanitizeAttributes, t3, null);
      const { attributes: e3 } = t3;
      if (!e3 || Bt2(t3)) return;
      const n3 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: W2, forceKeepAttr: void 0 };
      let r3 = e3.length;
      for (; r3--; ) {
        const o3 = e3[r3], { name: s3, namespaceURI: a3, value: l3 } = o3, c3 = kt2(s3);
        let u3 = "value" === s3 ? l3 : Se(l3);
        if (n3.attrName = c3, n3.attrValue = u3, n3.keepAttr = true, n3.forceKeepAttr = void 0, jt2(w2.uponSanitizeAttribute, t3, n3), u3 = n3.attrValue, !rt2 || "id" !== c3 && "name" !== c3 || (Ft2(s3, t3), u3 = "user-content-" + u3), X2 && ke(/((--!?|])>)|<\/(style|title)/i, u3)) {
          Ft2(s3, t3);
          continue;
        }
        if (n3.forceKeepAttr) continue;
        if (Ft2(s3, t3), !n3.keepAttr) continue;
        if (!G2 && ke(/\/>/i, u3)) {
          Ft2(s3, t3);
          continue;
        }
        Y2 && me([L2, D2, N2], (t4) => {
          u3 = Ce(u3, t4, " ");
        });
        const h3 = kt2(t3.nodeName);
        if (Ut2(h3, c3, u3)) {
          if (x2 && "object" == typeof m2 && "function" == typeof m2.getAttributeType) if (a3) ;
          else switch (m2.getAttributeType(h3, c3)) {
            case "TrustedHTML":
              u3 = x2.createHTML(u3);
              break;
            case "TrustedScriptURL":
              u3 = x2.createScriptURL(u3);
          }
          try {
            a3 ? t3.setAttributeNS(a3, s3, u3) : t3.setAttribute(s3, u3), Bt2(t3) ? Ot2(t3) : fe(i2.removed);
          } catch (t4) {
          }
        }
      }
      jt2(w2.afterSanitizeAttributes, t3, null);
    }, qt2 = function t3(e3) {
      let i3 = null;
      const n3 = Mt2(e3);
      for (jt2(w2.beforeSanitizeShadowDOM, e3, null); i3 = n3.nextNode(); ) jt2(w2.uponSanitizeShadowNode, i3, null), Wt2(i3), zt2(i3), i3.content instanceof s2 && t3(i3.content);
      jt2(w2.afterSanitizeShadowDOM, e3, null);
    };
    return i2.sanitize = function(t3) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n3 = null, o3 = null, a3 = null, c3 = null;
      if (vt2 = !t3, vt2 && (t3 = "<!-->"), "string" != typeof t3 && !_t2(t3)) {
        if ("function" != typeof t3.toString) throw Te("toString is not a function");
        if ("string" != typeof (t3 = t3.toString())) throw Te("dirty is not a string, aborting");
      }
      if (!i2.isSupported) return t3;
      if (Z3 || Dt2(e3), i2.removed = [], "string" == typeof t3 && (st2 = false), st2) {
        if (t3.nodeName) {
          const e4 = kt2(t3.nodeName);
          if (!_3[e4] || z2[e4]) throw Te("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (t3 instanceof l2) n3 = Pt2("<!---->"), o3 = n3.ownerDocument.importNode(t3, true), o3.nodeType === ii && "BODY" === o3.nodeName || "HTML" === o3.nodeName ? n3 = o3 : n3.appendChild(o3);
      else {
        if (!tt2 && !Y2 && !$5 && -1 === t3.indexOf("<")) return x2 && it2 ? x2.createHTML(t3) : t3;
        if (n3 = Pt2(t3), !n3) return tt2 ? null : it2 ? C2 : "";
      }
      n3 && Q2 && Ot2(n3.firstChild);
      const u3 = Mt2(st2 ? t3 : n3);
      for (; a3 = u3.nextNode(); ) Wt2(a3), zt2(a3), a3.content instanceof s2 && qt2(a3.content);
      if (st2) return t3;
      if (tt2) {
        if (et2) for (c3 = R2.call(n3.ownerDocument); n3.firstChild; ) c3.appendChild(n3.firstChild);
        else c3 = n3;
        return (W2.shadowroot || W2.shadowrootmode) && (c3 = T2.call(r2, c3, true)), c3;
      }
      let h3 = $5 ? n3.outerHTML : n3.innerHTML;
      return $5 && _3["!doctype"] && n3.ownerDocument && n3.ownerDocument.doctype && n3.ownerDocument.doctype.name && ke(Qe, n3.ownerDocument.doctype.name) && (h3 = "<!DOCTYPE " + n3.ownerDocument.doctype.name + ">\n" + h3), Y2 && me([L2, D2, N2], (t4) => {
        h3 = Ce(h3, t4, " ");
      }), x2 && it2 ? x2.createHTML(h3) : h3;
    }, i2.setConfig = function() {
      Dt2(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), Z3 = true;
    }, i2.clearConfig = function() {
      Tt2 = null, Z3 = false;
    }, i2.isValidAttribute = function(t3, e3, i3) {
      Tt2 || Dt2({});
      const n3 = kt2(t3), r3 = kt2(e3);
      return Ut2(n3, r3, i3);
    }, i2.addHook = function(t3, e3) {
      "function" == typeof e3 && be(w2[t3], e3);
    }, i2.removeHook = function(t3, e3) {
      if (void 0 !== e3) {
        const i3 = pe(w2[t3], e3);
        return -1 === i3 ? void 0 : ve(w2[t3], i3, 1)[0];
      }
      return fe(w2[t3]);
    }, i2.removeHooks = function(t3) {
      w2[t3] = [];
    }, i2.removeAllHooks = function() {
      w2 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
    }, i2;
  }();
  li.addHook("uponSanitizeAttribute", function(t3, e2) {
    /^data-trix-/.test(e2.attrName) && (e2.forceKeepAttr = true);
  });
  var ci = "style href src width height language class".split(" ");
  var ui = "javascript:".split(" ");
  var hi = "script iframe form noscript".split(" ");
  var di = class extends q {
    static setHTML(t3, e2, i2) {
      const n2 = new this(e2, i2).sanitize(), r2 = n2.getHTML ? n2.getHTML() : n2.outerHTML;
      t3.innerHTML = r2;
    }
    static sanitize(t3, e2) {
      const i2 = new this(t3, e2);
      return i2.sanitize(), i2;
    }
    constructor(t3) {
      let { allowedAttributes: e2, forbiddenProtocols: i2, forbiddenElements: n2, purifyOptions: r2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.allowedAttributes = e2 || ci, this.forbiddenProtocols = i2 || ui, this.forbiddenElements = n2 || hi, this.purifyOptions = r2 || {}, this.body = gi(t3);
    }
    sanitize() {
      this.sanitizeElements(), this.normalizeListElementNesting();
      const t3 = Object.assign({}, l, this.purifyOptions);
      return li.setConfig(t3), this.body = li.sanitize(this.body), this.body;
    }
    getHTML() {
      return this.body.innerHTML;
    }
    getBody() {
      return this.body;
    }
    sanitizeElements() {
      const t3 = R(this.body), e2 = [];
      for (; t3.nextNode(); ) {
        const i2 = t3.currentNode;
        switch (i2.nodeType) {
          case Node.ELEMENT_NODE:
            this.elementIsRemovable(i2) ? e2.push(i2) : this.sanitizeElement(i2);
            break;
          case Node.COMMENT_NODE:
            e2.push(i2);
        }
      }
      return e2.forEach((t4) => S(t4)), this.body;
    }
    sanitizeElement(t3) {
      return t3.hasAttribute("href") && this.forbiddenProtocols.includes(t3.protocol) && t3.removeAttribute("href"), Array.from(t3.attributes).forEach((e2) => {
        let { name: i2 } = e2;
        this.allowedAttributes.includes(i2) || 0 === i2.indexOf("data-trix") || t3.removeAttribute(i2);
      }), t3;
    }
    normalizeListElementNesting() {
      return Array.from(this.body.querySelectorAll("ul,ol")).forEach((t3) => {
        const e2 = t3.previousElementSibling;
        e2 && "li" === k(e2) && e2.appendChild(t3);
      }), this.body;
    }
    elementIsRemovable(t3) {
      if ((null == t3 ? void 0 : t3.nodeType) === Node.ELEMENT_NODE) return this.elementIsForbidden(t3) || this.elementIsntSerializable(t3);
    }
    elementIsForbidden(t3) {
      return this.forbiddenElements.includes(k(t3));
    }
    elementIsntSerializable(t3) {
      return "false" === t3.getAttribute("data-trix-serialize") && !P(t3);
    }
  };
  var gi = function() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    t3 = t3.replace(/<\/html[^>]*>[^]*$/i, "</html>");
    const e2 = document.implementation.createHTMLDocument("");
    return e2.documentElement.innerHTML = t3, Array.from(e2.head.querySelectorAll("style")).forEach((t4) => {
      e2.body.appendChild(t4);
    }), e2.body;
  };
  var { css: mi } = z;
  var pi = class extends ie {
    constructor() {
      super(...arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
    }
    createContentNodes() {
      return [];
    }
    createNodes() {
      let t3;
      const e2 = t3 = T({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), i2 = this.getHref();
      return i2 && (t3 = T({ tagName: "a", editable: false, attributes: { href: i2, tabindex: -1 } }), e2.appendChild(t3)), this.attachment.hasContent() ? di.setHTML(t3, this.attachment.getContent()) : this.createContentNodes().forEach((e3) => {
        t3.appendChild(e3);
      }), t3.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = T({ tagName: "progress", attributes: { class: mi.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e2.appendChild(this.progressElement)), [fi("left"), e2, fi("right")];
    }
    createCaptionElement() {
      const t3 = T({ tagName: "figcaption", className: mi.attachmentCaption }), e2 = this.attachmentPiece.getCaption();
      if (e2) t3.classList.add("".concat(mi.attachmentCaption, "--edited")), t3.textContent = e2;
      else {
        let e3, i2;
        const n2 = this.getCaptionConfig();
        if (n2.name && (e3 = this.attachment.getFilename()), n2.size && (i2 = this.attachment.getFormattedFilesize()), e3) {
          const i3 = T({ tagName: "span", className: mi.attachmentName, textContent: e3 });
          t3.appendChild(i3);
        }
        if (i2) {
          e3 && t3.appendChild(document.createTextNode(" "));
          const n3 = T({ tagName: "span", className: mi.attachmentSize, textContent: i2 });
          t3.appendChild(n3);
        }
      }
      return t3;
    }
    getClassName() {
      const t3 = [mi.attachment, "".concat(mi.attachment, "--").concat(this.attachment.getType())], e2 = this.attachment.getExtension();
      return e2 && t3.push("".concat(mi.attachment, "--").concat(e2)), t3.join(" ");
    }
    getData() {
      const t3 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, { attributes: e2 } = this.attachmentPiece;
      return e2.isEmpty() || (t3.trixAttributes = JSON.stringify(e2)), this.attachment.isPending() && (t3.trixSerialize = false), t3;
    }
    getHref() {
      if (!bi(this.attachment.getContent(), "a")) return this.attachment.getHref();
    }
    getCaptionConfig() {
      var t3;
      const e2 = this.attachment.getType(), n2 = kt(null === (t3 = i[e2]) || void 0 === t3 ? void 0 : t3.caption);
      return "file" === e2 && (n2.name = true), n2;
    }
    findProgressElement() {
      var t3;
      return null === (t3 = this.findElement()) || void 0 === t3 ? void 0 : t3.querySelector("progress");
    }
    attachmentDidChangeUploadProgress() {
      const t3 = this.attachment.getUploadProgress(), e2 = this.findProgressElement();
      e2 && (e2.value = t3);
    }
  };
  var fi = (t3) => T({ tagName: "span", textContent: d, data: { trixCursorTarget: t3, trixSerialize: false } });
  var bi = function(t3, e2) {
    const i2 = T("div");
    return di.setHTML(i2, t3 || ""), i2.querySelector(e2);
  };
  var vi = class extends pi {
    constructor() {
      super(...arguments), this.attachment.previewDelegate = this;
    }
    createContentNodes() {
      return this.image = T({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
    }
    createCaptionElement() {
      const t3 = super.createCaptionElement(...arguments);
      return t3.textContent || t3.setAttribute("data-trix-placeholder", c.captionPlaceholder), t3;
    }
    refresh(t3) {
      var e2;
      t3 || (t3 = null === (e2 = this.findElement()) || void 0 === e2 ? void 0 : e2.querySelector("img"));
      if (t3) return this.updateAttributesForImage(t3);
    }
    updateAttributesForImage(t3) {
      const e2 = this.attachment.getURL(), i2 = this.attachment.getPreviewURL();
      if (t3.src = i2 || e2, i2 === e2) t3.removeAttribute("data-trix-serialized-attributes");
      else {
        const i3 = JSON.stringify({ src: e2 });
        t3.setAttribute("data-trix-serialized-attributes", i3);
      }
      const n2 = this.attachment.getWidth(), r2 = this.attachment.getHeight();
      null != n2 && (t3.width = n2), null != r2 && (t3.height = r2);
      const o2 = ["imageElement", this.attachment.id, t3.src, t3.width, t3.height].join("/");
      t3.dataset.trixStoreKey = o2;
    }
    attachmentDidChangeAttributes() {
      return this.refresh(this.image), this.refresh();
    }
  };
  var Ai = class extends ie {
    constructor() {
      super(...arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), this.textConfig = this.options.textConfig, this.context = this.options.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
    }
    createNodes() {
      let t3 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes();
      const e2 = this.createElement();
      if (e2) {
        const i2 = function(t4) {
          for (; null !== (e3 = t4) && void 0 !== e3 && e3.firstElementChild; ) {
            var e3;
            t4 = t4.firstElementChild;
          }
          return t4;
        }(e2);
        Array.from(t3).forEach((t4) => {
          i2.appendChild(t4);
        }), t3 = [e2];
      }
      return t3;
    }
    createAttachmentNodes() {
      const t3 = this.attachment.isPreviewable() ? vi : pi;
      return this.createChildView(t3, this.piece.attachment, { piece: this.piece }).getNodes();
    }
    createStringNodes() {
      var t3;
      if (null !== (t3 = this.textConfig) && void 0 !== t3 && t3.plaintext) return [document.createTextNode(this.string)];
      {
        const t4 = [], e2 = this.string.split("\n");
        for (let i2 = 0; i2 < e2.length; i2++) {
          const n2 = e2[i2];
          if (i2 > 0) {
            const e3 = T("br");
            t4.push(e3);
          }
          if (n2.length) {
            const e3 = document.createTextNode(this.preserveSpaces(n2));
            t4.push(e3);
          }
        }
        return t4;
      }
    }
    createElement() {
      let t3, e2, i2;
      const n2 = {};
      for (e2 in this.attributes) {
        i2 = this.attributes[e2];
        const o2 = ft(e2);
        if (o2) {
          if (o2.tagName) {
            var r2;
            const e3 = T(o2.tagName);
            r2 ? (r2.appendChild(e3), r2 = e3) : t3 = r2 = e3;
          }
          if (o2.styleProperty && (n2[o2.styleProperty] = i2), o2.style) for (e2 in o2.style) i2 = o2.style[e2], n2[e2] = i2;
        }
      }
      if (Object.keys(n2).length) for (e2 in t3 || (t3 = T("span")), n2) i2 = n2[e2], t3.style[e2] = i2;
      return t3;
    }
    createContainerElement() {
      for (const t3 in this.attributes) {
        const e2 = this.attributes[t3], i2 = ft(t3);
        if (i2 && i2.groupTagName) {
          const n2 = {};
          return n2[t3] = e2, T(i2.groupTagName, n2);
        }
      }
    }
    preserveSpaces(t3) {
      return this.context.isLast && (t3 = t3.replace(/\ $/, g)), t3 = t3.replace(/(\S)\ {3}(\S)/g, "$1 ".concat(g, " $2")).replace(/\ {2}/g, "".concat(g, " ")).replace(/\ {2}/g, " ".concat(g)), (this.context.isFirst || this.context.followsWhitespace) && (t3 = t3.replace(/^\ /, g)), t3;
    }
  };
  var yi = class extends ie {
    constructor() {
      super(...arguments), this.text = this.object, this.textConfig = this.options.textConfig;
    }
    createNodes() {
      const t3 = [], e2 = $t.groupObjects(this.getPieces()), i2 = e2.length - 1;
      for (let r2 = 0; r2 < e2.length; r2++) {
        const o2 = e2[r2], s2 = {};
        0 === r2 && (s2.isFirst = true), r2 === i2 && (s2.isLast = true), xi(n2) && (s2.followsWhitespace = true);
        const a2 = this.findOrCreateCachedChildView(Ai, o2, { textConfig: this.textConfig, context: s2 });
        t3.push(...Array.from(a2.getNodes() || []));
        var n2 = o2;
      }
      return t3;
    }
    getPieces() {
      return Array.from(this.text.getPieces()).filter((t3) => !t3.hasAttribute("blockBreak"));
    }
  };
  var xi = (t3) => /\s$/.test(null == t3 ? void 0 : t3.toString());
  var { css: Ci } = z;
  var Ei = class extends ie {
    constructor() {
      super(...arguments), this.block = this.object, this.attributes = this.block.getAttributes();
    }
    createNodes() {
      const t3 = [document.createComment("block")];
      if (this.block.isEmpty()) t3.push(T("br"));
      else {
        var e2;
        const i2 = null === (e2 = mt(this.block.getLastAttribute())) || void 0 === e2 ? void 0 : e2.text, n2 = this.findOrCreateCachedChildView(yi, this.block.text, { textConfig: i2 });
        t3.push(...Array.from(n2.getNodes() || [])), this.shouldAddExtraNewlineElement() && t3.push(T("br"));
      }
      if (this.attributes.length) return t3;
      {
        let e3;
        const { tagName: i2 } = n.default;
        this.block.isRTL() && (e3 = { dir: "rtl" });
        const r2 = T({ tagName: i2, attributes: e3 });
        return t3.forEach((t4) => r2.appendChild(t4)), [r2];
      }
    }
    createContainerElement(t3) {
      const e2 = {};
      let i2;
      const n2 = this.attributes[t3], { tagName: r2, htmlAttributes: o2 = [] } = mt(n2);
      if (0 === t3 && this.block.isRTL() && Object.assign(e2, { dir: "rtl" }), "attachmentGallery" === n2) {
        const t4 = this.block.getBlockBreakPosition();
        i2 = "".concat(Ci.attachmentGallery, " ").concat(Ci.attachmentGallery, "--").concat(t4);
      }
      return Object.entries(this.block.htmlAttributes).forEach((t4) => {
        let [i3, n3] = t4;
        o2.includes(i3) && (e2[i3] = n3);
      }), T({ tagName: r2, className: i2, attributes: e2 });
    }
    shouldAddExtraNewlineElement() {
      return /\n\n$/.test(this.block.toString());
    }
  };
  var Si = class extends ie {
    static render(t3) {
      const e2 = T("div"), i2 = new this(t3, { element: e2 });
      return i2.render(), i2.sync(), e2;
    }
    constructor() {
      super(...arguments), this.element = this.options.element, this.elementStore = new Qt(), this.setDocument(this.object);
    }
    setDocument(t3) {
      t3.isEqualTo(this.document) || (this.document = this.object = t3);
    }
    render() {
      if (this.childViews = [], this.shadowElement = T("div"), !this.document.isEmpty()) {
        const t3 = $t.groupObjects(this.document.getBlocks(), { asTree: true });
        Array.from(t3).forEach((t4) => {
          const e2 = this.findOrCreateCachedChildView(Ei, t4);
          Array.from(e2.getNodes()).map((t5) => this.shadowElement.appendChild(t5));
        });
      }
    }
    isSynced() {
      return ki(this.shadowElement, this.element);
    }
    sync() {
      const t3 = this.createDocumentFragmentForSync();
      for (; this.element.lastChild; ) this.element.removeChild(this.element.lastChild);
      return this.element.appendChild(t3), this.didSync();
    }
    didSync() {
      return this.elementStore.reset(Ri(this.element)), Rt(() => this.garbageCollectCachedViews());
    }
    createDocumentFragmentForSync() {
      const t3 = document.createDocumentFragment();
      return Array.from(this.shadowElement.childNodes).forEach((e2) => {
        t3.appendChild(e2.cloneNode(true));
      }), Array.from(Ri(t3)).forEach((t4) => {
        const e2 = this.elementStore.remove(t4);
        e2 && t4.parentNode.replaceChild(e2, t4);
      }), t3;
    }
  };
  var Ri = (t3) => t3.querySelectorAll("[data-trix-store-key]");
  var ki = (t3, e2) => Ti(t3.innerHTML) === Ti(e2.innerHTML);
  var Ti = (t3) => t3.replace(/&nbsp;/g, " ");
  function wi(t3) {
    var e2, i2;
    function n2(e3, i3) {
      try {
        var o2 = t3[e3](i3), s2 = o2.value, a2 = s2 instanceof Li;
        Promise.resolve(a2 ? s2.v : s2).then(function(i4) {
          if (a2) {
            var l2 = "return" === e3 ? "return" : "next";
            if (!s2.k || i4.done) return n2(l2, i4);
            i4 = t3[l2](i4).value;
          }
          r2(o2.done ? "return" : "normal", i4);
        }, function(t4) {
          n2("throw", t4);
        });
      } catch (t4) {
        r2("throw", t4);
      }
    }
    function r2(t4, r3) {
      switch (t4) {
        case "return":
          e2.resolve({ value: r3, done: true });
          break;
        case "throw":
          e2.reject(r3);
          break;
        default:
          e2.resolve({ value: r3, done: false });
      }
      (e2 = e2.next) ? n2(e2.key, e2.arg) : i2 = null;
    }
    this._invoke = function(t4, r3) {
      return new Promise(function(o2, s2) {
        var a2 = { key: t4, arg: r3, resolve: o2, reject: s2, next: null };
        i2 ? i2 = i2.next = a2 : (e2 = i2 = a2, n2(t4, r3));
      });
    }, "function" != typeof t3.return && (this.return = void 0);
  }
  function Li(t3, e2) {
    this.v = t3, this.k = e2;
  }
  function Di(t3, e2, i2) {
    return (e2 = Ni(e2)) in t3 ? Object.defineProperty(t3, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t3[e2] = i2, t3;
  }
  function Ni(t3) {
    var e2 = function(t4, e3) {
      if ("object" != typeof t4 || null === t4) return t4;
      var i2 = t4[Symbol.toPrimitive];
      if (void 0 !== i2) {
        var n2 = i2.call(t4, e3 || "default");
        if ("object" != typeof n2) return n2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === e3 ? String : Number)(t4);
    }(t3, "string");
    return "symbol" == typeof e2 ? e2 : String(e2);
  }
  wi.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
    return this;
  }, wi.prototype.next = function(t3) {
    return this._invoke("next", t3);
  }, wi.prototype.throw = function(t3) {
    return this._invoke("throw", t3);
  }, wi.prototype.return = function(t3) {
    return this._invoke("return", t3);
  };
  function Ii(t3, e2) {
    return Pi(t3, Fi(t3, e2, "get"));
  }
  function Oi(t3, e2, i2) {
    return Mi(t3, Fi(t3, e2, "set"), i2), i2;
  }
  function Fi(t3, e2, i2) {
    if (!e2.has(t3)) throw new TypeError("attempted to " + i2 + " private field on non-instance");
    return e2.get(t3);
  }
  function Pi(t3, e2) {
    return e2.get ? e2.get.call(t3) : e2.value;
  }
  function Mi(t3, e2, i2) {
    if (e2.set) e2.set.call(t3, i2);
    else {
      if (!e2.writable) throw new TypeError("attempted to set read only private field");
      e2.value = i2;
    }
  }
  function Bi(t3, e2, i2) {
    if (!e2.has(t3)) throw new TypeError("attempted to get private field on non-instance");
    return i2;
  }
  function _i(t3, e2) {
    if (e2.has(t3)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function ji(t3, e2, i2) {
    _i(t3, e2), e2.set(t3, i2);
  }
  var Wi = class extends rt {
    static registerType(t3, e2) {
      e2.type = t3, this.types[t3] = e2;
    }
    static fromJSON(t3) {
      const e2 = this.types[t3.type];
      if (e2) return e2.fromJSON(t3);
    }
    constructor(t3) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.attributes = Ht.box(e2);
    }
    copyWithAttributes(t3) {
      return new this.constructor(this.getValue(), t3);
    }
    copyWithAdditionalAttributes(t3) {
      return this.copyWithAttributes(this.attributes.merge(t3));
    }
    copyWithoutAttribute(t3) {
      return this.copyWithAttributes(this.attributes.remove(t3));
    }
    copy() {
      return this.copyWithAttributes(this.attributes);
    }
    getAttribute(t3) {
      return this.attributes.get(t3);
    }
    getAttributesHash() {
      return this.attributes;
    }
    getAttributes() {
      return this.attributes.toObject();
    }
    hasAttribute(t3) {
      return this.attributes.has(t3);
    }
    hasSameStringValueAsPiece(t3) {
      return t3 && this.toString() === t3.toString();
    }
    hasSameAttributesAsPiece(t3) {
      return t3 && (this.attributes === t3.attributes || this.attributes.isEqualTo(t3.attributes));
    }
    isBlockBreak() {
      return false;
    }
    isEqualTo(t3) {
      return super.isEqualTo(...arguments) || this.hasSameConstructorAs(t3) && this.hasSameStringValueAsPiece(t3) && this.hasSameAttributesAsPiece(t3);
    }
    isEmpty() {
      return 0 === this.length;
    }
    isSerializable() {
      return true;
    }
    toJSON() {
      return { type: this.constructor.type, attributes: this.getAttributes() };
    }
    contentsForInspection() {
      return { type: this.constructor.type, attributes: this.attributes.inspect() };
    }
    canBeGrouped() {
      return this.hasAttribute("href");
    }
    canBeGroupedWith(t3) {
      return this.getAttribute("href") === t3.getAttribute("href");
    }
    getLength() {
      return this.length;
    }
    canBeConsolidatedWith(t3) {
      return false;
    }
  };
  Di(Wi, "types", {});
  var Ui = class extends ee {
    constructor(t3) {
      super(...arguments), this.url = t3;
    }
    perform(t3) {
      const e2 = new Image();
      e2.onload = () => (e2.width = this.width = e2.naturalWidth, e2.height = this.height = e2.naturalHeight, t3(true, e2)), e2.onerror = () => t3(false), e2.src = this.url;
    }
  };
  var Vi = class _Vi extends rt {
    static attachmentForFile(t3) {
      const e2 = new this(this.attributesForFile(t3));
      return e2.setFile(t3), e2;
    }
    static attributesForFile(t3) {
      return new Ht({ filename: t3.name, filesize: t3.size, contentType: t3.type });
    }
    static fromJSON(t3) {
      return new this(t3);
    }
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(t3), this.releaseFile = this.releaseFile.bind(this), this.attributes = Ht.box(t3), this.didChangeAttributes();
    }
    getAttribute(t3) {
      return this.attributes.get(t3);
    }
    hasAttribute(t3) {
      return this.attributes.has(t3);
    }
    getAttributes() {
      return this.attributes.toObject();
    }
    setAttributes() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const e2 = this.attributes.merge(t3);
      var i2, n2, r2, o2;
      if (!this.attributes.isEqualTo(e2)) return this.attributes = e2, this.didChangeAttributes(), null === (i2 = this.previewDelegate) || void 0 === i2 || null === (n2 = i2.attachmentDidChangeAttributes) || void 0 === n2 || n2.call(i2, this), null === (r2 = this.delegate) || void 0 === r2 || null === (o2 = r2.attachmentDidChangeAttributes) || void 0 === o2 ? void 0 : o2.call(r2, this);
    }
    didChangeAttributes() {
      if (this.isPreviewable()) return this.preloadURL();
    }
    isPending() {
      return null != this.file && !(this.getURL() || this.getHref());
    }
    isPreviewable() {
      return this.attributes.has("previewable") ? this.attributes.get("previewable") : _Vi.previewablePattern.test(this.getContentType());
    }
    getType() {
      return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
    }
    getURL() {
      return this.attributes.get("url");
    }
    getHref() {
      return this.attributes.get("href");
    }
    getFilename() {
      return this.attributes.get("filename") || "";
    }
    getFilesize() {
      return this.attributes.get("filesize");
    }
    getFormattedFilesize() {
      const t3 = this.attributes.get("filesize");
      return "number" == typeof t3 ? h.formatter(t3) : "";
    }
    getExtension() {
      var t3;
      return null === (t3 = this.getFilename().match(/\.(\w+)$/)) || void 0 === t3 ? void 0 : t3[1].toLowerCase();
    }
    getContentType() {
      return this.attributes.get("contentType");
    }
    hasContent() {
      return this.attributes.has("content");
    }
    getContent() {
      return this.attributes.get("content");
    }
    getWidth() {
      return this.attributes.get("width");
    }
    getHeight() {
      return this.attributes.get("height");
    }
    getFile() {
      return this.file;
    }
    setFile(t3) {
      if (this.file = t3, this.isPreviewable()) return this.preloadFile();
    }
    releaseFile() {
      this.releasePreloadedFile(), this.file = null;
    }
    getUploadProgress() {
      return null != this.uploadProgress ? this.uploadProgress : 0;
    }
    setUploadProgress(t3) {
      var e2, i2;
      if (this.uploadProgress !== t3) return this.uploadProgress = t3, null === (e2 = this.uploadProgressDelegate) || void 0 === e2 || null === (i2 = e2.attachmentDidChangeUploadProgress) || void 0 === i2 ? void 0 : i2.call(e2, this);
    }
    toJSON() {
      return this.getAttributes();
    }
    getCacheKey() {
      return [super.getCacheKey(...arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
    }
    getPreviewURL() {
      return this.previewURL || this.preloadingURL;
    }
    setPreviewURL(t3) {
      var e2, i2, n2, r2;
      if (t3 !== this.getPreviewURL()) return this.previewURL = t3, null === (e2 = this.previewDelegate) || void 0 === e2 || null === (i2 = e2.attachmentDidChangeAttributes) || void 0 === i2 || i2.call(e2, this), null === (n2 = this.delegate) || void 0 === n2 || null === (r2 = n2.attachmentDidChangePreviewURL) || void 0 === r2 ? void 0 : r2.call(n2, this);
    }
    preloadURL() {
      return this.preload(this.getURL(), this.releaseFile);
    }
    preloadFile() {
      if (this.file) return this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL);
    }
    releasePreloadedFile() {
      this.fileObjectURL && (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null);
    }
    preload(t3, e2) {
      if (t3 && t3 !== this.getPreviewURL()) {
        this.preloadingURL = t3;
        return new Ui(t3).then((i2) => {
          let { width: n2, height: r2 } = i2;
          return this.getWidth() && this.getHeight() || this.setAttributes({ width: n2, height: r2 }), this.preloadingURL = null, this.setPreviewURL(t3), null == e2 ? void 0 : e2();
        }).catch(() => (this.preloadingURL = null, null == e2 ? void 0 : e2()));
      }
    }
  };
  Di(Vi, "previewablePattern", /^image(\/(gif|png|webp|jpe?g)|$)/);
  var zi = class _zi extends Wi {
    static fromJSON(t3) {
      return new this(Vi.fromJSON(t3.attachment), t3.attributes);
    }
    constructor(t3) {
      super(...arguments), this.attachment = t3, this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
    }
    ensureAttachmentExclusivelyHasAttribute(t3) {
      this.hasAttribute(t3) && (this.attachment.hasAttribute(t3) || this.attachment.setAttributes(this.attributes.slice([t3])), this.attributes = this.attributes.remove(t3));
    }
    removeProhibitedAttributes() {
      const t3 = this.attributes.slice(_zi.permittedAttributes);
      t3.isEqualTo(this.attributes) || (this.attributes = t3);
    }
    getValue() {
      return this.attachment;
    }
    isSerializable() {
      return !this.attachment.isPending();
    }
    getCaption() {
      return this.attributes.get("caption") || "";
    }
    isEqualTo(t3) {
      var e2;
      return super.isEqualTo(t3) && this.attachment.id === (null == t3 || null === (e2 = t3.attachment) || void 0 === e2 ? void 0 : e2.id);
    }
    toString() {
      return "\uFFFC";
    }
    toJSON() {
      const t3 = super.toJSON(...arguments);
      return t3.attachment = this.attachment, t3;
    }
    getCacheKey() {
      return [super.getCacheKey(...arguments), this.attachment.getCacheKey()].join("/");
    }
    toConsole() {
      return JSON.stringify(this.toString());
    }
  };
  Di(zi, "permittedAttributes", ["caption", "presentation"]), Wi.registerType("attachment", zi);
  var qi = class extends Wi {
    static fromJSON(t3) {
      return new this(t3.string, t3.attributes);
    }
    constructor(t3) {
      super(...arguments), this.string = ((t4) => t4.replace(/\r\n?/g, "\n"))(t3), this.length = this.string.length;
    }
    getValue() {
      return this.string;
    }
    toString() {
      return this.string.toString();
    }
    isBlockBreak() {
      return "\n" === this.toString() && true === this.getAttribute("blockBreak");
    }
    toJSON() {
      const t3 = super.toJSON(...arguments);
      return t3.string = this.string, t3;
    }
    canBeConsolidatedWith(t3) {
      return t3 && this.hasSameConstructorAs(t3) && this.hasSameAttributesAsPiece(t3);
    }
    consolidateWith(t3) {
      return new this.constructor(this.toString() + t3.toString(), this.attributes);
    }
    splitAtOffset(t3) {
      let e2, i2;
      return 0 === t3 ? (e2 = null, i2 = this) : t3 === this.length ? (e2 = this, i2 = null) : (e2 = new this.constructor(this.string.slice(0, t3), this.attributes), i2 = new this.constructor(this.string.slice(t3), this.attributes)), [e2, i2];
    }
    toConsole() {
      let { string: t3 } = this;
      return t3.length > 15 && (t3 = t3.slice(0, 14) + "\u2026"), JSON.stringify(t3.toString());
    }
  };
  Wi.registerType("string", qi);
  var Hi = class extends rt {
    static box(t3) {
      return t3 instanceof this ? t3 : new this(t3);
    }
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.objects = t3.slice(0), this.length = this.objects.length;
    }
    indexOf(t3) {
      return this.objects.indexOf(t3);
    }
    splice() {
      for (var t3 = arguments.length, e2 = new Array(t3), i2 = 0; i2 < t3; i2++) e2[i2] = arguments[i2];
      return new this.constructor(st(this.objects, ...e2));
    }
    eachObject(t3) {
      return this.objects.map((e2, i2) => t3(e2, i2));
    }
    insertObjectAtIndex(t3, e2) {
      return this.splice(e2, 0, t3);
    }
    insertSplittableListAtIndex(t3, e2) {
      return this.splice(e2, 0, ...t3.objects);
    }
    insertSplittableListAtPosition(t3, e2) {
      const [i2, n2] = this.splitObjectAtPosition(e2);
      return new this.constructor(i2).insertSplittableListAtIndex(t3, n2);
    }
    editObjectAtIndex(t3, e2) {
      return this.replaceObjectAtIndex(e2(this.objects[t3]), t3);
    }
    replaceObjectAtIndex(t3, e2) {
      return this.splice(e2, 1, t3);
    }
    removeObjectAtIndex(t3) {
      return this.splice(t3, 1);
    }
    getObjectAtIndex(t3) {
      return this.objects[t3];
    }
    getSplittableListInRange(t3) {
      const [e2, i2, n2] = this.splitObjectsAtRange(t3);
      return new this.constructor(e2.slice(i2, n2 + 1));
    }
    selectSplittableList(t3) {
      const e2 = this.objects.filter((e3) => t3(e3));
      return new this.constructor(e2);
    }
    removeObjectsInRange(t3) {
      const [e2, i2, n2] = this.splitObjectsAtRange(t3);
      return new this.constructor(e2).splice(i2, n2 - i2 + 1);
    }
    transformObjectsInRange(t3, e2) {
      const [i2, n2, r2] = this.splitObjectsAtRange(t3), o2 = i2.map((t4, i3) => n2 <= i3 && i3 <= r2 ? e2(t4) : t4);
      return new this.constructor(o2);
    }
    splitObjectsAtRange(t3) {
      let e2, [i2, n2, r2] = this.splitObjectAtPosition(Ki(t3));
      return [i2, e2] = new this.constructor(i2).splitObjectAtPosition(Gi(t3) + r2), [i2, n2, e2 - 1];
    }
    getObjectAtPosition(t3) {
      const { index: e2 } = this.findIndexAndOffsetAtPosition(t3);
      return this.objects[e2];
    }
    splitObjectAtPosition(t3) {
      let e2, i2;
      const { index: n2, offset: r2 } = this.findIndexAndOffsetAtPosition(t3), o2 = this.objects.slice(0);
      if (null != n2) if (0 === r2) e2 = n2, i2 = 0;
      else {
        const t4 = this.getObjectAtIndex(n2), [s2, a2] = t4.splitAtOffset(r2);
        o2.splice(n2, 1, s2, a2), e2 = n2 + 1, i2 = s2.getLength() - r2;
      }
      else e2 = o2.length, i2 = 0;
      return [o2, e2, i2];
    }
    consolidate() {
      const t3 = [];
      let e2 = this.objects[0];
      return this.objects.slice(1).forEach((i2) => {
        var n2, r2;
        null !== (n2 = (r2 = e2).canBeConsolidatedWith) && void 0 !== n2 && n2.call(r2, i2) ? e2 = e2.consolidateWith(i2) : (t3.push(e2), e2 = i2);
      }), e2 && t3.push(e2), new this.constructor(t3);
    }
    consolidateFromIndexToIndex(t3, e2) {
      const i2 = this.objects.slice(0).slice(t3, e2 + 1), n2 = new this.constructor(i2).consolidate().toArray();
      return this.splice(t3, i2.length, ...n2);
    }
    findIndexAndOffsetAtPosition(t3) {
      let e2, i2 = 0;
      for (e2 = 0; e2 < this.objects.length; e2++) {
        const n2 = i2 + this.objects[e2].getLength();
        if (i2 <= t3 && t3 < n2) return { index: e2, offset: t3 - i2 };
        i2 = n2;
      }
      return { index: null, offset: null };
    }
    findPositionAtIndexAndOffset(t3, e2) {
      let i2 = 0;
      for (let n2 = 0; n2 < this.objects.length; n2++) {
        const r2 = this.objects[n2];
        if (n2 < t3) i2 += r2.getLength();
        else if (n2 === t3) {
          i2 += e2;
          break;
        }
      }
      return i2;
    }
    getEndPosition() {
      return null == this.endPosition && (this.endPosition = 0, this.objects.forEach((t3) => this.endPosition += t3.getLength())), this.endPosition;
    }
    toString() {
      return this.objects.join("");
    }
    toArray() {
      return this.objects.slice(0);
    }
    toJSON() {
      return this.toArray();
    }
    isEqualTo(t3) {
      return super.isEqualTo(...arguments) || Ji(this.objects, null == t3 ? void 0 : t3.objects);
    }
    contentsForInspection() {
      return { objects: "[".concat(this.objects.map((t3) => t3.inspect()).join(", "), "]") };
    }
  };
  var Ji = function(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (t3.length !== e2.length) return false;
    let i2 = true;
    for (let n2 = 0; n2 < t3.length; n2++) {
      const r2 = t3[n2];
      i2 && !r2.isEqualTo(e2[n2]) && (i2 = false);
    }
    return i2;
  };
  var Ki = (t3) => t3[0];
  var Gi = (t3) => t3[1];
  var Yi = class extends rt {
    static textForAttachmentWithAttributes(t3, e2) {
      return new this([new zi(t3, e2)]);
    }
    static textForStringWithAttributes(t3, e2) {
      return new this([new qi(t3, e2)]);
    }
    static fromJSON(t3) {
      return new this(Array.from(t3).map((t4) => Wi.fromJSON(t4)));
    }
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments);
      const e2 = t3.filter((t4) => !t4.isEmpty());
      this.pieceList = new Hi(e2);
    }
    copy() {
      return this.copyWithPieceList(this.pieceList);
    }
    copyWithPieceList(t3) {
      return new this.constructor(t3.consolidate().toArray());
    }
    copyUsingObjectMap(t3) {
      const e2 = this.getPieces().map((e3) => t3.find(e3) || e3);
      return new this.constructor(e2);
    }
    appendText(t3) {
      return this.insertTextAtPosition(t3, this.getLength());
    }
    insertTextAtPosition(t3, e2) {
      return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t3.pieceList, e2));
    }
    removeTextAtRange(t3) {
      return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t3));
    }
    replaceTextAtRange(t3, e2) {
      return this.removeTextAtRange(e2).insertTextAtPosition(t3, e2[0]);
    }
    moveTextFromRangeToPosition(t3, e2) {
      if (t3[0] <= e2 && e2 <= t3[1]) return;
      const i2 = this.getTextAtRange(t3), n2 = i2.getLength();
      return t3[0] < e2 && (e2 -= n2), this.removeTextAtRange(t3).insertTextAtPosition(i2, e2);
    }
    addAttributeAtRange(t3, e2, i2) {
      const n2 = {};
      return n2[t3] = e2, this.addAttributesAtRange(n2, i2);
    }
    addAttributesAtRange(t3, e2) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithAdditionalAttributes(t3)));
    }
    removeAttributeAtRange(t3, e2) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithoutAttribute(t3)));
    }
    setAttributesAtRange(t3, e2) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithAttributes(t3)));
    }
    getAttributesAtPosition(t3) {
      var e2;
      return (null === (e2 = this.pieceList.getObjectAtPosition(t3)) || void 0 === e2 ? void 0 : e2.getAttributes()) || {};
    }
    getCommonAttributes() {
      const t3 = Array.from(this.pieceList.toArray()).map((t4) => t4.getAttributes());
      return Ht.fromCommonAttributesOfObjects(t3).toObject();
    }
    getCommonAttributesAtRange(t3) {
      return this.getTextAtRange(t3).getCommonAttributes() || {};
    }
    getExpandedRangeForAttributeAtOffset(t3, e2) {
      let i2, n2 = i2 = e2;
      const r2 = this.getLength();
      for (; n2 > 0 && this.getCommonAttributesAtRange([n2 - 1, i2])[t3]; ) n2--;
      for (; i2 < r2 && this.getCommonAttributesAtRange([e2, i2 + 1])[t3]; ) i2++;
      return [n2, i2];
    }
    getTextAtRange(t3) {
      return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t3));
    }
    getStringAtRange(t3) {
      return this.pieceList.getSplittableListInRange(t3).toString();
    }
    getStringAtPosition(t3) {
      return this.getStringAtRange([t3, t3 + 1]);
    }
    startsWithString(t3) {
      return this.getStringAtRange([0, t3.length]) === t3;
    }
    endsWithString(t3) {
      const e2 = this.getLength();
      return this.getStringAtRange([e2 - t3.length, e2]) === t3;
    }
    getAttachmentPieces() {
      return this.pieceList.toArray().filter((t3) => !!t3.attachment);
    }
    getAttachments() {
      return this.getAttachmentPieces().map((t3) => t3.attachment);
    }
    getAttachmentAndPositionById(t3) {
      let e2 = 0;
      for (const n2 of this.pieceList.toArray()) {
        var i2;
        if ((null === (i2 = n2.attachment) || void 0 === i2 ? void 0 : i2.id) === t3) return { attachment: n2.attachment, position: e2 };
        e2 += n2.length;
      }
      return { attachment: null, position: null };
    }
    getAttachmentById(t3) {
      const { attachment: e2 } = this.getAttachmentAndPositionById(t3);
      return e2;
    }
    getRangeOfAttachment(t3) {
      const e2 = this.getAttachmentAndPositionById(t3.id), i2 = e2.position;
      if (t3 = e2.attachment) return [i2, i2 + 1];
    }
    updateAttributesForAttachment(t3, e2) {
      const i2 = this.getRangeOfAttachment(e2);
      return i2 ? this.addAttributesAtRange(t3, i2) : this;
    }
    getLength() {
      return this.pieceList.getEndPosition();
    }
    isEmpty() {
      return 0 === this.getLength();
    }
    isEqualTo(t3) {
      var e2;
      return super.isEqualTo(t3) || (null == t3 || null === (e2 = t3.pieceList) || void 0 === e2 ? void 0 : e2.isEqualTo(this.pieceList));
    }
    isBlockBreak() {
      return 1 === this.getLength() && this.pieceList.getObjectAtIndex(0).isBlockBreak();
    }
    eachPiece(t3) {
      return this.pieceList.eachObject(t3);
    }
    getPieces() {
      return this.pieceList.toArray();
    }
    getPieceAtPosition(t3) {
      return this.pieceList.getObjectAtPosition(t3);
    }
    contentsForInspection() {
      return { pieceList: this.pieceList.inspect() };
    }
    toSerializableText() {
      const t3 = this.pieceList.selectSplittableList((t4) => t4.isSerializable());
      return this.copyWithPieceList(t3);
    }
    toString() {
      return this.pieceList.toString();
    }
    toJSON() {
      return this.pieceList.toJSON();
    }
    toConsole() {
      return JSON.stringify(this.pieceList.toArray().map((t3) => JSON.parse(t3.toConsole())));
    }
    getDirection() {
      return lt(this.toString());
    }
    isRTL() {
      return "rtl" === this.getDirection();
    }
  };
  var Xi = class _Xi extends rt {
    static fromJSON(t3) {
      return new this(Yi.fromJSON(t3.text), t3.attributes, t3.htmlAttributes);
    }
    constructor(t3, e2, i2) {
      super(...arguments), this.text = $i(t3 || new Yi()), this.attributes = e2 || [], this.htmlAttributes = i2 || {};
    }
    isEmpty() {
      return this.text.isBlockBreak();
    }
    isEqualTo(t3) {
      return !!super.isEqualTo(t3) || this.text.isEqualTo(null == t3 ? void 0 : t3.text) && ot(this.attributes, null == t3 ? void 0 : t3.attributes) && Tt(this.htmlAttributes, null == t3 ? void 0 : t3.htmlAttributes);
    }
    copyWithText(t3) {
      return new _Xi(t3, this.attributes, this.htmlAttributes);
    }
    copyWithoutText() {
      return this.copyWithText(null);
    }
    copyWithAttributes(t3) {
      return new _Xi(this.text, t3, this.htmlAttributes);
    }
    copyWithoutAttributes() {
      return this.copyWithAttributes(null);
    }
    copyUsingObjectMap(t3) {
      const e2 = t3.find(this.text);
      return e2 ? this.copyWithText(e2) : this.copyWithText(this.text.copyUsingObjectMap(t3));
    }
    addAttribute(t3) {
      const e2 = this.attributes.concat(rn(t3));
      return this.copyWithAttributes(e2);
    }
    addHTMLAttribute(t3, e2) {
      const i2 = Object.assign({}, this.htmlAttributes, { [t3]: e2 });
      return new _Xi(this.text, this.attributes, i2);
    }
    removeAttribute(t3) {
      const { listAttribute: e2 } = mt(t3), i2 = sn(sn(this.attributes, t3), e2);
      return this.copyWithAttributes(i2);
    }
    removeLastAttribute() {
      return this.removeAttribute(this.getLastAttribute());
    }
    getLastAttribute() {
      return on(this.attributes);
    }
    getAttributes() {
      return this.attributes.slice(0);
    }
    getAttributeLevel() {
      return this.attributes.length;
    }
    getAttributeAtLevel(t3) {
      return this.attributes[t3 - 1];
    }
    hasAttribute(t3) {
      return this.attributes.includes(t3);
    }
    hasAttributes() {
      return this.getAttributeLevel() > 0;
    }
    getLastNestableAttribute() {
      return on(this.getNestableAttributes());
    }
    getNestableAttributes() {
      return this.attributes.filter((t3) => mt(t3).nestable);
    }
    getNestingLevel() {
      return this.getNestableAttributes().length;
    }
    decreaseNestingLevel() {
      const t3 = this.getLastNestableAttribute();
      return t3 ? this.removeAttribute(t3) : this;
    }
    increaseNestingLevel() {
      const t3 = this.getLastNestableAttribute();
      if (t3) {
        const e2 = this.attributes.lastIndexOf(t3), i2 = st(this.attributes, e2 + 1, 0, ...rn(t3));
        return this.copyWithAttributes(i2);
      }
      return this;
    }
    getListItemAttributes() {
      return this.attributes.filter((t3) => mt(t3).listAttribute);
    }
    isListItem() {
      var t3;
      return null === (t3 = mt(this.getLastAttribute())) || void 0 === t3 ? void 0 : t3.listAttribute;
    }
    isTerminalBlock() {
      var t3;
      return null === (t3 = mt(this.getLastAttribute())) || void 0 === t3 ? void 0 : t3.terminal;
    }
    breaksOnReturn() {
      var t3;
      return null === (t3 = mt(this.getLastAttribute())) || void 0 === t3 ? void 0 : t3.breakOnReturn;
    }
    findLineBreakInDirectionFromPosition(t3, e2) {
      const i2 = this.toString();
      let n2;
      switch (t3) {
        case "forward":
          n2 = i2.indexOf("\n", e2);
          break;
        case "backward":
          n2 = i2.slice(0, e2).lastIndexOf("\n");
      }
      if (-1 !== n2) return n2;
    }
    contentsForInspection() {
      return { text: this.text.inspect(), attributes: this.attributes };
    }
    toString() {
      return this.text.toString();
    }
    toJSON() {
      return { text: this.text, attributes: this.attributes, htmlAttributes: this.htmlAttributes };
    }
    getDirection() {
      return this.text.getDirection();
    }
    isRTL() {
      return this.text.isRTL();
    }
    getLength() {
      return this.text.getLength();
    }
    canBeConsolidatedWith(t3) {
      return !this.hasAttributes() && !t3.hasAttributes() && this.getDirection() === t3.getDirection();
    }
    consolidateWith(t3) {
      const e2 = Yi.textForStringWithAttributes("\n"), i2 = this.getTextWithoutBlockBreak().appendText(e2);
      return this.copyWithText(i2.appendText(t3.text));
    }
    splitAtOffset(t3) {
      let e2, i2;
      return 0 === t3 ? (e2 = null, i2 = this) : t3 === this.getLength() ? (e2 = this, i2 = null) : (e2 = this.copyWithText(this.text.getTextAtRange([0, t3])), i2 = this.copyWithText(this.text.getTextAtRange([t3, this.getLength()]))), [e2, i2];
    }
    getBlockBreakPosition() {
      return this.text.getLength() - 1;
    }
    getTextWithoutBlockBreak() {
      return en(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
    }
    canBeGrouped(t3) {
      return this.attributes[t3];
    }
    canBeGroupedWith(t3, e2) {
      const i2 = t3.getAttributes(), r2 = i2[e2], o2 = this.attributes[e2];
      return o2 === r2 && !(false === mt(o2).group && !(() => {
        if (!dt) {
          dt = [];
          for (const t4 in n) {
            const { listAttribute: e3 } = n[t4];
            null != e3 && dt.push(e3);
          }
        }
        return dt;
      })().includes(i2[e2 + 1])) && (this.getDirection() === t3.getDirection() || t3.isEmpty());
    }
  };
  var $i = function(t3) {
    return t3 = Zi(t3), t3 = tn(t3);
  };
  var Zi = function(t3) {
    let e2 = false;
    const i2 = t3.getPieces();
    let n2 = i2.slice(0, i2.length - 1);
    const r2 = i2[i2.length - 1];
    return r2 ? (n2 = n2.map((t4) => t4.isBlockBreak() ? (e2 = true, nn(t4)) : t4), e2 ? new Yi([...n2, r2]) : t3) : t3;
  };
  var Qi = Yi.textForStringWithAttributes("\n", { blockBreak: true });
  var tn = function(t3) {
    return en(t3) ? t3 : t3.appendText(Qi);
  };
  var en = function(t3) {
    const e2 = t3.getLength();
    if (0 === e2) return false;
    return t3.getTextAtRange([e2 - 1, e2]).isBlockBreak();
  };
  var nn = (t3) => t3.copyWithoutAttribute("blockBreak");
  var rn = function(t3) {
    const { listAttribute: e2 } = mt(t3);
    return e2 ? [e2, t3] : [t3];
  };
  var on = (t3) => t3.slice(-1)[0];
  var sn = function(t3, e2) {
    const i2 = t3.lastIndexOf(e2);
    return -1 === i2 ? t3 : st(t3, i2, 1);
  };
  var an = class extends rt {
    static fromJSON(t3) {
      return new this(Array.from(t3).map((t4) => Xi.fromJSON(t4)));
    }
    static fromString(t3, e2) {
      const i2 = Yi.textForStringWithAttributes(t3, e2);
      return new this([new Xi(i2)]);
    }
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), 0 === t3.length && (t3 = [new Xi()]), this.blockList = Hi.box(t3);
    }
    isEmpty() {
      const t3 = this.getBlockAtIndex(0);
      return 1 === this.blockList.length && t3.isEmpty() && !t3.hasAttributes();
    }
    copy() {
      const t3 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray();
      return new this.constructor(t3);
    }
    copyUsingObjectsFromDocument(t3) {
      const e2 = new Zt(t3.getObjects());
      return this.copyUsingObjectMap(e2);
    }
    copyUsingObjectMap(t3) {
      const e2 = this.getBlocks().map((e3) => t3.find(e3) || e3.copyUsingObjectMap(t3));
      return new this.constructor(e2);
    }
    copyWithBaseBlockAttributes() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      const e2 = this.getBlocks().map((e3) => {
        const i2 = t3.concat(e3.getAttributes());
        return e3.copyWithAttributes(i2);
      });
      return new this.constructor(e2);
    }
    replaceBlock(t3, e2) {
      const i2 = this.blockList.indexOf(t3);
      return -1 === i2 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e2, i2));
    }
    insertDocumentAtRange(t3, e2) {
      const { blockList: i2 } = t3;
      e2 = wt(e2);
      let [n2] = e2;
      const { index: r2, offset: o2 } = this.locationFromPosition(n2);
      let s2 = this;
      const a2 = this.getBlockAtPosition(n2);
      return Lt(e2) && a2.isEmpty() && !a2.hasAttributes() ? s2 = new this.constructor(s2.blockList.removeObjectAtIndex(r2)) : a2.getBlockBreakPosition() === o2 && n2++, s2 = s2.removeTextAtRange(e2), new this.constructor(s2.blockList.insertSplittableListAtPosition(i2, n2));
    }
    mergeDocumentAtRange(t3, e2) {
      let i2, n2;
      e2 = wt(e2);
      const [r2] = e2, o2 = this.locationFromPosition(r2), s2 = this.getBlockAtIndex(o2.index).getAttributes(), a2 = t3.getBaseBlockAttributes(), l2 = s2.slice(-a2.length);
      if (ot(a2, l2)) {
        const e3 = s2.slice(0, -a2.length);
        i2 = t3.copyWithBaseBlockAttributes(e3);
      } else i2 = t3.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(s2);
      const c2 = i2.getBlockCount(), u2 = i2.getBlockAtIndex(0);
      if (ot(s2, u2.getAttributes())) {
        const t4 = u2.getTextWithoutBlockBreak();
        if (n2 = this.insertTextAtRange(t4, e2), c2 > 1) {
          i2 = new this.constructor(i2.getBlocks().slice(1));
          const e3 = r2 + t4.getLength();
          n2 = n2.insertDocumentAtRange(i2, e3);
        }
      } else n2 = this.insertDocumentAtRange(i2, e2);
      return n2;
    }
    insertTextAtRange(t3, e2) {
      e2 = wt(e2);
      const [i2] = e2, { index: n2, offset: r2 } = this.locationFromPosition(i2), o2 = this.removeTextAtRange(e2);
      return new this.constructor(o2.blockList.editObjectAtIndex(n2, (e3) => e3.copyWithText(e3.text.insertTextAtPosition(t3, r2))));
    }
    removeTextAtRange(t3) {
      let e2;
      t3 = wt(t3);
      const [i2, n2] = t3;
      if (Lt(t3)) return this;
      const [r2, o2] = Array.from(this.locationRangeFromRange(t3)), s2 = r2.index, a2 = r2.offset, l2 = this.getBlockAtIndex(s2), c2 = o2.index, u2 = o2.offset, h2 = this.getBlockAtIndex(c2);
      if (n2 - i2 == 1 && l2.getBlockBreakPosition() === a2 && h2.getBlockBreakPosition() !== u2 && "\n" === h2.text.getStringAtPosition(u2)) e2 = this.blockList.editObjectAtIndex(c2, (t4) => t4.copyWithText(t4.text.removeTextAtRange([u2, u2 + 1])));
      else {
        let t4;
        const i3 = l2.text.getTextAtRange([0, a2]), n3 = h2.text.getTextAtRange([u2, h2.getLength()]), r3 = i3.appendText(n3);
        t4 = s2 !== c2 && 0 === a2 && l2.getAttributeLevel() >= h2.getAttributeLevel() ? h2.copyWithText(r3) : l2.copyWithText(r3);
        const o3 = c2 + 1 - s2;
        e2 = this.blockList.splice(s2, o3, t4);
      }
      return new this.constructor(e2);
    }
    moveTextFromRangeToPosition(t3, e2) {
      let i2;
      t3 = wt(t3);
      const [n2, r2] = t3;
      if (n2 <= e2 && e2 <= r2) return this;
      let o2 = this.getDocumentAtRange(t3), s2 = this.removeTextAtRange(t3);
      const a2 = n2 < e2;
      a2 && (e2 -= o2.getLength());
      const [l2, ...c2] = o2.getBlocks();
      return 0 === c2.length ? (i2 = l2.getTextWithoutBlockBreak(), a2 && (e2 += 1)) : i2 = l2.text, s2 = s2.insertTextAtRange(i2, e2), 0 === c2.length ? s2 : (o2 = new this.constructor(c2), e2 += i2.getLength(), s2.insertDocumentAtRange(o2, e2));
    }
    addAttributeAtRange(t3, e2, i2) {
      let { blockList: n2 } = this;
      return this.eachBlockAtRange(i2, (i3, r2, o2) => n2 = n2.editObjectAtIndex(o2, function() {
        return mt(t3) ? i3.addAttribute(t3, e2) : r2[0] === r2[1] ? i3 : i3.copyWithText(i3.text.addAttributeAtRange(t3, e2, r2));
      })), new this.constructor(n2);
    }
    addAttribute(t3, e2) {
      let { blockList: i2 } = this;
      return this.eachBlock((n2, r2) => i2 = i2.editObjectAtIndex(r2, () => n2.addAttribute(t3, e2))), new this.constructor(i2);
    }
    removeAttributeAtRange(t3, e2) {
      let { blockList: i2 } = this;
      return this.eachBlockAtRange(e2, function(e3, n2, r2) {
        mt(t3) ? i2 = i2.editObjectAtIndex(r2, () => e3.removeAttribute(t3)) : n2[0] !== n2[1] && (i2 = i2.editObjectAtIndex(r2, () => e3.copyWithText(e3.text.removeAttributeAtRange(t3, n2))));
      }), new this.constructor(i2);
    }
    updateAttributesForAttachment(t3, e2) {
      const i2 = this.getRangeOfAttachment(e2), [n2] = Array.from(i2), { index: r2 } = this.locationFromPosition(n2), o2 = this.getTextAtIndex(r2);
      return new this.constructor(this.blockList.editObjectAtIndex(r2, (i3) => i3.copyWithText(o2.updateAttributesForAttachment(t3, e2))));
    }
    removeAttributeForAttachment(t3, e2) {
      const i2 = this.getRangeOfAttachment(e2);
      return this.removeAttributeAtRange(t3, i2);
    }
    setHTMLAttributeAtPosition(t3, e2, i2) {
      const n2 = this.getBlockAtPosition(t3), r2 = n2.addHTMLAttribute(e2, i2);
      return this.replaceBlock(n2, r2);
    }
    insertBlockBreakAtRange(t3) {
      let e2;
      t3 = wt(t3);
      const [i2] = t3, { offset: n2 } = this.locationFromPosition(i2), r2 = this.removeTextAtRange(t3);
      return 0 === n2 && (e2 = [new Xi()]), new this.constructor(r2.blockList.insertSplittableListAtPosition(new Hi(e2), i2));
    }
    applyBlockAttributeAtRange(t3, e2, i2) {
      const n2 = this.expandRangeToLineBreaksAndSplitBlocks(i2);
      let r2 = n2.document;
      i2 = n2.range;
      const o2 = mt(t3);
      if (o2.listAttribute) {
        r2 = r2.removeLastListAttributeAtRange(i2, { exceptAttributeName: t3 });
        const e3 = r2.convertLineBreaksToBlockBreaksInRange(i2);
        r2 = e3.document, i2 = e3.range;
      } else r2 = o2.exclusive ? r2.removeBlockAttributesAtRange(i2) : o2.terminal ? r2.removeLastTerminalAttributeAtRange(i2) : r2.consolidateBlocksAtRange(i2);
      return r2.addAttributeAtRange(t3, e2, i2);
    }
    removeLastListAttributeAtRange(t3) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { blockList: i2 } = this;
      return this.eachBlockAtRange(t3, function(t4, n2, r2) {
        const o2 = t4.getLastAttribute();
        o2 && mt(o2).listAttribute && o2 !== e2.exceptAttributeName && (i2 = i2.editObjectAtIndex(r2, () => t4.removeAttribute(o2)));
      }), new this.constructor(i2);
    }
    removeLastTerminalAttributeAtRange(t3) {
      let { blockList: e2 } = this;
      return this.eachBlockAtRange(t3, function(t4, i2, n2) {
        const r2 = t4.getLastAttribute();
        r2 && mt(r2).terminal && (e2 = e2.editObjectAtIndex(n2, () => t4.removeAttribute(r2)));
      }), new this.constructor(e2);
    }
    removeBlockAttributesAtRange(t3) {
      let { blockList: e2 } = this;
      return this.eachBlockAtRange(t3, function(t4, i2, n2) {
        t4.hasAttributes() && (e2 = e2.editObjectAtIndex(n2, () => t4.copyWithoutAttributes()));
      }), new this.constructor(e2);
    }
    expandRangeToLineBreaksAndSplitBlocks(t3) {
      let e2;
      t3 = wt(t3);
      let [i2, n2] = t3;
      const r2 = this.locationFromPosition(i2), o2 = this.locationFromPosition(n2);
      let s2 = this;
      const a2 = s2.getBlockAtIndex(r2.index);
      if (r2.offset = a2.findLineBreakInDirectionFromPosition("backward", r2.offset), null != r2.offset && (e2 = s2.positionFromLocation(r2), s2 = s2.insertBlockBreakAtRange([e2, e2 + 1]), o2.index += 1, o2.offset -= s2.getBlockAtIndex(r2.index).getLength(), r2.index += 1), r2.offset = 0, 0 === o2.offset && o2.index > r2.index) o2.index -= 1, o2.offset = s2.getBlockAtIndex(o2.index).getBlockBreakPosition();
      else {
        const t4 = s2.getBlockAtIndex(o2.index);
        "\n" === t4.text.getStringAtRange([o2.offset - 1, o2.offset]) ? o2.offset -= 1 : o2.offset = t4.findLineBreakInDirectionFromPosition("forward", o2.offset), o2.offset !== t4.getBlockBreakPosition() && (e2 = s2.positionFromLocation(o2), s2 = s2.insertBlockBreakAtRange([e2, e2 + 1]));
      }
      return i2 = s2.positionFromLocation(r2), n2 = s2.positionFromLocation(o2), { document: s2, range: t3 = wt([i2, n2]) };
    }
    convertLineBreaksToBlockBreaksInRange(t3) {
      t3 = wt(t3);
      let [e2] = t3;
      const i2 = this.getStringAtRange(t3).slice(0, -1);
      let n2 = this;
      return i2.replace(/.*?\n/g, function(t4) {
        e2 += t4.length, n2 = n2.insertBlockBreakAtRange([e2 - 1, e2]);
      }), { document: n2, range: t3 };
    }
    consolidateBlocksAtRange(t3) {
      t3 = wt(t3);
      const [e2, i2] = t3, n2 = this.locationFromPosition(e2).index, r2 = this.locationFromPosition(i2).index;
      return new this.constructor(this.blockList.consolidateFromIndexToIndex(n2, r2));
    }
    getDocumentAtRange(t3) {
      t3 = wt(t3);
      const e2 = this.blockList.getSplittableListInRange(t3).toArray();
      return new this.constructor(e2);
    }
    getStringAtRange(t3) {
      let e2;
      const i2 = t3 = wt(t3);
      return i2[i2.length - 1] !== this.getLength() && (e2 = -1), this.getDocumentAtRange(t3).toString().slice(0, e2);
    }
    getBlockAtIndex(t3) {
      return this.blockList.getObjectAtIndex(t3);
    }
    getBlockAtPosition(t3) {
      const { index: e2 } = this.locationFromPosition(t3);
      return this.getBlockAtIndex(e2);
    }
    getTextAtIndex(t3) {
      var e2;
      return null === (e2 = this.getBlockAtIndex(t3)) || void 0 === e2 ? void 0 : e2.text;
    }
    getTextAtPosition(t3) {
      const { index: e2 } = this.locationFromPosition(t3);
      return this.getTextAtIndex(e2);
    }
    getPieceAtPosition(t3) {
      const { index: e2, offset: i2 } = this.locationFromPosition(t3);
      return this.getTextAtIndex(e2).getPieceAtPosition(i2);
    }
    getCharacterAtPosition(t3) {
      const { index: e2, offset: i2 } = this.locationFromPosition(t3);
      return this.getTextAtIndex(e2).getStringAtRange([i2, i2 + 1]);
    }
    getLength() {
      return this.blockList.getEndPosition();
    }
    getBlocks() {
      return this.blockList.toArray();
    }
    getBlockCount() {
      return this.blockList.length;
    }
    getEditCount() {
      return this.editCount;
    }
    eachBlock(t3) {
      return this.blockList.eachObject(t3);
    }
    eachBlockAtRange(t3, e2) {
      let i2, n2;
      t3 = wt(t3);
      const [r2, o2] = t3, s2 = this.locationFromPosition(r2), a2 = this.locationFromPosition(o2);
      if (s2.index === a2.index) return i2 = this.getBlockAtIndex(s2.index), n2 = [s2.offset, a2.offset], e2(i2, n2, s2.index);
      for (let t4 = s2.index; t4 <= a2.index; t4++) if (i2 = this.getBlockAtIndex(t4), i2) {
        switch (t4) {
          case s2.index:
            n2 = [s2.offset, i2.text.getLength()];
            break;
          case a2.index:
            n2 = [0, a2.offset];
            break;
          default:
            n2 = [0, i2.text.getLength()];
        }
        e2(i2, n2, t4);
      }
    }
    getCommonAttributesAtRange(t3) {
      t3 = wt(t3);
      const [e2] = t3;
      if (Lt(t3)) return this.getCommonAttributesAtPosition(e2);
      {
        const e3 = [], i2 = [];
        return this.eachBlockAtRange(t3, function(t4, n2) {
          if (n2[0] !== n2[1]) return e3.push(t4.text.getCommonAttributesAtRange(n2)), i2.push(ln(t4));
        }), Ht.fromCommonAttributesOfObjects(e3).merge(Ht.fromCommonAttributesOfObjects(i2)).toObject();
      }
    }
    getCommonAttributesAtPosition(t3) {
      let e2, i2;
      const { index: n2, offset: r2 } = this.locationFromPosition(t3), o2 = this.getBlockAtIndex(n2);
      if (!o2) return {};
      const s2 = ln(o2), a2 = o2.text.getAttributesAtPosition(r2), l2 = o2.text.getAttributesAtPosition(r2 - 1), c2 = Object.keys(W).filter((t4) => W[t4].inheritable);
      for (e2 in l2) i2 = l2[e2], (i2 === a2[e2] || c2.includes(e2)) && (s2[e2] = i2);
      return s2;
    }
    getRangeOfCommonAttributeAtPosition(t3, e2) {
      const { index: i2, offset: n2 } = this.locationFromPosition(e2), r2 = this.getTextAtIndex(i2), [o2, s2] = Array.from(r2.getExpandedRangeForAttributeAtOffset(t3, n2)), a2 = this.positionFromLocation({ index: i2, offset: o2 }), l2 = this.positionFromLocation({ index: i2, offset: s2 });
      return wt([a2, l2]);
    }
    getBaseBlockAttributes() {
      let t3 = this.getBlockAtIndex(0).getAttributes();
      for (let e2 = 1; e2 < this.getBlockCount(); e2++) {
        const i2 = this.getBlockAtIndex(e2).getAttributes(), n2 = Math.min(t3.length, i2.length);
        t3 = (() => {
          const e3 = [];
          for (let r2 = 0; r2 < n2 && i2[r2] === t3[r2]; r2++) e3.push(i2[r2]);
          return e3;
        })();
      }
      return t3;
    }
    getAttachmentById(t3) {
      for (const e2 of this.getAttachments()) if (e2.id === t3) return e2;
    }
    getAttachmentPieces() {
      let t3 = [];
      return this.blockList.eachObject((e2) => {
        let { text: i2 } = e2;
        return t3 = t3.concat(i2.getAttachmentPieces());
      }), t3;
    }
    getAttachments() {
      return this.getAttachmentPieces().map((t3) => t3.attachment);
    }
    getRangeOfAttachment(t3) {
      let e2 = 0;
      const i2 = this.blockList.toArray();
      for (let n2 = 0; n2 < i2.length; n2++) {
        const { text: r2 } = i2[n2], o2 = r2.getRangeOfAttachment(t3);
        if (o2) return wt([e2 + o2[0], e2 + o2[1]]);
        e2 += r2.getLength();
      }
    }
    getLocationRangeOfAttachment(t3) {
      const e2 = this.getRangeOfAttachment(t3);
      return this.locationRangeFromRange(e2);
    }
    getAttachmentPieceForAttachment(t3) {
      for (const e2 of this.getAttachmentPieces()) if (e2.attachment === t3) return e2;
    }
    findRangesForBlockAttribute(t3) {
      let e2 = 0;
      const i2 = [];
      return this.getBlocks().forEach((n2) => {
        const r2 = n2.getLength();
        n2.hasAttribute(t3) && i2.push([e2, e2 + r2]), e2 += r2;
      }), i2;
    }
    findRangesForTextAttribute(t3) {
      let { withValue: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = 0, n2 = [];
      const r2 = [];
      return this.getPieces().forEach((o2) => {
        const s2 = o2.getLength();
        (function(i3) {
          return e2 ? i3.getAttribute(t3) === e2 : i3.hasAttribute(t3);
        })(o2) && (n2[1] === i2 ? n2[1] = i2 + s2 : r2.push(n2 = [i2, i2 + s2])), i2 += s2;
      }), r2;
    }
    locationFromPosition(t3) {
      const e2 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t3));
      if (null != e2.index) return e2;
      {
        const t4 = this.getBlocks();
        return { index: t4.length - 1, offset: t4[t4.length - 1].getLength() };
      }
    }
    positionFromLocation(t3) {
      return this.blockList.findPositionAtIndexAndOffset(t3.index, t3.offset);
    }
    locationRangeFromPosition(t3) {
      return wt(this.locationFromPosition(t3));
    }
    locationRangeFromRange(t3) {
      if (!(t3 = wt(t3))) return;
      const [e2, i2] = Array.from(t3), n2 = this.locationFromPosition(e2), r2 = this.locationFromPosition(i2);
      return wt([n2, r2]);
    }
    rangeFromLocationRange(t3) {
      let e2;
      t3 = wt(t3);
      const i2 = this.positionFromLocation(t3[0]);
      return Lt(t3) || (e2 = this.positionFromLocation(t3[1])), wt([i2, e2]);
    }
    isEqualTo(t3) {
      return this.blockList.isEqualTo(null == t3 ? void 0 : t3.blockList);
    }
    getTexts() {
      return this.getBlocks().map((t3) => t3.text);
    }
    getPieces() {
      const t3 = [];
      return Array.from(this.getTexts()).forEach((e2) => {
        t3.push(...Array.from(e2.getPieces() || []));
      }), t3;
    }
    getObjects() {
      return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
    }
    toSerializableDocument() {
      const t3 = [];
      return this.blockList.eachObject((e2) => t3.push(e2.copyWithText(e2.text.toSerializableText()))), new this.constructor(t3);
    }
    toString() {
      return this.blockList.toString();
    }
    toJSON() {
      return this.blockList.toJSON();
    }
    toConsole() {
      return JSON.stringify(this.blockList.toArray().map((t3) => JSON.parse(t3.text.toConsole())));
    }
  };
  var ln = function(t3) {
    const e2 = {}, i2 = t3.getLastAttribute();
    return i2 && (e2[i2] = true), e2;
  };
  var cn = function(t3) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return { string: t3 = Wt(t3), attributes: e2, type: "string" };
  };
  var un = (t3, e2) => {
    try {
      return JSON.parse(t3.getAttribute("data-trix-".concat(e2)));
    } catch (t4) {
      return {};
    }
  };
  var hn = class extends q {
    static parse(t3, e2) {
      const i2 = new this(t3, e2);
      return i2.parse(), i2;
    }
    constructor(t3) {
      let { referenceElement: e2, purifyOptions: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.html = t3, this.referenceElement = e2, this.purifyOptions = i2, this.blocks = [], this.blockElements = [], this.processedElements = [];
    }
    getDocument() {
      return an.fromJSON(this.blocks);
    }
    parse() {
      try {
        this.createHiddenContainer(), di.setHTML(this.containerElement, this.html, { purifyOptions: this.purifyOptions });
        const t3 = R(this.containerElement, { usingFilter: pn });
        for (; t3.nextNode(); ) this.processNode(t3.currentNode);
        return this.translateBlockElementMarginsToNewlines();
      } finally {
        this.removeHiddenContainer();
      }
    }
    createHiddenContainer() {
      return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = T({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
    }
    removeHiddenContainer() {
      return S(this.containerElement);
    }
    processNode(t3) {
      switch (t3.nodeType) {
        case Node.TEXT_NODE:
          if (!this.isInsignificantTextNode(t3)) return this.appendBlockForTextNode(t3), this.processTextNode(t3);
          break;
        case Node.ELEMENT_NODE:
          return this.appendBlockForElement(t3), this.processElement(t3);
      }
    }
    appendBlockForTextNode(t3) {
      const e2 = t3.parentNode;
      if (e2 === this.currentBlockElement && this.isBlockElement(t3.previousSibling)) return this.appendStringWithAttributes("\n");
      if (e2 === this.containerElement || this.isBlockElement(e2)) {
        var i2;
        const t4 = this.getBlockAttributes(e2), n2 = this.getBlockHTMLAttributes(e2);
        ot(t4, null === (i2 = this.currentBlock) || void 0 === i2 ? void 0 : i2.attributes) || (this.currentBlock = this.appendBlockForAttributesWithElement(t4, e2, n2), this.currentBlockElement = e2);
      }
    }
    appendBlockForElement(t3) {
      const e2 = this.isBlockElement(t3), i2 = C(this.currentBlockElement, t3);
      if (e2 && !this.isBlockElement(t3.firstChild)) {
        if (!this.isInsignificantTextNode(t3.firstChild) || !this.isBlockElement(t3.firstElementChild)) {
          const e3 = this.getBlockAttributes(t3), n2 = this.getBlockHTMLAttributes(t3);
          if (t3.firstChild) {
            if (i2 && ot(e3, this.currentBlock.attributes)) return this.appendStringWithAttributes("\n");
            this.currentBlock = this.appendBlockForAttributesWithElement(e3, t3, n2), this.currentBlockElement = t3;
          }
        }
      } else if (this.currentBlockElement && !i2 && !e2) {
        const e3 = this.findParentBlockElement(t3);
        if (e3) return this.appendBlockForElement(e3);
        this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null;
      }
    }
    findParentBlockElement(t3) {
      let { parentElement: e2 } = t3;
      for (; e2 && e2 !== this.containerElement; ) {
        if (this.isBlockElement(e2) && this.blockElements.includes(e2)) return e2;
        e2 = e2.parentElement;
      }
      return null;
    }
    processTextNode(t3) {
      let e2 = t3.data;
      var i2;
      dn(t3.parentNode) || (e2 = Vt(e2), vn(null === (i2 = t3.previousSibling) || void 0 === i2 ? void 0 : i2.textContent) && (e2 = fn(e2)));
      return this.appendStringWithAttributes(e2, this.getTextAttributes(t3.parentNode));
    }
    processElement(t3) {
      let e2;
      if (P(t3)) {
        if (e2 = un(t3, "attachment"), Object.keys(e2).length) {
          const i2 = this.getTextAttributes(t3);
          this.appendAttachmentWithAttributes(e2, i2), t3.innerHTML = "";
        }
        return this.processedElements.push(t3);
      }
      switch (k(t3)) {
        case "br":
          return this.isExtraBR(t3) || this.isBlockElement(t3.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t3)), this.processedElements.push(t3);
        case "img":
          e2 = { url: t3.getAttribute("src"), contentType: "image" };
          const i2 = ((t4) => {
            const e3 = t4.getAttribute("width"), i3 = t4.getAttribute("height"), n2 = {};
            return e3 && (n2.width = parseInt(e3, 10)), i3 && (n2.height = parseInt(i3, 10)), n2;
          })(t3);
          for (const t4 in i2) {
            const n2 = i2[t4];
            e2[t4] = n2;
          }
          return this.appendAttachmentWithAttributes(e2, this.getTextAttributes(t3)), this.processedElements.push(t3);
        case "tr":
          if (this.needsTableSeparator(t3)) return this.appendStringWithAttributes(j.tableRowSeparator);
          break;
        case "td":
          if (this.needsTableSeparator(t3)) return this.appendStringWithAttributes(j.tableCellSeparator);
      }
    }
    appendBlockForAttributesWithElement(t3, e2) {
      let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      this.blockElements.push(e2);
      const n2 = function() {
        return { text: [], attributes: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, htmlAttributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {} };
      }(t3, i2);
      return this.blocks.push(n2), n2;
    }
    appendEmptyBlock() {
      return this.appendBlockForAttributesWithElement([], null);
    }
    appendStringWithAttributes(t3, e2) {
      return this.appendPiece(cn(t3, e2));
    }
    appendAttachmentWithAttributes(t3, e2) {
      return this.appendPiece(function(t4) {
        return { attachment: t4, attributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, type: "attachment" };
      }(t3, e2));
    }
    appendPiece(t3) {
      return 0 === this.blocks.length && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t3);
    }
    appendStringToTextAtIndex(t3, e2) {
      const { text: i2 } = this.blocks[e2], n2 = i2[i2.length - 1];
      if ("string" !== (null == n2 ? void 0 : n2.type)) return i2.push(cn(t3));
      n2.string += t3;
    }
    prependStringToTextAtIndex(t3, e2) {
      const { text: i2 } = this.blocks[e2], n2 = i2[0];
      if ("string" !== (null == n2 ? void 0 : n2.type)) return i2.unshift(cn(t3));
      n2.string = t3 + n2.string;
    }
    getTextAttributes(t3) {
      let e2;
      const i2 = {};
      for (const n2 in W) {
        const r2 = W[n2];
        if (r2.tagName && y(t3, { matchingSelector: r2.tagName, untilNode: this.containerElement })) i2[n2] = true;
        else if (r2.parser) {
          if (e2 = r2.parser(t3), e2) {
            let o2 = false;
            for (const i3 of this.findBlockElementAncestors(t3)) if (r2.parser(i3) === e2) {
              o2 = true;
              break;
            }
            o2 || (i2[n2] = e2);
          }
        } else r2.styleProperty && (e2 = t3.style[r2.styleProperty], e2 && (i2[n2] = e2));
      }
      if (P(t3)) {
        const n2 = un(t3, "attributes");
        for (const t4 in n2) e2 = n2[t4], i2[t4] = e2;
      }
      return i2;
    }
    getBlockAttributes(t3) {
      const e2 = [];
      for (; t3 && t3 !== this.containerElement; ) {
        for (const r2 in n) {
          const o2 = n[r2];
          var i2;
          if (false !== o2.parse) {
            if (k(t3) === o2.tagName) (null !== (i2 = o2.test) && void 0 !== i2 && i2.call(o2, t3) || !o2.test) && (e2.push(r2), o2.listAttribute && e2.push(o2.listAttribute));
          }
        }
        t3 = t3.parentNode;
      }
      return e2.reverse();
    }
    getBlockHTMLAttributes(t3) {
      const e2 = {}, i2 = Object.values(n).find((e3) => e3.tagName === k(t3));
      return ((null == i2 ? void 0 : i2.htmlAttributes) || []).forEach((i3) => {
        t3.hasAttribute(i3) && (e2[i3] = t3.getAttribute(i3));
      }), e2;
    }
    findBlockElementAncestors(t3) {
      const e2 = [];
      for (; t3 && t3 !== this.containerElement; ) {
        const i2 = k(t3);
        L().includes(i2) && e2.push(t3), t3 = t3.parentNode;
      }
      return e2;
    }
    isBlockElement(t3) {
      if ((null == t3 ? void 0 : t3.nodeType) === Node.ELEMENT_NODE && !P(t3) && !y(t3, { matchingSelector: "td", untilNode: this.containerElement })) return L().includes(k(t3)) || "block" === window.getComputedStyle(t3).display;
    }
    isInsignificantTextNode(t3) {
      if ((null == t3 ? void 0 : t3.nodeType) !== Node.TEXT_NODE) return;
      if (!bn(t3.data)) return;
      const { parentNode: e2, previousSibling: i2, nextSibling: n2 } = t3;
      return gn(e2.previousSibling) && !this.isBlockElement(e2.previousSibling) || dn(e2) ? void 0 : !i2 || this.isBlockElement(i2) || !n2 || this.isBlockElement(n2);
    }
    isExtraBR(t3) {
      return "br" === k(t3) && this.isBlockElement(t3.parentNode) && t3.parentNode.lastChild === t3;
    }
    needsTableSeparator(t3) {
      if (j.removeBlankTableCells) {
        var e2;
        const i2 = null === (e2 = t3.previousSibling) || void 0 === e2 ? void 0 : e2.textContent;
        return i2 && /\S/.test(i2);
      }
      return t3.previousSibling;
    }
    translateBlockElementMarginsToNewlines() {
      const t3 = this.getMarginOfDefaultBlockElement();
      for (let e2 = 0; e2 < this.blocks.length; e2++) {
        const i2 = this.getMarginOfBlockElementAtIndex(e2);
        i2 && (i2.top > 2 * t3.top && this.prependStringToTextAtIndex("\n", e2), i2.bottom > 2 * t3.bottom && this.appendStringToTextAtIndex("\n", e2));
      }
    }
    getMarginOfBlockElementAtIndex(t3) {
      const e2 = this.blockElements[t3];
      if (e2 && e2.textContent && !L().includes(k(e2)) && !this.processedElements.includes(e2)) return mn(e2);
    }
    getMarginOfDefaultBlockElement() {
      const t3 = T(n.default.tagName);
      return this.containerElement.appendChild(t3), mn(t3);
    }
  };
  var dn = function(t3) {
    const { whiteSpace: e2 } = window.getComputedStyle(t3);
    return ["pre", "pre-wrap", "pre-line"].includes(e2);
  };
  var gn = (t3) => t3 && !vn(t3.textContent);
  var mn = function(t3) {
    const e2 = window.getComputedStyle(t3);
    if ("block" === e2.display) return { top: parseInt(e2.marginTop), bottom: parseInt(e2.marginBottom) };
  };
  var pn = function(t3) {
    return "style" === k(t3) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var fn = (t3) => t3.replace(new RegExp("^".concat(Ut.source, "+")), "");
  var bn = (t3) => new RegExp("^".concat(Ut.source, "*$")).test(t3);
  var vn = (t3) => /\s$/.test(t3);
  var An = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"];
  var yn = "data-trix-serialized-attributes";
  var xn = "[".concat(yn, "]");
  var Cn = new RegExp("<!--block-->", "g");
  var En = { "application/json": function(t3) {
    let e2;
    if (t3 instanceof an) e2 = t3;
    else {
      if (!(t3 instanceof HTMLElement)) throw new Error("unserializable object");
      e2 = hn.parse(t3.innerHTML).getDocument();
    }
    return e2.toSerializableDocument().toJSONString();
  }, "text/html": function(t3) {
    let e2;
    if (t3 instanceof an) e2 = Si.render(t3);
    else {
      if (!(t3 instanceof HTMLElement)) throw new Error("unserializable object");
      e2 = t3.cloneNode(true);
    }
    return Array.from(e2.querySelectorAll("[data-trix-serialize=false]")).forEach((t4) => {
      S(t4);
    }), An.forEach((t4) => {
      Array.from(e2.querySelectorAll("[".concat(t4, "]"))).forEach((e3) => {
        e3.removeAttribute(t4);
      });
    }), Array.from(e2.querySelectorAll(xn)).forEach((t4) => {
      try {
        const e3 = JSON.parse(t4.getAttribute(yn));
        t4.removeAttribute(yn);
        for (const i2 in e3) {
          const n2 = e3[i2];
          t4.setAttribute(i2, n2);
        }
      } catch (t5) {
      }
    }), e2.innerHTML.replace(Cn, "");
  } };
  var Sn = Object.freeze({ __proto__: null });
  var Rn = class extends q {
    constructor(t3, e2) {
      super(...arguments), this.attachmentManager = t3, this.attachment = e2, this.id = this.attachment.id, this.file = this.attachment.file;
    }
    remove() {
      return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
    }
  };
  Rn.proxyMethod("attachment.getAttribute"), Rn.proxyMethod("attachment.hasAttribute"), Rn.proxyMethod("attachment.setAttribute"), Rn.proxyMethod("attachment.getAttributes"), Rn.proxyMethod("attachment.setAttributes"), Rn.proxyMethod("attachment.isPending"), Rn.proxyMethod("attachment.isPreviewable"), Rn.proxyMethod("attachment.getURL"), Rn.proxyMethod("attachment.getHref"), Rn.proxyMethod("attachment.getFilename"), Rn.proxyMethod("attachment.getFilesize"), Rn.proxyMethod("attachment.getFormattedFilesize"), Rn.proxyMethod("attachment.getExtension"), Rn.proxyMethod("attachment.getContentType"), Rn.proxyMethod("attachment.getFile"), Rn.proxyMethod("attachment.setFile"), Rn.proxyMethod("attachment.releaseFile"), Rn.proxyMethod("attachment.getUploadProgress"), Rn.proxyMethod("attachment.setUploadProgress");
  var kn = class extends q {
    constructor() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.managedAttachments = {}, Array.from(t3).forEach((t4) => {
        this.manageAttachment(t4);
      });
    }
    getAttachments() {
      const t3 = [];
      for (const e2 in this.managedAttachments) {
        const i2 = this.managedAttachments[e2];
        t3.push(i2);
      }
      return t3;
    }
    manageAttachment(t3) {
      return this.managedAttachments[t3.id] || (this.managedAttachments[t3.id] = new Rn(this, t3)), this.managedAttachments[t3.id];
    }
    attachmentIsManaged(t3) {
      return t3.id in this.managedAttachments;
    }
    requestRemovalOfAttachment(t3) {
      var e2, i2;
      if (this.attachmentIsManaged(t3)) return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.attachmentManagerDidRequestRemovalOfAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    unmanageAttachment(t3) {
      const e2 = this.managedAttachments[t3.id];
      return delete this.managedAttachments[t3.id], e2;
    }
  };
  var Tn = class {
    constructor(t3) {
      this.composition = t3, this.document = this.composition.document;
      const e2 = this.composition.getSelectedRange();
      this.startPosition = e2[0], this.endPosition = e2[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
    }
    shouldInsertBlockBreak() {
      return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? 0 !== this.startLocation.offset : this.breaksOnReturn && "\n" !== this.nextCharacter;
    }
    shouldBreakFormattedBlock() {
      return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && "\n" === this.nextCharacter || "\n" === this.previousCharacter);
    }
    shouldDecreaseListLevel() {
      return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
    }
    shouldPrependListItem() {
      return this.block.isListItem() && 0 === this.startLocation.offset && !this.block.isEmpty();
    }
    shouldRemoveLastBlockAttribute() {
      return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
    }
  };
  var wn = class extends q {
    constructor() {
      super(...arguments), this.document = new an(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
    }
    setDocument(t3) {
      var e2, i2;
      if (!t3.isEqualTo(this.document)) return this.document = t3, this.refreshAttachments(), this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidChangeDocument) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    getSnapshot() {
      return { document: this.document, selectedRange: this.getSelectedRange() };
    }
    loadSnapshot(t3) {
      var e2, i2, n2, r2;
      let { document: o2, selectedRange: s2 } = t3;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionWillLoadSnapshot) || void 0 === i2 || i2.call(e2), this.setDocument(null != o2 ? o2 : new an()), this.setSelection(null != s2 ? s2 : [0, 0]), null === (n2 = this.delegate) || void 0 === n2 || null === (r2 = n2.compositionDidLoadSnapshot) || void 0 === r2 ? void 0 : r2.call(n2);
    }
    insertText(t3) {
      let { updatePosition: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { updatePosition: true };
      const i2 = this.getSelectedRange();
      this.setDocument(this.document.insertTextAtRange(t3, i2));
      const n2 = i2[0], r2 = n2 + t3.getLength();
      return e2 && this.setSelection(r2), this.notifyDelegateOfInsertionAtRange([n2, r2]);
    }
    insertBlock() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xi();
      const e2 = new an([t3]);
      return this.insertDocument(e2);
    }
    insertDocument() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new an();
      const e2 = this.getSelectedRange();
      this.setDocument(this.document.insertDocumentAtRange(t3, e2));
      const i2 = e2[0], n2 = i2 + t3.getLength();
      return this.setSelection(n2), this.notifyDelegateOfInsertionAtRange([i2, n2]);
    }
    insertString(t3, e2) {
      const i2 = this.getCurrentTextAttributes(), n2 = Yi.textForStringWithAttributes(t3, i2);
      return this.insertText(n2, e2);
    }
    insertBlockBreak() {
      const t3 = this.getSelectedRange();
      this.setDocument(this.document.insertBlockBreakAtRange(t3));
      const e2 = t3[0], i2 = e2 + 1;
      return this.setSelection(i2), this.notifyDelegateOfInsertionAtRange([e2, i2]);
    }
    insertLineBreak() {
      const t3 = new Tn(this);
      if (t3.shouldDecreaseListLevel()) return this.decreaseListLevel(), this.setSelection(t3.startPosition);
      if (t3.shouldPrependListItem()) {
        const e2 = new an([t3.block.copyWithoutText()]);
        return this.insertDocument(e2);
      }
      return t3.shouldInsertBlockBreak() ? this.insertBlockBreak() : t3.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : t3.shouldBreakFormattedBlock() ? this.breakFormattedBlock(t3) : this.insertString("\n");
    }
    insertHTML(t3) {
      const e2 = hn.parse(t3, { purifyOptions: { SAFE_FOR_XML: true } }).getDocument(), i2 = this.getSelectedRange();
      this.setDocument(this.document.mergeDocumentAtRange(e2, i2));
      const n2 = i2[0], r2 = n2 + e2.getLength() - 1;
      return this.setSelection(r2), this.notifyDelegateOfInsertionAtRange([n2, r2]);
    }
    replaceHTML(t3) {
      const e2 = hn.parse(t3).getDocument().copyUsingObjectsFromDocument(this.document), i2 = this.getLocationRange({ strict: false }), n2 = this.document.rangeFromLocationRange(i2);
      return this.setDocument(e2), this.setSelection(n2);
    }
    insertFile(t3) {
      return this.insertFiles([t3]);
    }
    insertFiles(t3) {
      const e2 = [];
      return Array.from(t3).forEach((t4) => {
        var i2;
        if (null !== (i2 = this.delegate) && void 0 !== i2 && i2.compositionShouldAcceptFile(t4)) {
          const i3 = Vi.attachmentForFile(t4);
          e2.push(i3);
        }
      }), this.insertAttachments(e2);
    }
    insertAttachment(t3) {
      return this.insertAttachments([t3]);
    }
    insertAttachments(t3) {
      let e2 = new Yi();
      return Array.from(t3).forEach((t4) => {
        var n2;
        const r2 = t4.getType(), o2 = null === (n2 = i[r2]) || void 0 === n2 ? void 0 : n2.presentation, s2 = this.getCurrentTextAttributes();
        o2 && (s2.presentation = o2);
        const a2 = Yi.textForAttachmentWithAttributes(t4, s2);
        e2 = e2.appendText(a2);
      }), this.insertText(e2);
    }
    shouldManageDeletingInDirection(t3) {
      const e2 = this.getLocationRange();
      if (Lt(e2)) {
        if ("backward" === t3 && 0 === e2[0].offset) return true;
        if (this.shouldManageMovingCursorInDirection(t3)) return true;
      } else if (e2[0].index !== e2[1].index) return true;
      return false;
    }
    deleteInDirection(t3) {
      let e2, i2, n2, { length: r2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const o2 = this.getLocationRange();
      let s2 = this.getSelectedRange();
      const a2 = Lt(s2);
      if (a2 ? i2 = "backward" === t3 && 0 === o2[0].offset : n2 = o2[0].index !== o2[1].index, i2 && this.canDecreaseBlockAttributeLevel()) {
        const t4 = this.getBlock();
        if (t4.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(s2[0]), t4.isEmpty()) return false;
      }
      return a2 && (s2 = this.getExpandedRangeInDirection(t3, { length: r2 }), "backward" === t3 && (e2 = this.getAttachmentAtRange(s2))), e2 ? (this.editAttachment(e2), false) : (this.setDocument(this.document.removeTextAtRange(s2)), this.setSelection(s2[0]), !i2 && !n2 && void 0);
    }
    moveTextFromRange(t3) {
      const [e2] = Array.from(this.getSelectedRange());
      return this.setDocument(this.document.moveTextFromRangeToPosition(t3, e2)), this.setSelection(e2);
    }
    removeAttachment(t3) {
      const e2 = this.document.getRangeOfAttachment(t3);
      if (e2) return this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e2)), this.setSelection(e2[0]);
    }
    removeLastBlockAttribute() {
      const [t3, e2] = Array.from(this.getSelectedRange()), i2 = this.document.getBlockAtPosition(e2);
      return this.removeCurrentAttribute(i2.getLastAttribute()), this.setSelection(t3);
    }
    insertPlaceholder() {
      return this.placeholderPosition = this.getPosition(), this.insertString(" ");
    }
    selectPlaceholder() {
      if (null != this.placeholderPosition) return this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + 1]), this.getSelectedRange();
    }
    forgetPlaceholder() {
      this.placeholderPosition = null;
    }
    hasCurrentAttribute(t3) {
      const e2 = this.currentAttributes[t3];
      return null != e2 && false !== e2;
    }
    toggleCurrentAttribute(t3) {
      const e2 = !this.currentAttributes[t3];
      return e2 ? this.setCurrentAttribute(t3, e2) : this.removeCurrentAttribute(t3);
    }
    canSetCurrentAttribute(t3) {
      return mt(t3) ? this.canSetCurrentBlockAttribute(t3) : this.canSetCurrentTextAttribute(t3);
    }
    canSetCurrentTextAttribute(t3) {
      const e2 = this.getSelectedDocument();
      if (e2) {
        for (const t4 of Array.from(e2.getAttachments())) if (!t4.hasContent()) return false;
        return true;
      }
    }
    canSetCurrentBlockAttribute(t3) {
      const e2 = this.getBlock();
      if (e2) return !e2.isTerminalBlock();
    }
    setCurrentAttribute(t3, e2) {
      return mt(t3) ? this.setBlockAttribute(t3, e2) : (this.setTextAttribute(t3, e2), this.currentAttributes[t3] = e2, this.notifyDelegateOfCurrentAttributesChange());
    }
    setHTMLAtributeAtPosition(t3, e2, i2) {
      var n2;
      const r2 = this.document.getBlockAtPosition(t3), o2 = null === (n2 = mt(r2.getLastAttribute())) || void 0 === n2 ? void 0 : n2.htmlAttributes;
      if (r2 && null != o2 && o2.includes(e2)) {
        const n3 = this.document.setHTMLAttributeAtPosition(t3, e2, i2);
        this.setDocument(n3);
      }
    }
    setTextAttribute(t3, e2) {
      const i2 = this.getSelectedRange();
      if (!i2) return;
      const [n2, r2] = Array.from(i2);
      if (n2 !== r2) return this.setDocument(this.document.addAttributeAtRange(t3, e2, i2));
      if ("href" === t3) {
        const t4 = Yi.textForStringWithAttributes(e2, { href: e2 });
        return this.insertText(t4);
      }
    }
    setBlockAttribute(t3, e2) {
      const i2 = this.getSelectedRange();
      if (this.canSetCurrentAttribute(t3)) return this.setDocument(this.document.applyBlockAttributeAtRange(t3, e2, i2)), this.setSelection(i2);
    }
    removeCurrentAttribute(t3) {
      return mt(t3) ? (this.removeBlockAttribute(t3), this.updateCurrentAttributes()) : (this.removeTextAttribute(t3), delete this.currentAttributes[t3], this.notifyDelegateOfCurrentAttributesChange());
    }
    removeTextAttribute(t3) {
      const e2 = this.getSelectedRange();
      if (e2) return this.setDocument(this.document.removeAttributeAtRange(t3, e2));
    }
    removeBlockAttribute(t3) {
      const e2 = this.getSelectedRange();
      if (e2) return this.setDocument(this.document.removeAttributeAtRange(t3, e2));
    }
    canDecreaseNestingLevel() {
      var t3;
      return (null === (t3 = this.getBlock()) || void 0 === t3 ? void 0 : t3.getNestingLevel()) > 0;
    }
    canIncreaseNestingLevel() {
      var t3;
      const e2 = this.getBlock();
      if (e2) {
        if (null === (t3 = mt(e2.getLastNestableAttribute())) || void 0 === t3 || !t3.listAttribute) return e2.getNestingLevel() > 0;
        {
          const t4 = this.getPreviousBlock();
          if (t4) return function() {
            let t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return ot((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).slice(0, t5.length), t5);
          }(t4.getListItemAttributes(), e2.getListItemAttributes());
        }
      }
    }
    decreaseNestingLevel() {
      const t3 = this.getBlock();
      if (t3) return this.setDocument(this.document.replaceBlock(t3, t3.decreaseNestingLevel()));
    }
    increaseNestingLevel() {
      const t3 = this.getBlock();
      if (t3) return this.setDocument(this.document.replaceBlock(t3, t3.increaseNestingLevel()));
    }
    canDecreaseBlockAttributeLevel() {
      var t3;
      return (null === (t3 = this.getBlock()) || void 0 === t3 ? void 0 : t3.getAttributeLevel()) > 0;
    }
    decreaseBlockAttributeLevel() {
      var t3;
      const e2 = null === (t3 = this.getBlock()) || void 0 === t3 ? void 0 : t3.getLastAttribute();
      if (e2) return this.removeCurrentAttribute(e2);
    }
    decreaseListLevel() {
      let [t3] = Array.from(this.getSelectedRange());
      const { index: e2 } = this.document.locationFromPosition(t3);
      let i2 = e2;
      const n2 = this.getBlock().getAttributeLevel();
      let r2 = this.document.getBlockAtIndex(i2 + 1);
      for (; r2 && r2.isListItem() && !(r2.getAttributeLevel() <= n2); ) i2++, r2 = this.document.getBlockAtIndex(i2 + 1);
      t3 = this.document.positionFromLocation({ index: e2, offset: 0 });
      const o2 = this.document.positionFromLocation({ index: i2, offset: 0 });
      return this.setDocument(this.document.removeLastListAttributeAtRange([t3, o2]));
    }
    updateCurrentAttributes() {
      const t3 = this.getSelectedRange({ ignoreLock: true });
      if (t3) {
        const e2 = this.document.getCommonAttributesAtRange(t3);
        if (Array.from(gt()).forEach((t4) => {
          e2[t4] || this.canSetCurrentAttribute(t4) || (e2[t4] = false);
        }), !Tt(e2, this.currentAttributes)) return this.currentAttributes = e2, this.notifyDelegateOfCurrentAttributesChange();
      }
    }
    getCurrentAttributes() {
      return m.call({}, this.currentAttributes);
    }
    getCurrentTextAttributes() {
      const t3 = {};
      for (const e2 in this.currentAttributes) {
        const i2 = this.currentAttributes[e2];
        false !== i2 && ft(e2) && (t3[e2] = i2);
      }
      return t3;
    }
    freezeSelection() {
      return this.setCurrentAttribute("frozen", true);
    }
    thawSelection() {
      return this.removeCurrentAttribute("frozen");
    }
    hasFrozenSelection() {
      return this.hasCurrentAttribute("frozen");
    }
    setSelection(t3) {
      var e2;
      const i2 = this.document.locationRangeFromRange(t3);
      return null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.compositionDidRequestChangingSelectionToLocationRange(i2);
    }
    getSelectedRange() {
      const t3 = this.getLocationRange();
      if (t3) return this.document.rangeFromLocationRange(t3);
    }
    setSelectedRange(t3) {
      const e2 = this.document.locationRangeFromRange(t3);
      return this.getSelectionManager().setLocationRange(e2);
    }
    getPosition() {
      const t3 = this.getLocationRange();
      if (t3) return this.document.positionFromLocation(t3[0]);
    }
    getLocationRange(t3) {
      return this.targetLocationRange ? this.targetLocationRange : this.getSelectionManager().getLocationRange(t3) || wt({ index: 0, offset: 0 });
    }
    withTargetLocationRange(t3, e2) {
      let i2;
      this.targetLocationRange = t3;
      try {
        i2 = e2();
      } finally {
        this.targetLocationRange = null;
      }
      return i2;
    }
    withTargetRange(t3, e2) {
      const i2 = this.document.locationRangeFromRange(t3);
      return this.withTargetLocationRange(i2, e2);
    }
    withTargetDOMRange(t3, e2) {
      const i2 = this.createLocationRangeFromDOMRange(t3, { strict: false });
      return this.withTargetLocationRange(i2, e2);
    }
    getExpandedRangeInDirection(t3) {
      let { length: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, [i2, n2] = Array.from(this.getSelectedRange());
      return "backward" === t3 ? e2 ? i2 -= e2 : i2 = this.translateUTF16PositionFromOffset(i2, -1) : e2 ? n2 += e2 : n2 = this.translateUTF16PositionFromOffset(n2, 1), wt([i2, n2]);
    }
    shouldManageMovingCursorInDirection(t3) {
      if (this.editingAttachment) return true;
      const e2 = this.getExpandedRangeInDirection(t3);
      return null != this.getAttachmentAtRange(e2);
    }
    moveCursorInDirection(t3) {
      let e2, i2;
      if (this.editingAttachment) i2 = this.document.getRangeOfAttachment(this.editingAttachment);
      else {
        const n2 = this.getSelectedRange();
        i2 = this.getExpandedRangeInDirection(t3), e2 = !Dt(n2, i2);
      }
      if ("backward" === t3 ? this.setSelectedRange(i2[0]) : this.setSelectedRange(i2[1]), e2) {
        const t4 = this.getAttachmentAtRange(i2);
        if (t4) return this.editAttachment(t4);
      }
    }
    expandSelectionInDirection(t3) {
      let { length: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const i2 = this.getExpandedRangeInDirection(t3, { length: e2 });
      return this.setSelectedRange(i2);
    }
    expandSelectionForEditing() {
      if (this.hasCurrentAttribute("href")) return this.expandSelectionAroundCommonAttribute("href");
    }
    expandSelectionAroundCommonAttribute(t3) {
      const e2 = this.getPosition(), i2 = this.document.getRangeOfCommonAttributeAtPosition(t3, e2);
      return this.setSelectedRange(i2);
    }
    selectionContainsAttachments() {
      var t3;
      return (null === (t3 = this.getSelectedAttachments()) || void 0 === t3 ? void 0 : t3.length) > 0;
    }
    selectionIsInCursorTarget() {
      return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
    }
    positionIsCursorTarget(t3) {
      const e2 = this.document.locationFromPosition(t3);
      if (e2) return this.locationIsCursorTarget(e2);
    }
    positionIsBlockBreak(t3) {
      var e2;
      return null === (e2 = this.document.getPieceAtPosition(t3)) || void 0 === e2 ? void 0 : e2.isBlockBreak();
    }
    getSelectedDocument() {
      const t3 = this.getSelectedRange();
      if (t3) return this.document.getDocumentAtRange(t3);
    }
    getSelectedAttachments() {
      var t3;
      return null === (t3 = this.getSelectedDocument()) || void 0 === t3 ? void 0 : t3.getAttachments();
    }
    getAttachments() {
      return this.attachments.slice(0);
    }
    refreshAttachments() {
      const t3 = this.document.getAttachments(), { added: e2, removed: i2 } = function() {
        let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
        const i3 = [], n2 = [], r2 = /* @__PURE__ */ new Set();
        t4.forEach((t5) => {
          r2.add(t5);
        });
        const o2 = /* @__PURE__ */ new Set();
        return e3.forEach((t5) => {
          o2.add(t5), r2.has(t5) || i3.push(t5);
        }), t4.forEach((t5) => {
          o2.has(t5) || n2.push(t5);
        }), { added: i3, removed: n2 };
      }(this.attachments, t3);
      return this.attachments = t3, Array.from(i2).forEach((t4) => {
        var e3, i3;
        t4.delegate = null, null === (e3 = this.delegate) || void 0 === e3 || null === (i3 = e3.compositionDidRemoveAttachment) || void 0 === i3 || i3.call(e3, t4);
      }), (() => {
        const t4 = [];
        return Array.from(e2).forEach((e3) => {
          var i3, n2;
          e3.delegate = this, t4.push(null === (i3 = this.delegate) || void 0 === i3 || null === (n2 = i3.compositionDidAddAttachment) || void 0 === n2 ? void 0 : n2.call(i3, e3));
        }), t4;
      })();
    }
    attachmentDidChangeAttributes(t3) {
      var e2, i2;
      return this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidEditAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    attachmentDidChangePreviewURL(t3) {
      var e2, i2;
      return this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidChangeAttachmentPreviewURL) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    editAttachment(t3, e2) {
      var i2, n2;
      if (t3 !== this.editingAttachment) return this.stopEditingAttachment(), this.editingAttachment = t3, null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionDidStartEditingAttachment) || void 0 === n2 ? void 0 : n2.call(i2, this.editingAttachment, e2);
    }
    stopEditingAttachment() {
      var t3, e2;
      this.editingAttachment && (null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.compositionDidStopEditingAttachment) || void 0 === e2 || e2.call(t3, this.editingAttachment), this.editingAttachment = null);
    }
    updateAttributesForAttachment(t3, e2) {
      return this.setDocument(this.document.updateAttributesForAttachment(t3, e2));
    }
    removeAttributeForAttachment(t3, e2) {
      return this.setDocument(this.document.removeAttributeForAttachment(t3, e2));
    }
    breakFormattedBlock(t3) {
      let { document: e2 } = t3;
      const { block: i2 } = t3;
      let n2 = t3.startPosition, r2 = [n2 - 1, n2];
      i2.getBlockBreakPosition() === t3.startLocation.offset ? (i2.breaksOnReturn() && "\n" === t3.nextCharacter ? n2 += 1 : e2 = e2.removeTextAtRange(r2), r2 = [n2, n2]) : "\n" === t3.nextCharacter ? "\n" === t3.previousCharacter ? r2 = [n2 - 1, n2 + 1] : (r2 = [n2, n2 + 1], n2 += 1) : t3.startLocation.offset - 1 != 0 && (n2 += 1);
      const o2 = new an([i2.removeLastAttribute().copyWithoutText()]);
      return this.setDocument(e2.insertDocumentAtRange(o2, r2)), this.setSelection(n2);
    }
    getPreviousBlock() {
      const t3 = this.getLocationRange();
      if (t3) {
        const { index: e2 } = t3[0];
        if (e2 > 0) return this.document.getBlockAtIndex(e2 - 1);
      }
    }
    getBlock() {
      const t3 = this.getLocationRange();
      if (t3) return this.document.getBlockAtIndex(t3[0].index);
    }
    getAttachmentAtRange(t3) {
      const e2 = this.document.getDocumentAtRange(t3);
      if (e2.toString() === "".concat("\uFFFC", "\n")) return e2.getAttachments()[0];
    }
    notifyDelegateOfCurrentAttributesChange() {
      var t3, e2;
      return null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.compositionDidChangeCurrentAttributes) || void 0 === e2 ? void 0 : e2.call(t3, this.currentAttributes);
    }
    notifyDelegateOfInsertionAtRange(t3) {
      var e2, i2;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionDidPerformInsertionAtRange) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    translateUTF16PositionFromOffset(t3, e2) {
      const i2 = this.document.toUTF16String(), n2 = i2.offsetFromUCS2Offset(t3);
      return i2.offsetToUCS2Offset(n2 + e2);
    }
  };
  wn.proxyMethod("getSelectionManager().getPointRange"), wn.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), wn.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), wn.proxyMethod("getSelectionManager().locationIsCursorTarget"), wn.proxyMethod("getSelectionManager().selectionIsExpanded"), wn.proxyMethod("delegate?.getSelectionManager");
  var Ln = class extends q {
    constructor(t3) {
      super(...arguments), this.composition = t3, this.undoEntries = [], this.redoEntries = [];
    }
    recordUndoEntry(t3) {
      let { context: e2, consolidatable: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const n2 = this.undoEntries.slice(-1)[0];
      if (!i2 || !Dn(n2, t3, e2)) {
        const i3 = this.createEntry({ description: t3, context: e2 });
        this.undoEntries.push(i3), this.redoEntries = [];
      }
    }
    undo() {
      const t3 = this.undoEntries.pop();
      if (t3) {
        const e2 = this.createEntry(t3);
        return this.redoEntries.push(e2), this.composition.loadSnapshot(t3.snapshot);
      }
    }
    redo() {
      const t3 = this.redoEntries.pop();
      if (t3) {
        const e2 = this.createEntry(t3);
        return this.undoEntries.push(e2), this.composition.loadSnapshot(t3.snapshot);
      }
    }
    canUndo() {
      return this.undoEntries.length > 0;
    }
    canRedo() {
      return this.redoEntries.length > 0;
    }
    createEntry() {
      let { description: t3, context: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return { description: null == t3 ? void 0 : t3.toString(), context: JSON.stringify(e2), snapshot: this.composition.getSnapshot() };
    }
  };
  var Dn = (t3, e2, i2) => (null == t3 ? void 0 : t3.description) === (null == e2 ? void 0 : e2.toString()) && (null == t3 ? void 0 : t3.context) === JSON.stringify(i2);
  var Nn = "attachmentGallery";
  var In = class {
    constructor(t3) {
      this.document = t3.document, this.selectedRange = t3.selectedRange;
    }
    perform() {
      return this.removeBlockAttribute(), this.applyBlockAttribute();
    }
    getSnapshot() {
      return { document: this.document, selectedRange: this.selectedRange };
    }
    removeBlockAttribute() {
      return this.findRangesOfBlocks().map((t3) => this.document = this.document.removeAttributeAtRange(Nn, t3));
    }
    applyBlockAttribute() {
      let t3 = 0;
      this.findRangesOfPieces().forEach((e2) => {
        e2[1] - e2[0] > 1 && (e2[0] += t3, e2[1] += t3, "\n" !== this.document.getCharacterAtPosition(e2[1]) && (this.document = this.document.insertBlockBreakAtRange(e2[1]), e2[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), e2[1]++, t3++), 0 !== e2[0] && "\n" !== this.document.getCharacterAtPosition(e2[0] - 1) && (this.document = this.document.insertBlockBreakAtRange(e2[0]), e2[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), e2[0]++, t3++), this.document = this.document.applyBlockAttributeAtRange(Nn, true, e2));
      });
    }
    findRangesOfBlocks() {
      return this.document.findRangesForBlockAttribute(Nn);
    }
    findRangesOfPieces() {
      return this.document.findRangesForTextAttribute("presentation", { withValue: "gallery" });
    }
    moveSelectedRangeForward() {
      this.selectedRange[0] += 1, this.selectedRange[1] += 1;
    }
  };
  var On = function(t3) {
    const e2 = new In(t3);
    return e2.perform(), e2.getSnapshot();
  };
  var Fn = [On];
  var Pn = class {
    constructor(t3, e2, i2) {
      this.insertFiles = this.insertFiles.bind(this), this.composition = t3, this.selectionManager = e2, this.element = i2, this.undoManager = new Ln(this.composition), this.filters = Fn.slice(0);
    }
    loadDocument(t3) {
      return this.loadSnapshot({ document: t3, selectedRange: [0, 0] });
    }
    loadHTML() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      const e2 = hn.parse(t3, { referenceElement: this.element }).getDocument();
      return this.loadDocument(e2);
    }
    loadJSON(t3) {
      let { document: e2, selectedRange: i2 } = t3;
      return e2 = an.fromJSON(e2), this.loadSnapshot({ document: e2, selectedRange: i2 });
    }
    loadSnapshot(t3) {
      return this.undoManager = new Ln(this.composition), this.composition.loadSnapshot(t3);
    }
    getDocument() {
      return this.composition.document;
    }
    getSelectedDocument() {
      return this.composition.getSelectedDocument();
    }
    getSnapshot() {
      return this.composition.getSnapshot();
    }
    toJSON() {
      return this.getSnapshot();
    }
    deleteInDirection(t3) {
      return this.composition.deleteInDirection(t3);
    }
    insertAttachment(t3) {
      return this.composition.insertAttachment(t3);
    }
    insertAttachments(t3) {
      return this.composition.insertAttachments(t3);
    }
    insertDocument(t3) {
      return this.composition.insertDocument(t3);
    }
    insertFile(t3) {
      return this.composition.insertFile(t3);
    }
    insertFiles(t3) {
      return this.composition.insertFiles(t3);
    }
    insertHTML(t3) {
      return this.composition.insertHTML(t3);
    }
    insertString(t3) {
      return this.composition.insertString(t3);
    }
    insertText(t3) {
      return this.composition.insertText(t3);
    }
    insertLineBreak() {
      return this.composition.insertLineBreak();
    }
    getSelectedRange() {
      return this.composition.getSelectedRange();
    }
    getPosition() {
      return this.composition.getPosition();
    }
    getClientRectAtPosition(t3) {
      const e2 = this.getDocument().locationRangeFromRange([t3, t3 + 1]);
      return this.selectionManager.getClientRectAtLocationRange(e2);
    }
    expandSelectionInDirection(t3) {
      return this.composition.expandSelectionInDirection(t3);
    }
    moveCursorInDirection(t3) {
      return this.composition.moveCursorInDirection(t3);
    }
    setSelectedRange(t3) {
      return this.composition.setSelectedRange(t3);
    }
    activateAttribute(t3) {
      let e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return this.composition.setCurrentAttribute(t3, e2);
    }
    attributeIsActive(t3) {
      return this.composition.hasCurrentAttribute(t3);
    }
    canActivateAttribute(t3) {
      return this.composition.canSetCurrentAttribute(t3);
    }
    deactivateAttribute(t3) {
      return this.composition.removeCurrentAttribute(t3);
    }
    setHTMLAtributeAtPosition(t3, e2, i2) {
      this.composition.setHTMLAtributeAtPosition(t3, e2, i2);
    }
    canDecreaseNestingLevel() {
      return this.composition.canDecreaseNestingLevel();
    }
    canIncreaseNestingLevel() {
      return this.composition.canIncreaseNestingLevel();
    }
    decreaseNestingLevel() {
      if (this.canDecreaseNestingLevel()) return this.composition.decreaseNestingLevel();
    }
    increaseNestingLevel() {
      if (this.canIncreaseNestingLevel()) return this.composition.increaseNestingLevel();
    }
    canRedo() {
      return this.undoManager.canRedo();
    }
    canUndo() {
      return this.undoManager.canUndo();
    }
    recordUndoEntry(t3) {
      let { context: e2, consolidatable: i2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return this.undoManager.recordUndoEntry(t3, { context: e2, consolidatable: i2 });
    }
    redo() {
      if (this.canRedo()) return this.undoManager.redo();
    }
    undo() {
      if (this.canUndo()) return this.undoManager.undo();
    }
  };
  var Mn = class {
    constructor(t3) {
      this.element = t3;
    }
    findLocationFromContainerAndOffset(t3, e2) {
      let { strict: i2 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { strict: true }, n2 = 0, r2 = false;
      const o2 = { index: 0, offset: 0 }, s2 = this.findAttachmentElementParentForNode(t3);
      s2 && (t3 = s2.parentNode, e2 = E(s2));
      const a2 = R(this.element, { usingFilter: Wn });
      for (; a2.nextNode(); ) {
        const s3 = a2.currentNode;
        if (s3 === t3 && B(t3)) {
          F(s3) || (o2.offset += e2);
          break;
        }
        if (s3.parentNode === t3) {
          if (n2++ === e2) break;
        } else if (!C(t3, s3) && n2 > 0) break;
        N(s3, { strict: i2 }) ? (r2 && o2.index++, o2.offset = 0, r2 = true) : o2.offset += Bn(s3);
      }
      return o2;
    }
    findContainerAndOffsetFromLocation(t3) {
      let e2, i2;
      if (0 === t3.index && 0 === t3.offset) {
        for (e2 = this.element, i2 = 0; e2.firstChild; ) if (e2 = e2.firstChild, D(e2)) {
          i2 = 1;
          break;
        }
        return [e2, i2];
      }
      let [n2, r2] = this.findNodeAndOffsetFromLocation(t3);
      if (n2) {
        if (B(n2)) 0 === Bn(n2) ? (e2 = n2.parentNode.parentNode, i2 = E(n2.parentNode), F(n2, { name: "right" }) && i2++) : (e2 = n2, i2 = t3.offset - r2);
        else {
          if (e2 = n2.parentNode, !N(n2.previousSibling) && !D(e2)) for (; n2 === e2.lastChild && (n2 = e2, e2 = e2.parentNode, !D(e2)); ) ;
          i2 = E(n2), 0 !== t3.offset && i2++;
        }
        return [e2, i2];
      }
    }
    findNodeAndOffsetFromLocation(t3) {
      let e2, i2, n2 = 0;
      for (const r2 of this.getSignificantNodesForIndex(t3.index)) {
        const o2 = Bn(r2);
        if (t3.offset <= n2 + o2) if (B(r2)) {
          if (e2 = r2, i2 = n2, t3.offset === i2 && F(e2)) break;
        } else e2 || (e2 = r2, i2 = n2);
        if (n2 += o2, n2 > t3.offset) break;
      }
      return [e2, i2];
    }
    findAttachmentElementParentForNode(t3) {
      for (; t3 && t3 !== this.element; ) {
        if (P(t3)) return t3;
        t3 = t3.parentNode;
      }
    }
    getSignificantNodesForIndex(t3) {
      const e2 = [], i2 = R(this.element, { usingFilter: _n });
      let n2 = false;
      for (; i2.nextNode(); ) {
        const o2 = i2.currentNode;
        var r2;
        if (I(o2)) {
          if (null != r2 ? r2++ : r2 = 0, r2 === t3) n2 = true;
          else if (n2) break;
        } else n2 && e2.push(o2);
      }
      return e2;
    }
  };
  var Bn = function(t3) {
    if (t3.nodeType === Node.TEXT_NODE) {
      if (F(t3)) return 0;
      return t3.textContent.length;
    }
    return "br" === k(t3) || P(t3) ? 1 : 0;
  };
  var _n = function(t3) {
    return jn(t3) === NodeFilter.FILTER_ACCEPT ? Wn(t3) : NodeFilter.FILTER_REJECT;
  };
  var jn = function(t3) {
    return M(t3) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var Wn = function(t3) {
    return P(t3.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var Un = class {
    createDOMRangeFromPoint(t3) {
      let e2, { x: i2, y: n2 } = t3;
      if (document.caretPositionFromPoint) {
        const { offsetNode: t4, offset: r2 } = document.caretPositionFromPoint(i2, n2);
        return e2 = document.createRange(), e2.setStart(t4, r2), e2;
      }
      if (document.caretRangeFromPoint) return document.caretRangeFromPoint(i2, n2);
      if (document.body.createTextRange) {
        const t4 = Mt();
        try {
          const t5 = document.body.createTextRange();
          t5.moveToPoint(i2, n2), t5.select();
        } catch (t5) {
        }
        return e2 = Mt(), Bt(t4), e2;
      }
    }
    getClientRectsForDOMRange(t3) {
      const e2 = Array.from(t3.getClientRects());
      return [e2[0], e2[e2.length - 1]];
    }
  };
  var Vn = class extends q {
    constructor(t3) {
      super(...arguments), this.didMouseDown = this.didMouseDown.bind(this), this.selectionDidChange = this.selectionDidChange.bind(this), this.element = t3, this.locationMapper = new Mn(this.element), this.pointMapper = new Un(), this.lockCount = 0, b("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
    }
    getLocationRange() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return false === t3.strict ? this.createLocationRangeFromDOMRange(Mt()) : t3.ignoreLock ? this.currentLocationRange : this.lockedLocationRange ? this.lockedLocationRange : this.currentLocationRange;
    }
    setLocationRange(t3) {
      if (this.lockedLocationRange) return;
      t3 = wt(t3);
      const e2 = this.createDOMRangeFromLocationRange(t3);
      e2 && (Bt(e2), this.updateCurrentLocationRange(t3));
    }
    setLocationRangeFromPointRange(t3) {
      t3 = wt(t3);
      const e2 = this.getLocationAtPoint(t3[0]), i2 = this.getLocationAtPoint(t3[1]);
      this.setLocationRange([e2, i2]);
    }
    getClientRectAtLocationRange(t3) {
      const e2 = this.createDOMRangeFromLocationRange(t3);
      if (e2) return this.getClientRectsForDOMRange(e2)[1];
    }
    locationIsCursorTarget(t3) {
      const e2 = Array.from(this.findNodeAndOffsetFromLocation(t3))[0];
      return F(e2);
    }
    lock() {
      0 == this.lockCount++ && (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange());
    }
    unlock() {
      if (0 == --this.lockCount) {
        const { lockedLocationRange: t3 } = this;
        if (this.lockedLocationRange = null, null != t3) return this.setLocationRange(t3);
      }
    }
    clearSelection() {
      var t3;
      return null === (t3 = Pt()) || void 0 === t3 ? void 0 : t3.removeAllRanges();
    }
    selectionIsCollapsed() {
      var t3;
      return true === (null === (t3 = Mt()) || void 0 === t3 ? void 0 : t3.collapsed);
    }
    selectionIsExpanded() {
      return !this.selectionIsCollapsed();
    }
    createLocationRangeFromDOMRange(t3, e2) {
      if (null == t3 || !this.domRangeWithinElement(t3)) return;
      const i2 = this.findLocationFromContainerAndOffset(t3.startContainer, t3.startOffset, e2);
      if (!i2) return;
      const n2 = t3.collapsed ? void 0 : this.findLocationFromContainerAndOffset(t3.endContainer, t3.endOffset, e2);
      return wt([i2, n2]);
    }
    didMouseDown() {
      return this.pauseTemporarily();
    }
    pauseTemporarily() {
      let t3;
      this.paused = true;
      const e2 = () => {
        if (this.paused = false, clearTimeout(i2), Array.from(t3).forEach((t4) => {
          t4.destroy();
        }), C(document, this.element)) return this.selectionDidChange();
      }, i2 = setTimeout(e2, 200);
      t3 = ["mousemove", "keydown"].map((t4) => b(t4, { onElement: document, withCallback: e2 }));
    }
    selectionDidChange() {
      if (!this.paused && !x(this.element)) return this.updateCurrentLocationRange();
    }
    updateCurrentLocationRange(t3) {
      var e2, i2;
      if ((null != t3 ? t3 : t3 = this.createLocationRangeFromDOMRange(Mt())) && !Dt(t3, this.currentLocationRange)) return this.currentLocationRange = t3, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.locationRangeDidChange) || void 0 === i2 ? void 0 : i2.call(e2, this.currentLocationRange.slice(0));
    }
    createDOMRangeFromLocationRange(t3) {
      const e2 = this.findContainerAndOffsetFromLocation(t3[0]), i2 = Lt(t3) ? e2 : this.findContainerAndOffsetFromLocation(t3[1]) || e2;
      if (null != e2 && null != i2) {
        const t4 = document.createRange();
        return t4.setStart(...Array.from(e2 || [])), t4.setEnd(...Array.from(i2 || [])), t4;
      }
    }
    getLocationAtPoint(t3) {
      const e2 = this.createDOMRangeFromPoint(t3);
      var i2;
      if (e2) return null === (i2 = this.createLocationRangeFromDOMRange(e2)) || void 0 === i2 ? void 0 : i2[0];
    }
    domRangeWithinElement(t3) {
      return t3.collapsed ? C(this.element, t3.startContainer) : C(this.element, t3.startContainer) && C(this.element, t3.endContainer);
    }
  };
  Vn.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), Vn.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), Vn.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), Vn.proxyMethod("pointMapper.createDOMRangeFromPoint"), Vn.proxyMethod("pointMapper.getClientRectsForDOMRange");
  var zn = Object.freeze({ __proto__: null, Attachment: Vi, AttachmentManager: kn, AttachmentPiece: zi, Block: Xi, Composition: wn, Document: an, Editor: Pn, HTMLParser: hn, HTMLSanitizer: di, LineBreakInsertion: Tn, LocationMapper: Mn, ManagedAttachment: Rn, Piece: Wi, PointMapper: Un, SelectionManager: Vn, SplittableList: Hi, StringPiece: qi, Text: Yi, UndoManager: Ln });
  var qn = Object.freeze({ __proto__: null, ObjectView: ie, AttachmentView: pi, BlockView: Ei, DocumentView: Si, PieceView: Ai, PreviewableAttachmentView: vi, TextView: yi });
  var { lang: Hn, css: Jn, keyNames: Kn } = z;
  var Gn = function(t3) {
    return function() {
      const e2 = t3.apply(this, arguments);
      e2.do(), this.undos || (this.undos = []), this.undos.push(e2.undo);
    };
  };
  var Yn = class extends q {
    constructor(t3, e2, i2) {
      let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
      super(...arguments), Di(this, "makeElementMutable", Gn(() => ({ do: () => {
        this.element.dataset.trixMutable = true;
      }, undo: () => delete this.element.dataset.trixMutable }))), Di(this, "addToolbar", Gn(() => {
        const t4 = T({ tagName: "div", className: Jn.attachmentToolbar, data: { trixMutable: true }, childNodes: T({ tagName: "div", className: "trix-button-row", childNodes: T({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: T({ tagName: "button", className: "trix-button trix-button--remove", textContent: Hn.remove, attributes: { title: Hn.remove }, data: { trixAction: "remove" } }) }) }) });
        return this.attachment.isPreviewable() && t4.appendChild(T({ tagName: "div", className: Jn.attachmentMetadataContainer, childNodes: T({ tagName: "span", className: Jn.attachmentMetadata, childNodes: [T({ tagName: "span", className: Jn.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), T({ tagName: "span", className: Jn.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), b("click", { onElement: t4, withCallback: this.didClickToolbar }), b("click", { onElement: t4, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), v("trix-attachment-before-toolbar", { onElement: this.element, attributes: { toolbar: t4, attachment: this.attachment } }), { do: () => this.element.appendChild(t4), undo: () => S(t4) };
      })), Di(this, "installCaptionEditor", Gn(() => {
        const t4 = T({ tagName: "textarea", className: Jn.attachmentCaptionEditor, attributes: { placeholder: Hn.captionPlaceholder }, data: { trixMutable: true } });
        t4.value = this.attachmentPiece.getCaption();
        const e3 = t4.cloneNode();
        e3.classList.add("trix-autoresize-clone"), e3.tabIndex = -1;
        const i3 = function() {
          e3.value = t4.value, t4.style.height = e3.scrollHeight + "px";
        };
        b("input", { onElement: t4, withCallback: i3 }), b("input", { onElement: t4, withCallback: this.didInputCaption }), b("keydown", { onElement: t4, withCallback: this.didKeyDownCaption }), b("change", { onElement: t4, withCallback: this.didChangeCaption }), b("blur", { onElement: t4, withCallback: this.didBlurCaption });
        const n3 = this.element.querySelector("figcaption"), r2 = n3.cloneNode();
        return { do: () => {
          if (n3.style.display = "none", r2.appendChild(t4), r2.appendChild(e3), r2.classList.add("".concat(Jn.attachmentCaption, "--editing")), n3.parentElement.insertBefore(r2, n3), i3(), this.options.editCaption) return Rt(() => t4.focus());
        }, undo() {
          S(r2), n3.style.display = null;
        } };
      })), this.didClickToolbar = this.didClickToolbar.bind(this), this.didClickActionButton = this.didClickActionButton.bind(this), this.didKeyDownCaption = this.didKeyDownCaption.bind(this), this.didInputCaption = this.didInputCaption.bind(this), this.didChangeCaption = this.didChangeCaption.bind(this), this.didBlurCaption = this.didBlurCaption.bind(this), this.attachmentPiece = t3, this.element = e2, this.container = i2, this.options = n2, this.attachment = this.attachmentPiece.attachment, "a" === k(this.element) && (this.element = this.element.firstChild), this.install();
    }
    install() {
      this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() && this.installCaptionEditor();
    }
    uninstall() {
      var t3;
      let e2 = this.undos.pop();
      for (this.savePendingCaption(); e2; ) e2(), e2 = this.undos.pop();
      null === (t3 = this.delegate) || void 0 === t3 || t3.didUninstallAttachmentEditor(this);
    }
    savePendingCaption() {
      if (null != this.pendingCaption) {
        const r2 = this.pendingCaption;
        var t3, e2, i2, n2;
        if (this.pendingCaption = null, r2) null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.attachmentEditorDidRequestUpdatingAttributesForAttachment) || void 0 === e2 || e2.call(t3, { caption: r2 }, this.attachment);
        else null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.attachmentEditorDidRequestRemovingAttributeForAttachment) || void 0 === n2 || n2.call(i2, "caption", this.attachment);
      }
    }
    didClickToolbar(t3) {
      return t3.preventDefault(), t3.stopPropagation();
    }
    didClickActionButton(t3) {
      var e2;
      if ("remove" === t3.target.getAttribute("data-trix-action")) return null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.attachmentEditorDidRequestRemovalOfAttachment(this.attachment);
    }
    didKeyDownCaption(t3) {
      var e2, i2;
      if ("return" === Kn[t3.keyCode]) return t3.preventDefault(), this.savePendingCaption(), null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.attachmentEditorDidRequestDeselectingAttachment) || void 0 === i2 ? void 0 : i2.call(e2, this.attachment);
    }
    didInputCaption(t3) {
      this.pendingCaption = t3.target.value.replace(/\s/g, " ").trim();
    }
    didChangeCaption(t3) {
      return this.savePendingCaption();
    }
    didBlurCaption(t3) {
      return this.savePendingCaption();
    }
  };
  var Xn = class extends q {
    constructor(t3, i2) {
      super(...arguments), this.didFocus = this.didFocus.bind(this), this.didBlur = this.didBlur.bind(this), this.didClickAttachment = this.didClickAttachment.bind(this), this.element = t3, this.composition = i2, this.documentView = new Si(this.composition.document, { element: this.element }), b("focus", { onElement: this.element, withCallback: this.didFocus }), b("blur", { onElement: this.element, withCallback: this.didBlur }), b("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), b("mousedown", { onElement: this.element, matchingSelector: e, withCallback: this.didClickAttachment }), b("click", { onElement: this.element, matchingSelector: "a".concat(e), preventDefault: true });
    }
    didFocus(t3) {
      var e2;
      const i2 = () => {
        var t4, e3;
        if (!this.focused) return this.focused = true, null === (t4 = this.delegate) || void 0 === t4 || null === (e3 = t4.compositionControllerDidFocus) || void 0 === e3 ? void 0 : e3.call(t4);
      };
      return (null === (e2 = this.blurPromise) || void 0 === e2 ? void 0 : e2.then(i2)) || i2();
    }
    didBlur(t3) {
      this.blurPromise = new Promise((t4) => Rt(() => {
        var e2, i2;
        x(this.element) || (this.focused = null, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionControllerDidBlur) || void 0 === i2 || i2.call(e2));
        return this.blurPromise = null, t4();
      }));
    }
    didClickAttachment(t3, e2) {
      var i2, n2;
      const r2 = this.findAttachmentForElement(e2), o2 = !!y(t3.target, { matchingSelector: "figcaption" });
      return null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerDidSelectAttachment) || void 0 === n2 ? void 0 : n2.call(i2, r2, { editCaption: o2 });
    }
    getSerializableElement() {
      return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
    }
    render() {
      var t3, e2, i2, n2, r2, o2;
      (this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced()) && (null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerWillSyncDocumentView) || void 0 === n2 || n2.call(i2), this.documentView.sync(), null === (r2 = this.delegate) || void 0 === r2 || null === (o2 = r2.compositionControllerDidSyncDocumentView) || void 0 === o2 || o2.call(r2));
      return null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.compositionControllerDidRender) || void 0 === e2 ? void 0 : e2.call(t3);
    }
    rerenderViewForObject(t3) {
      return this.invalidateViewForObject(t3), this.render();
    }
    invalidateViewForObject(t3) {
      return this.documentView.invalidateViewForObject(t3);
    }
    isViewCachingEnabled() {
      return this.documentView.isViewCachingEnabled();
    }
    enableViewCaching() {
      return this.documentView.enableViewCaching();
    }
    disableViewCaching() {
      return this.documentView.disableViewCaching();
    }
    refreshViewCache() {
      return this.documentView.garbageCollectCachedViews();
    }
    isEditingAttachment() {
      return !!this.attachmentEditor;
    }
    installAttachmentEditorForAttachment(t3, e2) {
      var i2;
      if ((null === (i2 = this.attachmentEditor) || void 0 === i2 ? void 0 : i2.attachment) === t3) return;
      const n2 = this.documentView.findElementForObject(t3);
      if (!n2) return;
      this.uninstallAttachmentEditor();
      const r2 = this.composition.document.getAttachmentPieceForAttachment(t3);
      this.attachmentEditor = new Yn(r2, n2, this.element, e2), this.attachmentEditor.delegate = this;
    }
    uninstallAttachmentEditor() {
      var t3;
      return null === (t3 = this.attachmentEditor) || void 0 === t3 ? void 0 : t3.uninstall();
    }
    didUninstallAttachmentEditor() {
      return this.attachmentEditor = null, this.render();
    }
    attachmentEditorDidRequestUpdatingAttributesForAttachment(t3, e2) {
      var i2, n2;
      return null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerWillUpdateAttachment) || void 0 === n2 || n2.call(i2, e2), this.composition.updateAttributesForAttachment(t3, e2);
    }
    attachmentEditorDidRequestRemovingAttributeForAttachment(t3, e2) {
      var i2, n2;
      return null === (i2 = this.delegate) || void 0 === i2 || null === (n2 = i2.compositionControllerWillUpdateAttachment) || void 0 === n2 || n2.call(i2, e2), this.composition.removeAttributeForAttachment(t3, e2);
    }
    attachmentEditorDidRequestRemovalOfAttachment(t3) {
      var e2, i2;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionControllerDidRequestRemovalOfAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    attachmentEditorDidRequestDeselectingAttachment(t3) {
      var e2, i2;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.compositionControllerDidRequestDeselectingAttachment) || void 0 === i2 ? void 0 : i2.call(e2, t3);
    }
    canSyncDocumentView() {
      return !this.isEditingAttachment();
    }
    findAttachmentForElement(t3) {
      return this.composition.document.getAttachmentById(parseInt(t3.dataset.trixId, 10));
    }
  };
  var $n = class extends q {
  };
  var Zn = "data-trix-mutable";
  var Qn = "[".concat(Zn, "]");
  var tr = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true };
  var er = class extends q {
    constructor(t3) {
      super(t3), this.didMutate = this.didMutate.bind(this), this.element = t3, this.observer = new window.MutationObserver(this.didMutate), this.start();
    }
    start() {
      return this.reset(), this.observer.observe(this.element, tr);
    }
    stop() {
      return this.observer.disconnect();
    }
    didMutate(t3) {
      var e2, i2;
      if (this.mutations.push(...Array.from(this.findSignificantMutations(t3) || [])), this.mutations.length) return null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.elementDidMutate) || void 0 === i2 || i2.call(e2, this.getMutationSummary()), this.reset();
    }
    reset() {
      this.mutations = [];
    }
    findSignificantMutations(t3) {
      return t3.filter((t4) => this.mutationIsSignificant(t4));
    }
    mutationIsSignificant(t3) {
      if (this.nodeIsMutable(t3.target)) return false;
      for (const e2 of Array.from(this.nodesModifiedByMutation(t3))) if (this.nodeIsSignificant(e2)) return true;
      return false;
    }
    nodeIsSignificant(t3) {
      return t3 !== this.element && !this.nodeIsMutable(t3) && !M(t3);
    }
    nodeIsMutable(t3) {
      return y(t3, { matchingSelector: Qn });
    }
    nodesModifiedByMutation(t3) {
      const e2 = [];
      switch (t3.type) {
        case "attributes":
          t3.attributeName !== Zn && e2.push(t3.target);
          break;
        case "characterData":
          e2.push(t3.target.parentNode), e2.push(t3.target);
          break;
        case "childList":
          e2.push(...Array.from(t3.addedNodes || [])), e2.push(...Array.from(t3.removedNodes || []));
      }
      return e2;
    }
    getMutationSummary() {
      return this.getTextMutationSummary();
    }
    getTextMutationSummary() {
      const { additions: t3, deletions: e2 } = this.getTextChangesFromCharacterData(), i2 = this.getTextChangesFromChildList();
      Array.from(i2.additions).forEach((e3) => {
        Array.from(t3).includes(e3) || t3.push(e3);
      }), e2.push(...Array.from(i2.deletions || []));
      const n2 = {}, r2 = t3.join("");
      r2 && (n2.textAdded = r2);
      const o2 = e2.join("");
      return o2 && (n2.textDeleted = o2), n2;
    }
    getMutationsByType(t3) {
      return Array.from(this.mutations).filter((e2) => e2.type === t3);
    }
    getTextChangesFromChildList() {
      let t3, e2;
      const i2 = [], n2 = [];
      Array.from(this.getMutationsByType("childList")).forEach((t4) => {
        i2.push(...Array.from(t4.addedNodes || [])), n2.push(...Array.from(t4.removedNodes || []));
      });
      0 === i2.length && 1 === n2.length && I(n2[0]) ? (t3 = [], e2 = ["\n"]) : (t3 = ir(i2), e2 = ir(n2));
      const r2 = t3.filter((t4, i3) => t4 !== e2[i3]).map(Wt), o2 = e2.filter((e3, i3) => e3 !== t3[i3]).map(Wt);
      return { additions: r2, deletions: o2 };
    }
    getTextChangesFromCharacterData() {
      let t3, e2;
      const i2 = this.getMutationsByType("characterData");
      if (i2.length) {
        const n2 = i2[0], r2 = i2[i2.length - 1], o2 = function(t4, e3) {
          let i3, n3;
          return t4 = $2.box(t4), (e3 = $2.box(e3)).length < t4.length ? [n3, i3] = zt(t4, e3) : [i3, n3] = zt(e3, t4), { added: i3, removed: n3 };
        }(Wt(n2.oldValue), Wt(r2.target.data));
        t3 = o2.added, e2 = o2.removed;
      }
      return { additions: t3 ? [t3] : [], deletions: e2 ? [e2] : [] };
    }
  };
  var ir = function() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const e2 = [];
    for (const i2 of Array.from(t3)) switch (i2.nodeType) {
      case Node.TEXT_NODE:
        e2.push(i2.data);
        break;
      case Node.ELEMENT_NODE:
        "br" === k(i2) ? e2.push("\n") : e2.push(...Array.from(ir(i2.childNodes) || []));
    }
    return e2;
  };
  var nr = class extends ee {
    constructor(t3) {
      super(...arguments), this.file = t3;
    }
    perform(t3) {
      const e2 = new FileReader();
      return e2.onerror = () => t3(false), e2.onload = () => {
        e2.onerror = null;
        try {
          e2.abort();
        } catch (t4) {
        }
        return t3(true, this.file);
      }, e2.readAsArrayBuffer(this.file);
    }
  };
  var rr = class {
    constructor(t3) {
      this.element = t3;
    }
    shouldIgnore(t3) {
      return !!a.samsungAndroid && (this.previousEvent = this.event, this.event = t3, this.checkSamsungKeyboardBuggyModeStart(), this.checkSamsungKeyboardBuggyModeEnd(), this.buggyMode);
    }
    checkSamsungKeyboardBuggyModeStart() {
      this.insertingLongTextAfterUnidentifiedChar() && or(this.element.innerText, this.event.data) && (this.buggyMode = true, this.event.preventDefault());
    }
    checkSamsungKeyboardBuggyModeEnd() {
      this.buggyMode && "insertText" !== this.event.inputType && (this.buggyMode = false);
    }
    insertingLongTextAfterUnidentifiedChar() {
      var t3;
      return this.isBeforeInputInsertText() && this.previousEventWasUnidentifiedKeydown() && (null === (t3 = this.event.data) || void 0 === t3 ? void 0 : t3.length) > 50;
    }
    isBeforeInputInsertText() {
      return "beforeinput" === this.event.type && "insertText" === this.event.inputType;
    }
    previousEventWasUnidentifiedKeydown() {
      var t3, e2;
      return "keydown" === (null === (t3 = this.previousEvent) || void 0 === t3 ? void 0 : t3.type) && "Unidentified" === (null === (e2 = this.previousEvent) || void 0 === e2 ? void 0 : e2.key);
    }
  };
  var or = (t3, e2) => ar(t3) === ar(e2);
  var sr = new RegExp("(".concat("\uFFFC", "|").concat(d, "|").concat(g, "|\\s)+"), "g");
  var ar = (t3) => t3.replace(sr, " ").trim();
  var lr = class extends q {
    constructor(t3) {
      super(...arguments), this.element = t3, this.mutationObserver = new er(this.element), this.mutationObserver.delegate = this, this.flakyKeyboardDetector = new rr(this.element);
      for (const t4 in this.constructor.events) b(t4, { onElement: this.element, withCallback: this.handlerFor(t4) });
    }
    elementDidMutate(t3) {
    }
    editorWillSyncDocumentView() {
      return this.mutationObserver.stop();
    }
    editorDidSyncDocumentView() {
      return this.mutationObserver.start();
    }
    requestRender() {
      var t3, e2;
      return null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.inputControllerDidRequestRender) || void 0 === e2 ? void 0 : e2.call(t3);
    }
    requestReparse() {
      var t3, e2;
      return null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.inputControllerDidRequestReparse) || void 0 === e2 || e2.call(t3), this.requestRender();
    }
    attachFiles(t3) {
      const e2 = Array.from(t3).map((t4) => new nr(t4));
      return Promise.all(e2).then((t4) => {
        this.handleInput(function() {
          var e3, i2;
          return null === (e3 = this.delegate) || void 0 === e3 || e3.inputControllerWillAttachFiles(), null === (i2 = this.responder) || void 0 === i2 || i2.insertFiles(t4), this.requestRender();
        });
      });
    }
    handlerFor(t3) {
      return (e2) => {
        e2.defaultPrevented || this.handleInput(() => {
          if (!x(this.element)) {
            if (this.flakyKeyboardDetector.shouldIgnore(e2)) return;
            this.eventName = t3, this.constructor.events[t3].call(this, e2);
          }
        });
      };
    }
    handleInput(t3) {
      try {
        var e2;
        null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillHandleInput(), t3.call(this);
      } finally {
        var i2;
        null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerDidHandleInput();
      }
    }
    createLinkHTML(t3, e2) {
      const i2 = document.createElement("a");
      return i2.href = t3, i2.textContent = e2 || t3, i2.outerHTML;
    }
  };
  var cr;
  Di(lr, "events", {});
  var { browser: ur, keyNames: hr } = z;
  var dr = 0;
  var gr = class extends lr {
    constructor() {
      super(...arguments), this.resetInputSummary();
    }
    setInputSummary() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.inputSummary.eventName = this.eventName;
      for (const e2 in t3) {
        const i2 = t3[e2];
        this.inputSummary[e2] = i2;
      }
      return this.inputSummary;
    }
    resetInputSummary() {
      this.inputSummary = {};
    }
    reset() {
      return this.resetInputSummary(), Ft.reset();
    }
    elementDidMutate(t3) {
      var e2, i2;
      return this.isComposing() ? null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidAllowUnhandledInput) || void 0 === i2 ? void 0 : i2.call(e2) : this.handleInput(function() {
        return this.mutationIsSignificant(t3) && (this.mutationIsExpected(t3) ? this.requestRender() : this.requestReparse()), this.reset();
      });
    }
    mutationIsExpected(t3) {
      let { textAdded: e2, textDeleted: i2 } = t3;
      if (this.inputSummary.preferDocument) return true;
      const n2 = null != e2 ? e2 === this.inputSummary.textAdded : !this.inputSummary.textAdded, r2 = null != i2 ? this.inputSummary.didDelete : !this.inputSummary.didDelete, o2 = ["\n", " \n"].includes(e2) && !n2, s2 = "\n" === i2 && !r2;
      if (o2 && !s2 || s2 && !o2) {
        const t4 = this.getSelectedRange();
        if (t4) {
          var a2;
          const i3 = o2 ? e2.replace(/\n$/, "").length || -1 : (null == e2 ? void 0 : e2.length) || 1;
          if (null !== (a2 = this.responder) && void 0 !== a2 && a2.positionIsBlockBreak(t4[1] + i3)) return true;
        }
      }
      return n2 && r2;
    }
    mutationIsSignificant(t3) {
      var e2;
      const i2 = Object.keys(t3).length > 0, n2 = "" === (null === (e2 = this.compositionInput) || void 0 === e2 ? void 0 : e2.getEndData());
      return i2 || !n2;
    }
    getCompositionInput() {
      if (this.isComposing()) return this.compositionInput;
      this.compositionInput = new vr(this);
    }
    isComposing() {
      return this.compositionInput && !this.compositionInput.isEnded();
    }
    deleteInDirection(t3, e2) {
      var i2;
      return false !== (null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.deleteInDirection(t3)) ? this.setInputSummary({ didDelete: true }) : e2 ? (e2.preventDefault(), this.requestRender()) : void 0;
    }
    serializeSelectionToDataTransfer(t3) {
      var e2;
      if (!function(t4) {
        if (null == t4 || !t4.setData) return false;
        for (const e3 in Ct) {
          const i3 = Ct[e3];
          try {
            if (t4.setData(e3, i3), !t4.getData(e3) === i3) return false;
          } catch (t5) {
            return false;
          }
        }
        return true;
      }(t3)) return;
      const i2 = null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.getSelectedDocument().toSerializableDocument();
      return t3.setData("application/x-trix-document", JSON.stringify(i2)), t3.setData("text/html", Si.render(i2).innerHTML), t3.setData("text/plain", i2.toString().replace(/\n$/, "")), true;
    }
    canAcceptDataTransfer(t3) {
      const e2 = {};
      return Array.from((null == t3 ? void 0 : t3.types) || []).forEach((t4) => {
        e2[t4] = true;
      }), e2.Files || e2["application/x-trix-document"] || e2["text/html"] || e2["text/plain"];
    }
    getPastedHTMLUsingHiddenElement(t3) {
      const e2 = this.getSelectedRange(), i2 = { position: "absolute", left: "".concat(window.pageXOffset, "px"), top: "".concat(window.pageYOffset, "px"), opacity: 0 }, n2 = T({ style: i2, tagName: "div", editable: true });
      return document.body.appendChild(n2), n2.focus(), requestAnimationFrame(() => {
        const i3 = n2.innerHTML;
        return S(n2), this.setSelectedRange(e2), t3(i3);
      });
    }
  };
  Di(gr, "events", { keydown(t3) {
    this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true;
    const e2 = hr[t3.keyCode];
    if (e2) {
      var i2;
      let n3 = this.keys;
      ["ctrl", "alt", "shift", "meta"].forEach((e3) => {
        var i3;
        t3["".concat(e3, "Key")] && ("ctrl" === e3 && (e3 = "control"), n3 = null === (i3 = n3) || void 0 === i3 ? void 0 : i3[e3]);
      }), null != (null === (i2 = n3) || void 0 === i2 ? void 0 : i2[e2]) && (this.setInputSummary({ keyName: e2 }), Ft.reset(), n3[e2].call(this, t3));
    }
    if (St(t3)) {
      const e3 = String.fromCharCode(t3.keyCode).toLowerCase();
      if (e3) {
        var n2;
        const i3 = ["alt", "shift"].map((e4) => {
          if (t3["".concat(e4, "Key")]) return e4;
        }).filter((t4) => t4);
        i3.push(e3), null !== (n2 = this.delegate) && void 0 !== n2 && n2.inputControllerDidReceiveKeyboardCommand(i3) && t3.preventDefault();
      }
    }
  }, keypress(t3) {
    if (null != this.inputSummary.eventName) return;
    if (t3.metaKey) return;
    if (t3.ctrlKey && !t3.altKey) return;
    const e2 = fr(t3);
    var i2, n2;
    return e2 ? (null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillPerformTyping(), null === (n2 = this.responder) || void 0 === n2 || n2.insertString(e2), this.setInputSummary({ textAdded: e2, didDelete: this.selectionIsExpanded() })) : void 0;
  }, textInput(t3) {
    const { data: e2 } = t3, { textAdded: i2 } = this.inputSummary;
    if (i2 && i2 !== e2 && i2.toUpperCase() === e2) {
      var n2;
      const t4 = this.getSelectedRange();
      return this.setSelectedRange([t4[0], t4[1] + i2.length]), null === (n2 = this.responder) || void 0 === n2 || n2.insertString(e2), this.setInputSummary({ textAdded: e2 }), this.setSelectedRange(t4);
    }
  }, dragenter(t3) {
    t3.preventDefault();
  }, dragstart(t3) {
    var e2, i2;
    return this.serializeSelectionToDataTransfer(t3.dataTransfer), this.draggedRange = this.getSelectedRange(), null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidStartDrag) || void 0 === i2 ? void 0 : i2.call(e2);
  }, dragover(t3) {
    if (this.draggedRange || this.canAcceptDataTransfer(t3.dataTransfer)) {
      t3.preventDefault();
      const n2 = { x: t3.clientX, y: t3.clientY };
      var e2, i2;
      if (!Tt(n2, this.draggingPoint)) return this.draggingPoint = n2, null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidReceiveDragOverPoint) || void 0 === i2 ? void 0 : i2.call(e2, this.draggingPoint);
    }
  }, dragend(t3) {
    var e2, i2;
    null === (e2 = this.delegate) || void 0 === e2 || null === (i2 = e2.inputControllerDidCancelDrag) || void 0 === i2 || i2.call(e2), this.draggedRange = null, this.draggingPoint = null;
  }, drop(t3) {
    var e2, i2;
    t3.preventDefault();
    const n2 = null === (e2 = t3.dataTransfer) || void 0 === e2 ? void 0 : e2.files, r2 = t3.dataTransfer.getData("application/x-trix-document"), o2 = { x: t3.clientX, y: t3.clientY };
    if (null === (i2 = this.responder) || void 0 === i2 || i2.setLocationRangeFromPointRange(o2), null != n2 && n2.length) this.attachFiles(n2);
    else if (this.draggedRange) {
      var s2, a2;
      null === (s2 = this.delegate) || void 0 === s2 || s2.inputControllerWillMoveText(), null === (a2 = this.responder) || void 0 === a2 || a2.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender();
    } else if (r2) {
      var l2;
      const t4 = an.fromJSONString(r2);
      null === (l2 = this.responder) || void 0 === l2 || l2.insertDocument(t4), this.requestRender();
    }
    this.draggedRange = null, this.draggingPoint = null;
  }, cut(t3) {
    var e2, i2;
    if (null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionIsExpanded() && (this.serializeSelectionToDataTransfer(t3.clipboardData) && t3.preventDefault(), null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillCutText(), this.deleteInDirection("backward"), t3.defaultPrevented)) return this.requestRender();
  }, copy(t3) {
    var e2;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionIsExpanded() && this.serializeSelectionToDataTransfer(t3.clipboardData) && t3.preventDefault();
  }, paste(t3) {
    const e2 = t3.clipboardData || t3.testClipboardData, i2 = { clipboard: e2 };
    if (!e2 || br(t3)) return void this.getPastedHTMLUsingHiddenElement((t4) => {
      var e3, n3, r3;
      return i2.type = "text/html", i2.html = t4, null === (e3 = this.delegate) || void 0 === e3 || e3.inputControllerWillPaste(i2), null === (n3 = this.responder) || void 0 === n3 || n3.insertHTML(i2.html), this.requestRender(), null === (r3 = this.delegate) || void 0 === r3 ? void 0 : r3.inputControllerDidPaste(i2);
    });
    const n2 = e2.getData("URL"), r2 = e2.getData("text/html"), o2 = e2.getData("public.url-name");
    if (n2) {
      var s2, a2, l2;
      let t4;
      i2.type = "text/html", t4 = o2 ? Vt(o2).trim() : n2, i2.html = this.createLinkHTML(n2, t4), null === (s2 = this.delegate) || void 0 === s2 || s2.inputControllerWillPaste(i2), this.setInputSummary({ textAdded: t4, didDelete: this.selectionIsExpanded() }), null === (a2 = this.responder) || void 0 === a2 || a2.insertHTML(i2.html), this.requestRender(), null === (l2 = this.delegate) || void 0 === l2 || l2.inputControllerDidPaste(i2);
    } else if (Et(e2)) {
      var c2, u2, h2;
      i2.type = "text/plain", i2.string = e2.getData("text/plain"), null === (c2 = this.delegate) || void 0 === c2 || c2.inputControllerWillPaste(i2), this.setInputSummary({ textAdded: i2.string, didDelete: this.selectionIsExpanded() }), null === (u2 = this.responder) || void 0 === u2 || u2.insertString(i2.string), this.requestRender(), null === (h2 = this.delegate) || void 0 === h2 || h2.inputControllerDidPaste(i2);
    } else if (r2) {
      var d2, g2, m2;
      i2.type = "text/html", i2.html = r2, null === (d2 = this.delegate) || void 0 === d2 || d2.inputControllerWillPaste(i2), null === (g2 = this.responder) || void 0 === g2 || g2.insertHTML(i2.html), this.requestRender(), null === (m2 = this.delegate) || void 0 === m2 || m2.inputControllerDidPaste(i2);
    } else if (Array.from(e2.types).includes("Files")) {
      var p2, f2;
      const t4 = null === (p2 = e2.items) || void 0 === p2 || null === (p2 = p2[0]) || void 0 === p2 || null === (f2 = p2.getAsFile) || void 0 === f2 ? void 0 : f2.call(p2);
      if (t4) {
        var b2, v2, A2;
        const e3 = mr(t4);
        !t4.name && e3 && (t4.name = "pasted-file-".concat(++dr, ".").concat(e3)), i2.type = "File", i2.file = t4, null === (b2 = this.delegate) || void 0 === b2 || b2.inputControllerWillAttachFiles(), null === (v2 = this.responder) || void 0 === v2 || v2.insertFile(i2.file), this.requestRender(), null === (A2 = this.delegate) || void 0 === A2 || A2.inputControllerDidPaste(i2);
      }
    }
    t3.preventDefault();
  }, compositionstart(t3) {
    return this.getCompositionInput().start(t3.data);
  }, compositionupdate(t3) {
    return this.getCompositionInput().update(t3.data);
  }, compositionend(t3) {
    return this.getCompositionInput().end(t3.data);
  }, beforeinput(t3) {
    this.inputSummary.didInput = true;
  }, input(t3) {
    return this.inputSummary.didInput = true, t3.stopPropagation();
  } }), Di(gr, "keys", { backspace(t3) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t3);
  }, delete(t3) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t3);
  }, return(t3) {
    var e2, i2;
    return this.setInputSummary({ preferDocument: true }), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.insertLineBreak();
  }, tab(t3) {
    var e2, i2;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.canIncreaseNestingLevel() && (null === (i2 = this.responder) || void 0 === i2 || i2.increaseNestingLevel(), this.requestRender(), t3.preventDefault());
  }, left(t3) {
    var e2;
    if (this.selectionIsInCursorTarget()) return t3.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("backward");
  }, right(t3) {
    var e2;
    if (this.selectionIsInCursorTarget()) return t3.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("forward");
  }, control: { d(t3) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t3);
  }, h(t3) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t3);
  }, o(t3) {
    var e2, i2;
    return t3.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.insertString("\n", { updatePosition: false }), this.requestRender();
  } }, shift: { return(t3) {
    var e2, i2;
    null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.insertString("\n"), this.requestRender(), t3.preventDefault();
  }, tab(t3) {
    var e2, i2;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.canDecreaseNestingLevel() && (null === (i2 = this.responder) || void 0 === i2 || i2.decreaseNestingLevel(), this.requestRender(), t3.preventDefault());
  }, left(t3) {
    if (this.selectionIsInCursorTarget()) return t3.preventDefault(), this.expandSelectionInDirection("backward");
  }, right(t3) {
    if (this.selectionIsInCursorTarget()) return t3.preventDefault(), this.expandSelectionInDirection("forward");
  } }, alt: { backspace(t3) {
    var e2;
    return this.setInputSummary({ preferDocument: false }), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.inputControllerWillPerformTyping();
  } }, meta: { backspace(t3) {
    var e2;
    return this.setInputSummary({ preferDocument: false }), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.inputControllerWillPerformTyping();
  } } }), gr.proxyMethod("responder?.getSelectedRange"), gr.proxyMethod("responder?.setSelectedRange"), gr.proxyMethod("responder?.expandSelectionInDirection"), gr.proxyMethod("responder?.selectionIsInCursorTarget"), gr.proxyMethod("responder?.selectionIsExpanded");
  var mr = (t3) => {
    var e2;
    return null === (e2 = t3.type) || void 0 === e2 || null === (e2 = e2.match(/\/(\w+)$/)) || void 0 === e2 ? void 0 : e2[1];
  };
  var pr = !(null === (cr = " ".codePointAt) || void 0 === cr || !cr.call(" ", 0));
  var fr = function(t3) {
    if (t3.key && pr && t3.key.codePointAt(0) === t3.keyCode) return t3.key;
    {
      let e2;
      if (null === t3.which ? e2 = t3.keyCode : 0 !== t3.which && 0 !== t3.charCode && (e2 = t3.charCode), null != e2 && "escape" !== hr[e2]) return $2.fromCodepoints([e2]).toString();
    }
  };
  var br = function(t3) {
    const e2 = t3.clipboardData;
    if (e2) {
      if (e2.types.includes("text/html")) {
        for (const t4 of e2.types) {
          const i2 = /^CorePasteboardFlavorType/.test(t4), n2 = /^dyn\./.test(t4) && e2.getData(t4);
          if (i2 || n2) return true;
        }
        return false;
      }
      {
        const t4 = e2.types.includes("com.apple.webarchive"), i2 = e2.types.includes("com.apple.flat-rtfd");
        return t4 || i2;
      }
    }
  };
  var vr = class extends q {
    constructor(t3) {
      super(...arguments), this.inputController = t3, this.responder = this.inputController.responder, this.delegate = this.inputController.delegate, this.inputSummary = this.inputController.inputSummary, this.data = {};
    }
    start(t3) {
      if (this.data.start = t3, this.isSignificant()) {
        var e2, i2;
        if ("keypress" === this.inputSummary.eventName && this.inputSummary.textAdded) null === (i2 = this.responder) || void 0 === i2 || i2.deleteInDirection("left");
        this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.getSelectedRange();
      }
    }
    update(t3) {
      if (this.data.update = t3, this.isSignificant()) {
        const t4 = this.selectPlaceholder();
        t4 && (this.forgetPlaceholder(), this.range = t4);
      }
    }
    end(t3) {
      return this.data.end = t3, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.setSelectedRange(this.range), null === (n2 = this.responder) || void 0 === n2 || n2.insertString(this.data.end), null === (r2 = this.responder) || void 0 === r2 ? void 0 : r2.setSelectedRange(this.range[0] + this.data.end.length)) : null != this.data.start || null != this.data.update ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
      var e2, i2, n2, r2;
    }
    getEndData() {
      return this.data.end;
    }
    isEnded() {
      return null != this.getEndData();
    }
    isSignificant() {
      return !ur.composesExistingText || this.inputSummary.didInput;
    }
    canApplyToDocument() {
      var t3, e2;
      return 0 === (null === (t3 = this.data.start) || void 0 === t3 ? void 0 : t3.length) && (null === (e2 = this.data.end) || void 0 === e2 ? void 0 : e2.length) > 0 && this.range;
    }
  };
  vr.proxyMethod("inputController.setInputSummary"), vr.proxyMethod("inputController.requestRender"), vr.proxyMethod("inputController.requestReparse"), vr.proxyMethod("responder?.selectionIsExpanded"), vr.proxyMethod("responder?.insertPlaceholder"), vr.proxyMethod("responder?.selectPlaceholder"), vr.proxyMethod("responder?.forgetPlaceholder");
  var Ar = class extends lr {
    constructor() {
      super(...arguments), this.render = this.render.bind(this);
    }
    elementDidMutate() {
      return this.scheduledRender ? this.composing ? null === (t3 = this.delegate) || void 0 === t3 || null === (e2 = t3.inputControllerDidAllowUnhandledInput) || void 0 === e2 ? void 0 : e2.call(t3) : void 0 : this.reparse();
      var t3, e2;
    }
    scheduleRender() {
      return this.scheduledRender ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
    }
    render() {
      var t3, e2;
      (cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing) || (null === (e2 = this.delegate) || void 0 === e2 || e2.render());
      null === (t3 = this.afterRender) || void 0 === t3 || t3.call(this), this.afterRender = null;
    }
    reparse() {
      var t3;
      return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.reparse();
    }
    insertString() {
      var t3;
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i2 = arguments.length > 1 ? arguments[1] : void 0;
      return null === (t3 = this.delegate) || void 0 === t3 || t3.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
        var t4;
        return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.insertString(e2, i2);
      });
    }
    toggleAttributeIfSupported(t3) {
      var e2;
      if (gt().includes(t3)) return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformFormatting(t3), this.withTargetDOMRange(function() {
        var e3;
        return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.toggleCurrentAttribute(t3);
      });
    }
    activateAttributeIfSupported(t3, e2) {
      var i2;
      if (gt().includes(t3)) return null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillPerformFormatting(t3), this.withTargetDOMRange(function() {
        var i3;
        return null === (i3 = this.responder) || void 0 === i3 ? void 0 : i3.setCurrentAttribute(t3, e2);
      });
    }
    deleteInDirection(t3) {
      let { recordUndoEntry: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { recordUndoEntry: true };
      var i2;
      e2 && (null === (i2 = this.delegate) || void 0 === i2 || i2.inputControllerWillPerformTyping());
      const n2 = () => {
        var e3;
        return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.deleteInDirection(t3);
      }, r2 = this.getTargetDOMRange({ minLength: this.composing ? 1 : 2 });
      return r2 ? this.withTargetDOMRange(r2, n2) : n2();
    }
    withTargetDOMRange(t3, e2) {
      var i2;
      return "function" == typeof t3 && (e2 = t3, t3 = this.getTargetDOMRange()), t3 ? null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.withTargetDOMRange(t3, e2.bind(this)) : (Ft.reset(), e2.call(this));
    }
    getTargetDOMRange() {
      var t3, e2;
      let { minLength: i2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { minLength: 0 };
      const n2 = null === (t3 = (e2 = this.event).getTargetRanges) || void 0 === t3 ? void 0 : t3.call(e2);
      if (n2 && n2.length) {
        const t4 = yr(n2[0]);
        if (0 === i2 || t4.toString().length >= i2) return t4;
      }
    }
    withEvent(t3, e2) {
      let i2;
      this.event = t3;
      try {
        i2 = e2.call(this);
      } finally {
        this.event = null;
      }
      return i2;
    }
  };
  Di(Ar, "events", { keydown(t3) {
    if (St(t3)) {
      var e2;
      const i2 = Rr(t3);
      null !== (e2 = this.delegate) && void 0 !== e2 && e2.inputControllerDidReceiveKeyboardCommand(i2) && t3.preventDefault();
    } else {
      let e3 = t3.key;
      t3.altKey && (e3 += "+Alt"), t3.shiftKey && (e3 += "+Shift");
      const i2 = this.constructor.keys[e3];
      if (i2) return this.withEvent(t3, i2);
    }
  }, paste(t3) {
    var e2;
    let i2;
    const n2 = null === (e2 = t3.clipboardData) || void 0 === e2 ? void 0 : e2.getData("URL");
    return Er(t3) ? (t3.preventDefault(), this.attachFiles(t3.clipboardData.files)) : Sr(t3) ? (t3.preventDefault(), i2 = { type: "text/plain", string: t3.clipboardData.getData("text/plain") }, null === (r2 = this.delegate) || void 0 === r2 || r2.inputControllerWillPaste(i2), null === (o2 = this.responder) || void 0 === o2 || o2.insertString(i2.string), this.render(), null === (s2 = this.delegate) || void 0 === s2 ? void 0 : s2.inputControllerDidPaste(i2)) : n2 ? (t3.preventDefault(), i2 = { type: "text/html", html: this.createLinkHTML(n2) }, null === (a2 = this.delegate) || void 0 === a2 || a2.inputControllerWillPaste(i2), null === (l2 = this.responder) || void 0 === l2 || l2.insertHTML(i2.html), this.render(), null === (c2 = this.delegate) || void 0 === c2 ? void 0 : c2.inputControllerDidPaste(i2)) : void 0;
    var r2, o2, s2, a2, l2, c2;
  }, beforeinput(t3) {
    const e2 = this.constructor.inputTypes[t3.inputType], i2 = (n2 = t3, !(!/iPhone|iPad/.test(navigator.userAgent) || n2.inputType && "insertParagraph" !== n2.inputType));
    var n2;
    e2 && (this.withEvent(t3, e2), i2 || this.scheduleRender()), i2 && this.render();
  }, input(t3) {
    Ft.reset();
  }, dragstart(t3) {
    var e2, i2;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionContainsAttachments() && (t3.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: null === (i2 = this.responder) || void 0 === i2 ? void 0 : i2.getSelectedRange(), point: kr(t3) });
  }, dragenter(t3) {
    xr(t3) && t3.preventDefault();
  }, dragover(t3) {
    if (this.dragging) {
      t3.preventDefault();
      const i2 = kr(t3);
      var e2;
      if (!Tt(i2, this.dragging.point)) return this.dragging.point = i2, null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.setLocationRangeFromPointRange(i2);
    } else xr(t3) && t3.preventDefault();
  }, drop(t3) {
    var e2, i2;
    if (this.dragging) return t3.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillMoveText(), null === (i2 = this.responder) || void 0 === i2 || i2.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender();
    if (xr(t3)) {
      var n2;
      t3.preventDefault();
      const e3 = kr(t3);
      return null === (n2 = this.responder) || void 0 === n2 || n2.setLocationRangeFromPointRange(e3), this.attachFiles(t3.dataTransfer.files);
    }
  }, dragend() {
    var t3;
    this.dragging && (null === (t3 = this.responder) || void 0 === t3 || t3.setSelectedRange(this.dragging.range), this.dragging = null);
  }, compositionend(t3) {
    this.composing && (this.composing = false, a.recentAndroid || this.scheduleRender());
  } }), Di(Ar, "keys", { ArrowLeft() {
    var t3, e2;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.shouldManageMovingCursorInDirection("backward")) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("backward");
  }, ArrowRight() {
    var t3, e2;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.shouldManageMovingCursorInDirection("forward")) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("forward");
  }, Backspace() {
    var t3, e2, i2;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.shouldManageDeletingInDirection("backward")) return this.event.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i2 = this.responder) || void 0 === i2 || i2.deleteInDirection("backward"), this.render();
  }, Tab() {
    var t3, e2;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.canIncreaseNestingLevel()) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 || e2.increaseNestingLevel(), this.render();
  }, "Tab+Shift"() {
    var t3, e2;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.canDecreaseNestingLevel()) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 || e2.decreaseNestingLevel(), this.render();
  } }), Di(Ar, "inputTypes", { deleteByComposition() {
    return this.deleteInDirection("backward", { recordUndoEntry: false });
  }, deleteByCut() {
    return this.deleteInDirection("backward");
  }, deleteByDrag() {
    return this.event.preventDefault(), this.withTargetDOMRange(function() {
      var t3;
      this.deleteByDragRange = null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.getSelectedRange();
    });
  }, deleteCompositionText() {
    return this.deleteInDirection("backward", { recordUndoEntry: false });
  }, deleteContent() {
    return this.deleteInDirection("backward");
  }, deleteContentBackward() {
    return this.deleteInDirection("backward");
  }, deleteContentForward() {
    return this.deleteInDirection("forward");
  }, deleteEntireSoftLine() {
    return this.deleteInDirection("forward");
  }, deleteHardLineBackward() {
    return this.deleteInDirection("backward");
  }, deleteHardLineForward() {
    return this.deleteInDirection("forward");
  }, deleteSoftLineBackward() {
    return this.deleteInDirection("backward");
  }, deleteSoftLineForward() {
    return this.deleteInDirection("forward");
  }, deleteWordBackward() {
    return this.deleteInDirection("backward");
  }, deleteWordForward() {
    return this.deleteInDirection("forward");
  }, formatBackColor() {
    return this.activateAttributeIfSupported("backgroundColor", this.event.data);
  }, formatBold() {
    return this.toggleAttributeIfSupported("bold");
  }, formatFontColor() {
    return this.activateAttributeIfSupported("color", this.event.data);
  }, formatFontName() {
    return this.activateAttributeIfSupported("font", this.event.data);
  }, formatIndent() {
    var t3;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.canIncreaseNestingLevel()) return this.withTargetDOMRange(function() {
      var t4;
      return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.increaseNestingLevel();
    });
  }, formatItalic() {
    return this.toggleAttributeIfSupported("italic");
  }, formatJustifyCenter() {
    return this.toggleAttributeIfSupported("justifyCenter");
  }, formatJustifyFull() {
    return this.toggleAttributeIfSupported("justifyFull");
  }, formatJustifyLeft() {
    return this.toggleAttributeIfSupported("justifyLeft");
  }, formatJustifyRight() {
    return this.toggleAttributeIfSupported("justifyRight");
  }, formatOutdent() {
    var t3;
    if (null !== (t3 = this.responder) && void 0 !== t3 && t3.canDecreaseNestingLevel()) return this.withTargetDOMRange(function() {
      var t4;
      return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.decreaseNestingLevel();
    });
  }, formatRemove() {
    this.withTargetDOMRange(function() {
      for (const i2 in null === (t3 = this.responder) || void 0 === t3 ? void 0 : t3.getCurrentAttributes()) {
        var t3, e2;
        null === (e2 = this.responder) || void 0 === e2 || e2.removeCurrentAttribute(i2);
      }
    });
  }, formatSetBlockTextDirection() {
    return this.activateAttributeIfSupported("blockDir", this.event.data);
  }, formatSetInlineTextDirection() {
    return this.activateAttributeIfSupported("textDir", this.event.data);
  }, formatStrikeThrough() {
    return this.toggleAttributeIfSupported("strike");
  }, formatSubscript() {
    return this.toggleAttributeIfSupported("sub");
  }, formatSuperscript() {
    return this.toggleAttributeIfSupported("sup");
  }, formatUnderline() {
    return this.toggleAttributeIfSupported("underline");
  }, historyRedo() {
    var t3;
    return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.inputControllerWillPerformRedo();
  }, historyUndo() {
    var t3;
    return null === (t3 = this.delegate) || void 0 === t3 ? void 0 : t3.inputControllerWillPerformUndo();
  }, insertCompositionText() {
    return this.composing = true, this.insertString(this.event.data);
  }, insertFromComposition() {
    return this.composing = false, this.insertString(this.event.data);
  }, insertFromDrop() {
    const t3 = this.deleteByDragRange;
    var e2;
    if (t3) return this.deleteByDragRange = null, null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
      var e3;
      return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.moveTextFromRange(t3);
    });
  }, insertFromPaste() {
    const { dataTransfer: t3 } = this.event, e2 = { dataTransfer: t3 }, i2 = t3.getData("URL"), n2 = t3.getData("text/html");
    if (i2) {
      var r2;
      let n3;
      this.event.preventDefault(), e2.type = "text/html";
      const o3 = t3.getData("public.url-name");
      n3 = o3 ? Vt(o3).trim() : i2, e2.html = this.createLinkHTML(i2, n3), null === (r2 = this.delegate) || void 0 === r2 || r2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t4;
        return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.insertHTML(e2.html);
      }), this.afterRender = () => {
        var t4;
        return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.inputControllerDidPaste(e2);
      };
    } else if (Et(t3)) {
      var o2;
      e2.type = "text/plain", e2.string = t3.getData("text/plain"), null === (o2 = this.delegate) || void 0 === o2 || o2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t4;
        return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.insertString(e2.string);
      }), this.afterRender = () => {
        var t4;
        return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.inputControllerDidPaste(e2);
      };
    } else if (Cr(this.event)) {
      var s2;
      e2.type = "File", e2.file = t3.files[0], null === (s2 = this.delegate) || void 0 === s2 || s2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t4;
        return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.insertFile(e2.file);
      }), this.afterRender = () => {
        var t4;
        return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.inputControllerDidPaste(e2);
      };
    } else if (n2) {
      var a2;
      this.event.preventDefault(), e2.type = "text/html", e2.html = n2, null === (a2 = this.delegate) || void 0 === a2 || a2.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t4;
        return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.insertHTML(e2.html);
      }), this.afterRender = () => {
        var t4;
        return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.inputControllerDidPaste(e2);
      };
    }
  }, insertFromYank() {
    return this.insertString(this.event.data);
  }, insertLineBreak() {
    return this.insertString("\n");
  }, insertLink() {
    return this.activateAttributeIfSupported("href", this.event.data);
  }, insertOrderedList() {
    return this.toggleAttributeIfSupported("number");
  }, insertParagraph() {
    var t3;
    return null === (t3 = this.delegate) || void 0 === t3 || t3.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
      var t4;
      return null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.insertLineBreak();
    });
  }, insertReplacementText() {
    const t3 = this.event.dataTransfer.getData("text/plain"), e2 = this.event.getTargetRanges()[0];
    this.withTargetDOMRange(e2, () => {
      this.insertString(t3, { updatePosition: false });
    });
  }, insertText() {
    var t3;
    return this.insertString(this.event.data || (null === (t3 = this.event.dataTransfer) || void 0 === t3 ? void 0 : t3.getData("text/plain")));
  }, insertTranspose() {
    return this.insertString(this.event.data);
  }, insertUnorderedList() {
    return this.toggleAttributeIfSupported("bullet");
  } });
  var yr = function(t3) {
    const e2 = document.createRange();
    return e2.setStart(t3.startContainer, t3.startOffset), e2.setEnd(t3.endContainer, t3.endOffset), e2;
  };
  var xr = (t3) => {
    var e2;
    return Array.from((null === (e2 = t3.dataTransfer) || void 0 === e2 ? void 0 : e2.types) || []).includes("Files");
  };
  var Cr = (t3) => {
    var e2;
    return (null === (e2 = t3.dataTransfer.files) || void 0 === e2 ? void 0 : e2[0]) && !Er(t3) && !((t4) => {
      let { dataTransfer: e3 } = t4;
      return e3.types.includes("Files") && e3.types.includes("text/html") && e3.getData("text/html").includes("urn:schemas-microsoft-com:office:office");
    })(t3);
  };
  var Er = function(t3) {
    const e2 = t3.clipboardData;
    if (e2) {
      return Array.from(e2.types).filter((t4) => t4.match(/file/i)).length === e2.types.length && e2.files.length >= 1;
    }
  };
  var Sr = function(t3) {
    const e2 = t3.clipboardData;
    if (e2) return e2.types.includes("text/plain") && 1 === e2.types.length;
  };
  var Rr = function(t3) {
    const e2 = [];
    return t3.altKey && e2.push("alt"), t3.shiftKey && e2.push("shift"), e2.push(t3.key), e2;
  };
  var kr = (t3) => ({ x: t3.clientX, y: t3.clientY });
  var Tr = "[data-trix-attribute]";
  var wr = "[data-trix-action]";
  var Lr = "".concat(Tr, ", ").concat(wr);
  var Dr = "[data-trix-dialog]";
  var Nr = "".concat(Dr, "[data-trix-active]");
  var Ir = "".concat(Dr, " [data-trix-method]");
  var Or = "".concat(Dr, " [data-trix-input]");
  var Fr = (t3, e2) => (e2 || (e2 = Mr(t3)), t3.querySelector("[data-trix-input][name='".concat(e2, "']")));
  var Pr = (t3) => t3.getAttribute("data-trix-action");
  var Mr = (t3) => t3.getAttribute("data-trix-attribute") || t3.getAttribute("data-trix-dialog-attribute");
  var Br = class extends q {
    constructor(t3) {
      super(t3), this.didClickActionButton = this.didClickActionButton.bind(this), this.didClickAttributeButton = this.didClickAttributeButton.bind(this), this.didClickDialogButton = this.didClickDialogButton.bind(this), this.didKeyDownDialogInput = this.didKeyDownDialogInput.bind(this), this.element = t3, this.attributes = {}, this.actions = {}, this.resetDialogInputs(), b("mousedown", { onElement: this.element, matchingSelector: wr, withCallback: this.didClickActionButton }), b("mousedown", { onElement: this.element, matchingSelector: Tr, withCallback: this.didClickAttributeButton }), b("click", { onElement: this.element, matchingSelector: Lr, preventDefault: true }), b("click", { onElement: this.element, matchingSelector: Ir, withCallback: this.didClickDialogButton }), b("keydown", { onElement: this.element, matchingSelector: Or, withCallback: this.didKeyDownDialogInput });
    }
    didClickActionButton(t3, e2) {
      var i2;
      null === (i2 = this.delegate) || void 0 === i2 || i2.toolbarDidClickButton(), t3.preventDefault();
      const n2 = Pr(e2);
      return this.getDialog(n2) ? this.toggleDialog(n2) : null === (r2 = this.delegate) || void 0 === r2 ? void 0 : r2.toolbarDidInvokeAction(n2, e2);
      var r2;
    }
    didClickAttributeButton(t3, e2) {
      var i2;
      null === (i2 = this.delegate) || void 0 === i2 || i2.toolbarDidClickButton(), t3.preventDefault();
      const n2 = Mr(e2);
      var r2;
      this.getDialog(n2) ? this.toggleDialog(n2) : null === (r2 = this.delegate) || void 0 === r2 || r2.toolbarDidToggleAttribute(n2);
      return this.refreshAttributeButtons();
    }
    didClickDialogButton(t3, e2) {
      const i2 = y(e2, { matchingSelector: Dr });
      return this[e2.getAttribute("data-trix-method")].call(this, i2);
    }
    didKeyDownDialogInput(t3, e2) {
      if (13 === t3.keyCode) {
        t3.preventDefault();
        const i2 = e2.getAttribute("name"), n2 = this.getDialog(i2);
        this.setAttribute(n2);
      }
      if (27 === t3.keyCode) return t3.preventDefault(), this.hideDialog();
    }
    updateActions(t3) {
      return this.actions = t3, this.refreshActionButtons();
    }
    refreshActionButtons() {
      return this.eachActionButton((t3, e2) => {
        t3.disabled = false === this.actions[e2];
      });
    }
    eachActionButton(t3) {
      return Array.from(this.element.querySelectorAll(wr)).map((e2) => t3(e2, Pr(e2)));
    }
    updateAttributes(t3) {
      return this.attributes = t3, this.refreshAttributeButtons();
    }
    refreshAttributeButtons() {
      return this.eachAttributeButton((t3, e2) => (t3.disabled = false === this.attributes[e2], this.attributes[e2] || this.dialogIsVisible(e2) ? (t3.setAttribute("data-trix-active", ""), t3.classList.add("trix-active")) : (t3.removeAttribute("data-trix-active"), t3.classList.remove("trix-active"))));
    }
    eachAttributeButton(t3) {
      return Array.from(this.element.querySelectorAll(Tr)).map((e2) => t3(e2, Mr(e2)));
    }
    applyKeyboardCommand(t3) {
      const e2 = JSON.stringify(t3.sort());
      for (const t4 of Array.from(this.element.querySelectorAll("[data-trix-key]"))) {
        const i2 = t4.getAttribute("data-trix-key").split("+");
        if (JSON.stringify(i2.sort()) === e2) return v("mousedown", { onElement: t4 }), true;
      }
      return false;
    }
    dialogIsVisible(t3) {
      const e2 = this.getDialog(t3);
      if (e2) return e2.hasAttribute("data-trix-active");
    }
    toggleDialog(t3) {
      return this.dialogIsVisible(t3) ? this.hideDialog() : this.showDialog(t3);
    }
    showDialog(t3) {
      var e2, i2;
      this.hideDialog(), null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarWillShowDialog();
      const n2 = this.getDialog(t3);
      n2.setAttribute("data-trix-active", ""), n2.classList.add("trix-active"), Array.from(n2.querySelectorAll("input[disabled]")).forEach((t4) => {
        t4.removeAttribute("disabled");
      });
      const r2 = Mr(n2);
      if (r2) {
        const e3 = Fr(n2, t3);
        e3 && (e3.value = this.attributes[r2] || "", e3.select());
      }
      return null === (i2 = this.delegate) || void 0 === i2 ? void 0 : i2.toolbarDidShowDialog(t3);
    }
    setAttribute(t3) {
      var e2;
      const i2 = Mr(t3), n2 = Fr(t3, i2);
      return !n2.willValidate || (n2.setCustomValidity(""), n2.checkValidity() && this.isSafeAttribute(n2)) ? (null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarDidUpdateAttribute(i2, n2.value), this.hideDialog()) : (n2.setCustomValidity("Invalid value"), n2.setAttribute("data-trix-validate", ""), n2.classList.add("trix-validate"), n2.focus());
    }
    isSafeAttribute(t3) {
      return !t3.hasAttribute("data-trix-validate-href") || li.isValidAttribute("a", "href", t3.value);
    }
    removeAttribute(t3) {
      var e2;
      const i2 = Mr(t3);
      return null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarDidRemoveAttribute(i2), this.hideDialog();
    }
    hideDialog() {
      const t3 = this.element.querySelector(Nr);
      var e2;
      if (t3) return t3.removeAttribute("data-trix-active"), t3.classList.remove("trix-active"), this.resetDialogInputs(), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.toolbarDidHideDialog(((t4) => t4.getAttribute("data-trix-dialog"))(t3));
    }
    resetDialogInputs() {
      Array.from(this.element.querySelectorAll(Or)).forEach((t3) => {
        t3.setAttribute("disabled", "disabled"), t3.removeAttribute("data-trix-validate"), t3.classList.remove("trix-validate");
      });
    }
    getDialog(t3) {
      return this.element.querySelector("[data-trix-dialog=".concat(t3, "]"));
    }
  };
  var _r = class extends $n {
    constructor(t3) {
      let { editorElement: e2, document: i2, html: n2 } = t3;
      super(...arguments), this.editorElement = e2, this.selectionManager = new Vn(this.editorElement), this.selectionManager.delegate = this, this.composition = new wn(), this.composition.delegate = this, this.attachmentManager = new kn(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = 2 === _.getLevel() ? new Ar(this.editorElement) : new gr(this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new Xn(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new Br(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new Pn(this.composition, this.selectionManager, this.editorElement), i2 ? this.editor.loadDocument(i2) : this.editor.loadHTML(n2);
    }
    registerSelectionManager() {
      return Ft.registerSelectionManager(this.selectionManager);
    }
    unregisterSelectionManager() {
      return Ft.unregisterSelectionManager(this.selectionManager);
    }
    render() {
      return this.compositionController.render();
    }
    reparse() {
      return this.composition.replaceHTML(this.editorElement.innerHTML);
    }
    compositionDidChangeDocument(t3) {
      if (this.notifyEditorElement("document-change"), !this.handlingInput) return this.render();
    }
    compositionDidChangeCurrentAttributes(t3) {
      return this.currentAttributes = t3, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
    }
    compositionDidPerformInsertionAtRange(t3) {
      this.pasting && (this.pastedRange = t3);
    }
    compositionShouldAcceptFile(t3) {
      return this.notifyEditorElement("file-accept", { file: t3 });
    }
    compositionDidAddAttachment(t3) {
      const e2 = this.attachmentManager.manageAttachment(t3);
      return this.notifyEditorElement("attachment-add", { attachment: e2 });
    }
    compositionDidEditAttachment(t3) {
      this.compositionController.rerenderViewForObject(t3);
      const e2 = this.attachmentManager.manageAttachment(t3);
      return this.notifyEditorElement("attachment-edit", { attachment: e2 }), this.notifyEditorElement("change");
    }
    compositionDidChangeAttachmentPreviewURL(t3) {
      return this.compositionController.invalidateViewForObject(t3), this.notifyEditorElement("change");
    }
    compositionDidRemoveAttachment(t3) {
      const e2 = this.attachmentManager.unmanageAttachment(t3);
      return this.notifyEditorElement("attachment-remove", { attachment: e2 });
    }
    compositionDidStartEditingAttachment(t3, e2) {
      return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t3), this.compositionController.installAttachmentEditorForAttachment(t3, e2), this.selectionManager.setLocationRange(this.attachmentLocationRange);
    }
    compositionDidStopEditingAttachment(t3) {
      this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
    }
    compositionDidRequestChangingSelectionToLocationRange(t3) {
      if (!this.loadingSnapshot || this.isFocused()) return this.requestedLocationRange = t3, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render();
    }
    compositionWillLoadSnapshot() {
      this.loadingSnapshot = true;
    }
    compositionDidLoadSnapshot() {
      this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
    }
    getSelectionManager() {
      return this.selectionManager;
    }
    attachmentManagerDidRequestRemovalOfAttachment(t3) {
      return this.removeAttachment(t3);
    }
    compositionControllerWillSyncDocumentView() {
      return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
    }
    compositionControllerDidSyncDocumentView() {
      return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
    }
    compositionControllerDidRender() {
      this.requestedLocationRange && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
    }
    compositionControllerDidFocus() {
      return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
    }
    compositionControllerDidBlur() {
      return this.notifyEditorElement("blur");
    }
    compositionControllerDidSelectAttachment(t3, e2) {
      return this.toolbarController.hideDialog(), this.composition.editAttachment(t3, e2);
    }
    compositionControllerDidRequestDeselectingAttachment(t3) {
      const e2 = this.attachmentLocationRange || this.composition.document.getLocationRangeOfAttachment(t3);
      return this.selectionManager.setLocationRange(e2[1]);
    }
    compositionControllerWillUpdateAttachment(t3) {
      return this.editor.recordUndoEntry("Edit Attachment", { context: t3.id, consolidatable: true });
    }
    compositionControllerDidRequestRemovalOfAttachment(t3) {
      return this.removeAttachment(t3);
    }
    inputControllerWillHandleInput() {
      this.handlingInput = true, this.requestedRender = false;
    }
    inputControllerDidRequestRender() {
      this.requestedRender = true;
    }
    inputControllerDidHandleInput() {
      if (this.handlingInput = false, this.requestedRender) return this.requestedRender = false, this.render();
    }
    inputControllerDidAllowUnhandledInput() {
      return this.notifyEditorElement("change");
    }
    inputControllerDidRequestReparse() {
      return this.reparse();
    }
    inputControllerWillPerformTyping() {
      return this.recordTypingUndoEntry();
    }
    inputControllerWillPerformFormatting(t3) {
      return this.recordFormattingUndoEntry(t3);
    }
    inputControllerWillCutText() {
      return this.editor.recordUndoEntry("Cut");
    }
    inputControllerWillPaste(t3) {
      return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t3 });
    }
    inputControllerDidPaste(t3) {
      return t3.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t3 });
    }
    inputControllerWillMoveText() {
      return this.editor.recordUndoEntry("Move");
    }
    inputControllerWillAttachFiles() {
      return this.editor.recordUndoEntry("Drop Files");
    }
    inputControllerWillPerformUndo() {
      return this.editor.undo();
    }
    inputControllerWillPerformRedo() {
      return this.editor.redo();
    }
    inputControllerDidReceiveKeyboardCommand(t3) {
      return this.toolbarController.applyKeyboardCommand(t3);
    }
    inputControllerDidStartDrag() {
      this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
    }
    inputControllerDidReceiveDragOverPoint(t3) {
      return this.selectionManager.setLocationRangeFromPointRange(t3);
    }
    inputControllerDidCancelDrag() {
      this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
    }
    locationRangeDidChange(t3) {
      return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !Dt(this.attachmentLocationRange, t3) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
    }
    toolbarDidClickButton() {
      if (!this.getLocationRange()) return this.setLocationRange({ index: 0, offset: 0 });
    }
    toolbarDidInvokeAction(t3, e2) {
      return this.invokeAction(t3, e2);
    }
    toolbarDidToggleAttribute(t3) {
      if (this.recordFormattingUndoEntry(t3), this.composition.toggleCurrentAttribute(t3), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarDidUpdateAttribute(t3, e2) {
      if (this.recordFormattingUndoEntry(t3), this.composition.setCurrentAttribute(t3, e2), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarDidRemoveAttribute(t3) {
      if (this.recordFormattingUndoEntry(t3), this.composition.removeCurrentAttribute(t3), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarWillShowDialog(t3) {
      return this.composition.expandSelectionForEditing(), this.freezeSelection();
    }
    toolbarDidShowDialog(t3) {
      return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t3 });
    }
    toolbarDidHideDialog(t3) {
      return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t3 });
    }
    freezeSelection() {
      if (!this.selectionFrozen) return this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render();
    }
    thawSelection() {
      if (this.selectionFrozen) return this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render();
    }
    canInvokeAction(t3) {
      return !!this.actionIsExternal(t3) || !(null === (e2 = this.actions[t3]) || void 0 === e2 || null === (e2 = e2.test) || void 0 === e2 || !e2.call(this));
      var e2;
    }
    invokeAction(t3, e2) {
      return this.actionIsExternal(t3) ? this.notifyEditorElement("action-invoke", { actionName: t3, invokingElement: e2 }) : null === (i2 = this.actions[t3]) || void 0 === i2 || null === (i2 = i2.perform) || void 0 === i2 ? void 0 : i2.call(this);
      var i2;
    }
    actionIsExternal(t3) {
      return /^x-./.test(t3);
    }
    getCurrentActions() {
      const t3 = {};
      for (const e2 in this.actions) t3[e2] = this.canInvokeAction(e2);
      return t3;
    }
    updateCurrentActions() {
      const t3 = this.getCurrentActions();
      if (!Tt(t3, this.currentActions)) return this.currentActions = t3, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions });
    }
    runEditorFilters() {
      let t3 = this.composition.getSnapshot();
      if (Array.from(this.editor.filters).forEach((e3) => {
        const { document: i3, selectedRange: n2 } = t3;
        t3 = e3.call(this.editor, t3) || {}, t3.document || (t3.document = i3), t3.selectedRange || (t3.selectedRange = n2);
      }), e2 = t3, i2 = this.composition.getSnapshot(), !Dt(e2.selectedRange, i2.selectedRange) || !e2.document.isEqualTo(i2.document)) return this.composition.loadSnapshot(t3);
      var e2, i2;
    }
    updateInputElement() {
      const t3 = function(t4, e2) {
        const i2 = En[e2];
        if (i2) return i2(t4);
        throw new Error("unknown content type: ".concat(e2));
      }(this.compositionController.getSerializableElement(), "text/html");
      return this.editorElement.setFormValue(t3);
    }
    notifyEditorElement(t3, e2) {
      switch (t3) {
        case "document-change":
          this.documentChangedSinceLastRender = true;
          break;
        case "render":
          this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
          break;
        case "change":
        case "attachment-add":
        case "attachment-edit":
        case "attachment-remove":
          this.updateInputElement();
      }
      return this.editorElement.notify(t3, e2);
    }
    removeAttachment(t3) {
      return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t3), this.render();
    }
    recordFormattingUndoEntry(t3) {
      const e2 = mt(t3), i2 = this.selectionManager.getLocationRange();
      if (e2 || !Lt(i2)) return this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true });
    }
    recordTypingUndoEntry() {
      return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
    }
    getUndoContext() {
      for (var t3 = arguments.length, e2 = new Array(t3), i2 = 0; i2 < t3; i2++) e2[i2] = arguments[i2];
      return [this.getLocationContext(), this.getTimeContext(), ...Array.from(e2)];
    }
    getLocationContext() {
      const t3 = this.selectionManager.getLocationRange();
      return Lt(t3) ? t3[0].index : t3;
    }
    getTimeContext() {
      return V.interval > 0 ? Math.floor((/* @__PURE__ */ new Date()).getTime() / V.interval) : 0;
    }
    isFocused() {
      var t3;
      return this.editorElement === (null === (t3 = this.editorElement.ownerDocument) || void 0 === t3 ? void 0 : t3.activeElement);
    }
    isFocusedInvisibly() {
      return this.isFocused() && !this.getLocationRange();
    }
    get actions() {
      return this.constructor.actions;
    }
  };
  Di(_r, "actions", { undo: { test() {
    return this.editor.canUndo();
  }, perform() {
    return this.editor.undo();
  } }, redo: { test() {
    return this.editor.canRedo();
  }, perform() {
    return this.editor.redo();
  } }, link: { test() {
    return this.editor.canActivateAttribute("href");
  } }, increaseNestingLevel: { test() {
    return this.editor.canIncreaseNestingLevel();
  }, perform() {
    return this.editor.increaseNestingLevel() && this.render();
  } }, decreaseNestingLevel: { test() {
    return this.editor.canDecreaseNestingLevel();
  }, perform() {
    return this.editor.decreaseNestingLevel() && this.render();
  } }, attachFiles: { test: () => true, perform() {
    return _.pickFiles(this.editor.insertFiles);
  } } }), _r.proxyMethod("getSelectionManager().setLocationRange"), _r.proxyMethod("getSelectionManager().getLocationRange");
  var jr = Object.freeze({ __proto__: null, AttachmentEditorController: Yn, CompositionController: Xn, Controller: $n, EditorController: _r, InputController: lr, Level0InputController: gr, Level2InputController: Ar, ToolbarController: Br });
  var Wr = Object.freeze({ __proto__: null, MutationObserver: er, SelectionChangeObserver: Ot });
  var Ur = Object.freeze({ __proto__: null, FileVerificationOperation: nr, ImagePreloadOperation: Ui });
  vt("trix-toolbar", "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}");
  var Vr = class extends HTMLElement {
    connectedCallback() {
      "" === this.innerHTML && (this.innerHTML = U.getDefaultHTML());
    }
  };
  var zr = 0;
  var qr = function(t3) {
    if (!t3.hasAttribute("contenteditable")) return t3.setAttribute("contenteditable", ""), function(t4) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return e2.times = 1, b(t4, e2);
    }("focus", { onElement: t3, withCallback: () => Hr(t3) });
  };
  var Hr = function(t3) {
    return Jr(t3), Kr(t3);
  };
  var Jr = function(t3) {
    var e2, i2;
    if (null !== (e2 = (i2 = document).queryCommandSupported) && void 0 !== e2 && e2.call(i2, "enableObjectResizing")) return document.execCommand("enableObjectResizing", false, false), b("mscontrolselect", { onElement: t3, preventDefault: true });
  };
  var Kr = function(t3) {
    var e2, i2;
    if (null !== (e2 = (i2 = document).queryCommandSupported) && void 0 !== e2 && e2.call(i2, "DefaultParagraphSeparator")) {
      const { tagName: t4 } = n.default;
      if (["div", "p"].includes(t4)) return document.execCommand("DefaultParagraphSeparator", false, t4);
    }
  };
  var Gr = a.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
  vt("trix-editor", "%t {\n    display: block;\n}\n\n%t:empty::before {\n    content: attr(placeholder);\n    color: graytext;\n    cursor: text;\n    pointer-events: none;\n    white-space: pre-line;\n}\n\n%t a[contenteditable=false] {\n    cursor: text;\n}\n\n%t img {\n    max-width: 100%;\n    height: auto;\n}\n\n%t ".concat(e, " figcaption textarea {\n    resize: none;\n}\n\n%t ").concat(e, " figcaption textarea.trix-autoresize-clone {\n    position: absolute;\n    left: -9999px;\n    max-height: 0px;\n}\n\n%t ").concat(e, " figcaption[data-trix-placeholder]:empty::before {\n    content: attr(data-trix-placeholder);\n    color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n    display: ").concat(Gr.display, " !important;\n    width: ").concat(Gr.width, " !important;\n    padding: 0 !important;\n    margin: 0 !important;\n    border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n    vertical-align: top !important;\n    margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n    vertical-align: bottom !important;\n    margin-right: -1px !important;\n}"));
  var Yr = /* @__PURE__ */ new WeakMap();
  var Xr = /* @__PURE__ */ new WeakSet();
  var $r = class {
    constructor(t3) {
      var e2, i2;
      _i(e2 = this, i2 = Xr), i2.add(e2), ji(this, Yr, { writable: true, value: void 0 }), this.element = t3, Oi(this, Yr, t3.attachInternals());
    }
    connectedCallback() {
      Bi(this, Xr, Zr).call(this);
    }
    disconnectedCallback() {
    }
    get labels() {
      return Ii(this, Yr).labels;
    }
    get disabled() {
      var t3;
      return null === (t3 = this.element.inputElement) || void 0 === t3 ? void 0 : t3.disabled;
    }
    set disabled(t3) {
      this.element.toggleAttribute("disabled", t3);
    }
    get required() {
      return this.element.hasAttribute("required");
    }
    set required(t3) {
      this.element.toggleAttribute("required", t3), Bi(this, Xr, Zr).call(this);
    }
    get validity() {
      return Ii(this, Yr).validity;
    }
    get validationMessage() {
      return Ii(this, Yr).validationMessage;
    }
    get willValidate() {
      return Ii(this, Yr).willValidate;
    }
    setFormValue(t3) {
      Bi(this, Xr, Zr).call(this);
    }
    checkValidity() {
      return Ii(this, Yr).checkValidity();
    }
    reportValidity() {
      return Ii(this, Yr).reportValidity();
    }
    setCustomValidity(t3) {
      Bi(this, Xr, Zr).call(this, t3);
    }
  };
  function Zr() {
    let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const { required: e2, value: i2 } = this.element, n2 = e2 && !i2, r2 = !!t3, o2 = T("input", { required: e2 }), s2 = t3 || o2.validationMessage;
    Ii(this, Yr).setValidity({ valueMissing: n2, customError: r2 }, s2);
  }
  var Qr = /* @__PURE__ */ new WeakMap();
  var to = /* @__PURE__ */ new WeakMap();
  var eo = /* @__PURE__ */ new WeakMap();
  var io = class {
    constructor(t3) {
      ji(this, Qr, { writable: true, value: void 0 }), ji(this, to, { writable: true, value: (t4) => {
        t4.defaultPrevented || t4.target === this.element.form && this.element.reset();
      } }), ji(this, eo, { writable: true, value: (t4) => {
        if (t4.defaultPrevented) return;
        if (this.element.contains(t4.target)) return;
        const e2 = y(t4.target, { matchingSelector: "label" });
        e2 && Array.from(this.labels).includes(e2) && this.element.focus();
      } }), this.element = t3;
    }
    connectedCallback() {
      Oi(this, Qr, function(t3) {
        if (t3.hasAttribute("aria-label") || t3.hasAttribute("aria-labelledby")) return;
        const e2 = function() {
          const e3 = Array.from(t3.labels).map((e4) => {
            if (!e4.contains(t3)) return e4.textContent;
          }).filter((t4) => t4), i2 = e3.join(" ");
          return i2 ? t3.setAttribute("aria-label", i2) : t3.removeAttribute("aria-label");
        };
        return e2(), b("focus", { onElement: t3, withCallback: e2 });
      }(this.element)), window.addEventListener("reset", Ii(this, to), false), window.addEventListener("click", Ii(this, eo), false);
    }
    disconnectedCallback() {
      var t3;
      null === (t3 = Ii(this, Qr)) || void 0 === t3 || t3.destroy(), window.removeEventListener("reset", Ii(this, to), false), window.removeEventListener("click", Ii(this, eo), false);
    }
    get labels() {
      const t3 = [];
      this.element.id && this.element.ownerDocument && t3.push(...Array.from(this.element.ownerDocument.querySelectorAll("label[for='".concat(this.element.id, "']")) || []));
      const e2 = y(this.element, { matchingSelector: "label" });
      return e2 && [this.element, null].includes(e2.control) && t3.push(e2), t3;
    }
    get disabled() {
      return console.warn("This browser does not support the [disabled] attribute for trix-editor elements."), false;
    }
    set disabled(t3) {
      console.warn("This browser does not support the [disabled] attribute for trix-editor elements.");
    }
    get required() {
      return console.warn("This browser does not support the [required] attribute for trix-editor elements."), false;
    }
    set required(t3) {
      console.warn("This browser does not support the [required] attribute for trix-editor elements.");
    }
    get validity() {
      return console.warn("This browser does not support the validity property for trix-editor elements."), null;
    }
    get validationMessage() {
      return console.warn("This browser does not support the validationMessage property for trix-editor elements."), "";
    }
    get willValidate() {
      return console.warn("This browser does not support the willValidate property for trix-editor elements."), false;
    }
    setFormValue(t3) {
    }
    checkValidity() {
      return console.warn("This browser does not support checkValidity() for trix-editor elements."), true;
    }
    reportValidity() {
      return console.warn("This browser does not support reportValidity() for trix-editor elements."), true;
    }
    setCustomValidity(t3) {
      console.warn("This browser does not support setCustomValidity(validationMessage) for trix-editor elements.");
    }
  };
  var no = /* @__PURE__ */ new WeakMap();
  var ro = class extends HTMLElement {
    constructor() {
      super(), ji(this, no, { writable: true, value: void 0 }), Oi(this, no, this.constructor.formAssociated ? new $r(this) : new io(this));
    }
    get trixId() {
      return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++zr), this.trixId);
    }
    get labels() {
      return Ii(this, no).labels;
    }
    get disabled() {
      return Ii(this, no).disabled;
    }
    set disabled(t3) {
      Ii(this, no).disabled = t3;
    }
    get required() {
      return Ii(this, no).required;
    }
    set required(t3) {
      Ii(this, no).required = t3;
    }
    get validity() {
      return Ii(this, no).validity;
    }
    get validationMessage() {
      return Ii(this, no).validationMessage;
    }
    get willValidate() {
      return Ii(this, no).willValidate;
    }
    get type() {
      return this.localName;
    }
    get toolbarElement() {
      var t3;
      if (this.hasAttribute("toolbar")) return null === (t3 = this.ownerDocument) || void 0 === t3 ? void 0 : t3.getElementById(this.getAttribute("toolbar"));
      if (this.parentNode) {
        const t4 = "trix-toolbar-".concat(this.trixId);
        return this.setAttribute("toolbar", t4), this.internalToolbar = T("trix-toolbar", { id: t4 }), this.parentNode.insertBefore(this.internalToolbar, this), this.internalToolbar;
      }
    }
    get form() {
      var t3;
      return null === (t3 = this.inputElement) || void 0 === t3 ? void 0 : t3.form;
    }
    get inputElement() {
      var t3;
      if (this.hasAttribute("input")) return null === (t3 = this.ownerDocument) || void 0 === t3 ? void 0 : t3.getElementById(this.getAttribute("input"));
      if (this.parentNode) {
        const t4 = "trix-input-".concat(this.trixId);
        this.setAttribute("input", t4);
        const e2 = T("input", { type: "hidden", id: t4 });
        return this.parentNode.insertBefore(e2, this.nextElementSibling), e2;
      }
    }
    get editor() {
      var t3;
      return null === (t3 = this.editorController) || void 0 === t3 ? void 0 : t3.editor;
    }
    get name() {
      var t3;
      return null === (t3 = this.inputElement) || void 0 === t3 ? void 0 : t3.name;
    }
    get value() {
      var t3;
      return null === (t3 = this.inputElement) || void 0 === t3 ? void 0 : t3.value;
    }
    set value(t3) {
      var e2;
      this.defaultValue = t3, null === (e2 = this.editor) || void 0 === e2 || e2.loadHTML(this.defaultValue);
    }
    attributeChangedCallback(t3, e2, i2) {
      "connected" === t3 && this.isConnected && null != e2 && e2 !== i2 && requestAnimationFrame(() => this.reconnect());
    }
    notify(t3, e2) {
      if (this.editorController) return v("trix-".concat(t3), { onElement: this, attributes: e2 });
    }
    setFormValue(t3) {
      this.inputElement && (this.inputElement.value = t3, Ii(this, no).setFormValue(t3));
    }
    connectedCallback() {
      this.hasAttribute("data-trix-internal") || (qr(this), function(t3) {
        if (!t3.hasAttribute("role")) t3.setAttribute("role", "textbox");
      }(this), this.editorController || (v("trix-before-initialize", { onElement: this }), this.editorController = new _r({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(() => v("trix-initialize", { onElement: this }))), this.editorController.registerSelectionManager(), Ii(this, no).connectedCallback(), this.toggleAttribute("connected", true), function(t3) {
        if (!document.querySelector(":focus") && t3.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t3) t3.focus();
      }(this));
    }
    disconnectedCallback() {
      var t3;
      null === (t3 = this.editorController) || void 0 === t3 || t3.unregisterSelectionManager(), Ii(this, no).disconnectedCallback(), this.toggleAttribute("connected", false);
    }
    reconnect() {
      this.removeInternalToolbar(), this.disconnectedCallback(), this.connectedCallback();
    }
    removeInternalToolbar() {
      var t3;
      null === (t3 = this.internalToolbar) || void 0 === t3 || t3.remove(), this.internalToolbar = null;
    }
    checkValidity() {
      return Ii(this, no).checkValidity();
    }
    reportValidity() {
      return Ii(this, no).reportValidity();
    }
    setCustomValidity(t3) {
      Ii(this, no).setCustomValidity(t3);
    }
    formDisabledCallback(t3) {
      this.inputElement && (this.inputElement.disabled = t3), this.toggleAttribute("contenteditable", !t3);
    }
    formResetCallback() {
      this.reset();
    }
    reset() {
      this.value = this.defaultValue;
    }
  };
  Di(ro, "formAssociated", "ElementInternals" in window), Di(ro, "observedAttributes", ["connected"]);
  var oo = { VERSION: t, config: z, core: Sn, models: zn, views: qn, controllers: jr, observers: Wr, operations: Ur, elements: Object.freeze({ __proto__: null, TrixEditorElement: ro, TrixToolbarElement: Vr }), filters: Object.freeze({ __proto__: null, Filter: In, attachmentGalleryFilter: On }) };
  Object.assign(oo, zn), window.Trix = oo, setTimeout(function() {
    customElements.get("trix-toolbar") || customElements.define("trix-toolbar", Vr), customElements.get("trix-editor") || customElements.define("trix-editor", ro);
  }, 0);

  // node_modules/@rails/actiontext/app/assets/javascripts/actiontext.esm.js
  var sparkMd5 = {
    exports: {}
  };
  (function(module, exports) {
    (function(factory) {
      {
        module.exports = factory();
      }
    })(function(undefined$1) {
      var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function md5cycle(x2, k2) {
        var a2 = x2[0], b2 = x2[1], c2 = x2[2], d2 = x2[3];
        a2 += (b2 & c2 | ~b2 & d2) + k2[0] - 680876936 | 0;
        a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
        d2 += (a2 & b2 | ~a2 & c2) + k2[1] - 389564586 | 0;
        d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
        c2 += (d2 & a2 | ~d2 & b2) + k2[2] + 606105819 | 0;
        c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
        b2 += (c2 & d2 | ~c2 & a2) + k2[3] - 1044525330 | 0;
        b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
        a2 += (b2 & c2 | ~b2 & d2) + k2[4] - 176418897 | 0;
        a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
        d2 += (a2 & b2 | ~a2 & c2) + k2[5] + 1200080426 | 0;
        d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
        c2 += (d2 & a2 | ~d2 & b2) + k2[6] - 1473231341 | 0;
        c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
        b2 += (c2 & d2 | ~c2 & a2) + k2[7] - 45705983 | 0;
        b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
        a2 += (b2 & c2 | ~b2 & d2) + k2[8] + 1770035416 | 0;
        a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
        d2 += (a2 & b2 | ~a2 & c2) + k2[9] - 1958414417 | 0;
        d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
        c2 += (d2 & a2 | ~d2 & b2) + k2[10] - 42063 | 0;
        c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
        b2 += (c2 & d2 | ~c2 & a2) + k2[11] - 1990404162 | 0;
        b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
        a2 += (b2 & c2 | ~b2 & d2) + k2[12] + 1804603682 | 0;
        a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
        d2 += (a2 & b2 | ~a2 & c2) + k2[13] - 40341101 | 0;
        d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
        c2 += (d2 & a2 | ~d2 & b2) + k2[14] - 1502002290 | 0;
        c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
        b2 += (c2 & d2 | ~c2 & a2) + k2[15] + 1236535329 | 0;
        b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
        a2 += (b2 & d2 | c2 & ~d2) + k2[1] - 165796510 | 0;
        a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
        d2 += (a2 & c2 | b2 & ~c2) + k2[6] - 1069501632 | 0;
        d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
        c2 += (d2 & b2 | a2 & ~b2) + k2[11] + 643717713 | 0;
        c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
        b2 += (c2 & a2 | d2 & ~a2) + k2[0] - 373897302 | 0;
        b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
        a2 += (b2 & d2 | c2 & ~d2) + k2[5] - 701558691 | 0;
        a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
        d2 += (a2 & c2 | b2 & ~c2) + k2[10] + 38016083 | 0;
        d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
        c2 += (d2 & b2 | a2 & ~b2) + k2[15] - 660478335 | 0;
        c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
        b2 += (c2 & a2 | d2 & ~a2) + k2[4] - 405537848 | 0;
        b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
        a2 += (b2 & d2 | c2 & ~d2) + k2[9] + 568446438 | 0;
        a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
        d2 += (a2 & c2 | b2 & ~c2) + k2[14] - 1019803690 | 0;
        d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
        c2 += (d2 & b2 | a2 & ~b2) + k2[3] - 187363961 | 0;
        c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
        b2 += (c2 & a2 | d2 & ~a2) + k2[8] + 1163531501 | 0;
        b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
        a2 += (b2 & d2 | c2 & ~d2) + k2[13] - 1444681467 | 0;
        a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
        d2 += (a2 & c2 | b2 & ~c2) + k2[2] - 51403784 | 0;
        d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
        c2 += (d2 & b2 | a2 & ~b2) + k2[7] + 1735328473 | 0;
        c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
        b2 += (c2 & a2 | d2 & ~a2) + k2[12] - 1926607734 | 0;
        b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
        a2 += (b2 ^ c2 ^ d2) + k2[5] - 378558 | 0;
        a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
        d2 += (a2 ^ b2 ^ c2) + k2[8] - 2022574463 | 0;
        d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
        c2 += (d2 ^ a2 ^ b2) + k2[11] + 1839030562 | 0;
        c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
        b2 += (c2 ^ d2 ^ a2) + k2[14] - 35309556 | 0;
        b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
        a2 += (b2 ^ c2 ^ d2) + k2[1] - 1530992060 | 0;
        a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
        d2 += (a2 ^ b2 ^ c2) + k2[4] + 1272893353 | 0;
        d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
        c2 += (d2 ^ a2 ^ b2) + k2[7] - 155497632 | 0;
        c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
        b2 += (c2 ^ d2 ^ a2) + k2[10] - 1094730640 | 0;
        b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
        a2 += (b2 ^ c2 ^ d2) + k2[13] + 681279174 | 0;
        a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
        d2 += (a2 ^ b2 ^ c2) + k2[0] - 358537222 | 0;
        d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
        c2 += (d2 ^ a2 ^ b2) + k2[3] - 722521979 | 0;
        c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
        b2 += (c2 ^ d2 ^ a2) + k2[6] + 76029189 | 0;
        b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
        a2 += (b2 ^ c2 ^ d2) + k2[9] - 640364487 | 0;
        a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
        d2 += (a2 ^ b2 ^ c2) + k2[12] - 421815835 | 0;
        d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
        c2 += (d2 ^ a2 ^ b2) + k2[15] + 530742520 | 0;
        c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
        b2 += (c2 ^ d2 ^ a2) + k2[2] - 995338651 | 0;
        b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
        a2 += (c2 ^ (b2 | ~d2)) + k2[0] - 198630844 | 0;
        a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
        d2 += (b2 ^ (a2 | ~c2)) + k2[7] + 1126891415 | 0;
        d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
        c2 += (a2 ^ (d2 | ~b2)) + k2[14] - 1416354905 | 0;
        c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
        b2 += (d2 ^ (c2 | ~a2)) + k2[5] - 57434055 | 0;
        b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
        a2 += (c2 ^ (b2 | ~d2)) + k2[12] + 1700485571 | 0;
        a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
        d2 += (b2 ^ (a2 | ~c2)) + k2[3] - 1894986606 | 0;
        d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
        c2 += (a2 ^ (d2 | ~b2)) + k2[10] - 1051523 | 0;
        c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
        b2 += (d2 ^ (c2 | ~a2)) + k2[1] - 2054922799 | 0;
        b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
        a2 += (c2 ^ (b2 | ~d2)) + k2[8] + 1873313359 | 0;
        a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
        d2 += (b2 ^ (a2 | ~c2)) + k2[15] - 30611744 | 0;
        d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
        c2 += (a2 ^ (d2 | ~b2)) + k2[6] - 1560198380 | 0;
        c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
        b2 += (d2 ^ (c2 | ~a2)) + k2[13] + 1309151649 | 0;
        b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
        a2 += (c2 ^ (b2 | ~d2)) + k2[4] - 145523070 | 0;
        a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
        d2 += (b2 ^ (a2 | ~c2)) + k2[11] - 1120210379 | 0;
        d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
        c2 += (a2 ^ (d2 | ~b2)) + k2[2] + 718787259 | 0;
        c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
        b2 += (d2 ^ (c2 | ~a2)) + k2[9] - 343485551 | 0;
        b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
        x2[0] = a2 + x2[0] | 0;
        x2[1] = b2 + x2[1] | 0;
        x2[2] = c2 + x2[2] | 0;
        x2[3] = d2 + x2[3] | 0;
      }
      function md5blk(s2) {
        var md5blks = [], i2;
        for (i2 = 0; i2 < 64; i2 += 4) {
          md5blks[i2 >> 2] = s2.charCodeAt(i2) + (s2.charCodeAt(i2 + 1) << 8) + (s2.charCodeAt(i2 + 2) << 16) + (s2.charCodeAt(i2 + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a2) {
        var md5blks = [], i2;
        for (i2 = 0; i2 < 64; i2 += 4) {
          md5blks[i2 >> 2] = a2[i2] + (a2[i2 + 1] << 8) + (a2[i2 + 2] << 16) + (a2[i2 + 3] << 24);
        }
        return md5blks;
      }
      function md51(s2) {
        var n2 = s2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi2;
        for (i2 = 64; i2 <= n2; i2 += 64) {
          md5cycle(state, md5blk(s2.substring(i2 - 64, i2)));
        }
        s2 = s2.substring(i2 - 64);
        length = s2.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i2 = 0; i2 < length; i2 += 1) {
          tail[i2 >> 2] |= s2.charCodeAt(i2) << (i2 % 4 << 3);
        }
        tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
        if (i2 > 55) {
          md5cycle(state, tail);
          for (i2 = 0; i2 < 16; i2 += 1) {
            tail[i2] = 0;
          }
        }
        tmp = n2 * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi2 = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi2;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a2) {
        var n2 = a2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi2;
        for (i2 = 64; i2 <= n2; i2 += 64) {
          md5cycle(state, md5blk_array(a2.subarray(i2 - 64, i2)));
        }
        a2 = i2 - 64 < n2 ? a2.subarray(i2 - 64) : new Uint8Array(0);
        length = a2.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i2 = 0; i2 < length; i2 += 1) {
          tail[i2 >> 2] |= a2[i2] << (i2 % 4 << 3);
        }
        tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
        if (i2 > 55) {
          md5cycle(state, tail);
          for (i2 = 0; i2 < 16; i2 += 1) {
            tail[i2] = 0;
          }
        }
        tmp = n2 * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi2 = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi2;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n2) {
        var s2 = "", j2;
        for (j2 = 0; j2 < 4; j2 += 1) {
          s2 += hex_chr[n2 >> j2 * 8 + 4 & 15] + hex_chr[n2 >> j2 * 8 & 15];
        }
        return s2;
      }
      function hex(x2) {
        var i2;
        for (i2 = 0; i2 < x2.length; i2 += 1) {
          x2[i2] = rhex(x2[i2]);
        }
        return x2.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") ;
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to2) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
            if (to2 !== undefined$1) {
              end = clamp(to2, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i2;
        for (i2 = 0; i2 < length; i2 += 1) {
          arr[i2] = str.charCodeAt(i2);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes = [], length = hex2.length, x2;
        for (x2 = 0; x2 < length - 1; x2 += 2) {
          bytes.push(parseInt(hex2.substr(x2, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes);
      }
      function SparkMD52() {
        this.reset();
      }
      SparkMD52.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD52.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i2;
        for (i2 = 64; i2 <= length; i2 += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i2 - 64, i2)));
        }
        this._buff = this._buff.substring(i2 - 64);
        return this;
      };
      SparkMD52.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i2, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i2 = 0; i2 < length; i2 += 1) {
          tail[i2 >> 2] |= buff.charCodeAt(i2) << (i2 % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD52.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD52.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD52.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD52.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD52.prototype._finish = function(tail, length) {
        var i2 = length, tmp, lo, hi2;
        tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
        if (i2 > 55) {
          md5cycle(this._hash, tail);
          for (i2 = 0; i2 < 16; i2 += 1) {
            tail[i2] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi2 = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi2;
        md5cycle(this._hash, tail);
      };
      SparkMD52.hash = function(str, raw) {
        return SparkMD52.hashBinary(toUtf8(str), raw);
      };
      SparkMD52.hashBinary = function(content, raw) {
        var hash = md51(content), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD52.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD52.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i2;
        this._length += arr.byteLength;
        for (i2 = 64; i2 <= length; i2 += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i2 - 64, i2)));
        }
        this._buff = i2 - 64 < length ? new Uint8Array(buff.buffer.slice(i2 - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD52.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i2, ret;
        for (i2 = 0; i2 < length; i2 += 1) {
          tail[i2 >> 2] |= buff[i2] << (i2 % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD52.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD52.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD52.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD52.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD52.prototype.setState.call(this, state);
      };
      SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
      SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
      SparkMD52.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD52;
    });
  })(sparkMd5);
  var SparkMD5 = sparkMd5.exports;
  var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
  var FileChecksum = class _FileChecksum {
    static create(file, callback) {
      const instance = new _FileChecksum(file);
      instance.create(callback);
    }
    constructor(file) {
      this.file = file;
      this.chunkSize = 2097152;
      this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
      this.chunkIndex = 0;
    }
    create(callback) {
      this.callback = callback;
      this.md5Buffer = new SparkMD5.ArrayBuffer();
      this.fileReader = new FileReader();
      this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
      this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
      this.readNextChunk();
    }
    fileReaderDidLoad(event) {
      this.md5Buffer.append(event.target.result);
      if (!this.readNextChunk()) {
        const binaryDigest = this.md5Buffer.end(true);
        const base64digest = btoa(binaryDigest);
        this.callback(null, base64digest);
      }
    }
    fileReaderDidError(event) {
      this.callback(`Error reading ${this.file.name}`);
    }
    readNextChunk() {
      if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
        const start3 = this.chunkIndex * this.chunkSize;
        const end = Math.min(start3 + this.chunkSize, this.file.size);
        const bytes = fileSlice.call(this.file, start3, end);
        this.fileReader.readAsArrayBuffer(bytes);
        this.chunkIndex++;
        return true;
      } else {
        return false;
      }
    }
  };
  function getMetaValue(name) {
    const element = findElement(document.head, `meta[name="${name}"]`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  function findElements(root, selector) {
    if (typeof root == "string") {
      selector = root;
      root = document;
    }
    const elements = root.querySelectorAll(selector);
    return toArray(elements);
  }
  function findElement(root, selector) {
    if (typeof root == "string") {
      selector = root;
      root = document;
    }
    return root.querySelector(selector);
  }
  function dispatchEvent2(element, type, eventInit = {}) {
    const { disabled } = element;
    const { bubbles, cancelable, detail } = eventInit;
    const event = document.createEvent("Event");
    event.initEvent(type, bubbles || true, cancelable || true);
    event.detail = detail || {};
    try {
      element.disabled = false;
      element.dispatchEvent(event);
    } finally {
      element.disabled = disabled;
    }
    return event;
  }
  function toArray(value) {
    if (Array.isArray(value)) {
      return value;
    } else if (Array.from) {
      return Array.from(value);
    } else {
      return [].slice.call(value);
    }
  }
  var BlobRecord = class {
    constructor(file, checksum, url, customHeaders = {}) {
      this.file = file;
      this.attributes = {
        filename: file.name,
        content_type: file.type || "application/octet-stream",
        byte_size: file.size,
        checksum
      };
      this.xhr = new XMLHttpRequest();
      this.xhr.open("POST", url, true);
      this.xhr.responseType = "json";
      this.xhr.setRequestHeader("Content-Type", "application/json");
      this.xhr.setRequestHeader("Accept", "application/json");
      this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      Object.keys(customHeaders).forEach((headerKey) => {
        this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
      });
      const csrfToken = getMetaValue("csrf-token");
      if (csrfToken != void 0) {
        this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
      }
      this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
      this.xhr.addEventListener("error", (event) => this.requestDidError(event));
    }
    get status() {
      return this.xhr.status;
    }
    get response() {
      const { responseType, response } = this.xhr;
      if (responseType == "json") {
        return response;
      } else {
        return JSON.parse(response);
      }
    }
    create(callback) {
      this.callback = callback;
      this.xhr.send(JSON.stringify({
        blob: this.attributes
      }));
    }
    requestDidLoad(event) {
      if (this.status >= 200 && this.status < 300) {
        const { response } = this;
        const { direct_upload } = response;
        delete response.direct_upload;
        this.attributes = response;
        this.directUploadData = direct_upload;
        this.callback(null, this.toJSON());
      } else {
        this.requestDidError(event);
      }
    }
    requestDidError(event) {
      this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
    }
    toJSON() {
      const result = {};
      for (const key in this.attributes) {
        result[key] = this.attributes[key];
      }
      return result;
    }
  };
  var BlobUpload = class {
    constructor(blob) {
      this.blob = blob;
      this.file = blob.file;
      const { url, headers } = blob.directUploadData;
      this.xhr = new XMLHttpRequest();
      this.xhr.open("PUT", url, true);
      this.xhr.responseType = "text";
      for (const key in headers) {
        this.xhr.setRequestHeader(key, headers[key]);
      }
      this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
      this.xhr.addEventListener("error", (event) => this.requestDidError(event));
    }
    create(callback) {
      this.callback = callback;
      this.xhr.send(this.file.slice());
    }
    requestDidLoad(event) {
      const { status, response } = this.xhr;
      if (status >= 200 && status < 300) {
        this.callback(null, response);
      } else {
        this.requestDidError(event);
      }
    }
    requestDidError(event) {
      this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
    }
  };
  var id = 0;
  var DirectUpload = class {
    constructor(file, url, delegate, customHeaders = {}) {
      this.id = ++id;
      this.file = file;
      this.url = url;
      this.delegate = delegate;
      this.customHeaders = customHeaders;
    }
    create(callback) {
      FileChecksum.create(this.file, (error2, checksum) => {
        if (error2) {
          callback(error2);
          return;
        }
        const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);
        notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
        blob.create((error3) => {
          if (error3) {
            callback(error3);
          } else {
            const upload = new BlobUpload(blob);
            notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
            upload.create((error4) => {
              if (error4) {
                callback(error4);
              } else {
                callback(null, blob.toJSON());
              }
            });
          }
        });
      });
    }
  };
  function notify(object, methodName, ...messages) {
    if (object && typeof object[methodName] == "function") {
      return object[methodName](...messages);
    }
  }
  var DirectUploadController = class {
    constructor(input, file) {
      this.input = input;
      this.file = file;
      this.directUpload = new DirectUpload(this.file, this.url, this);
      this.dispatch("initialize");
    }
    start(callback) {
      const hiddenInput = document.createElement("input");
      hiddenInput.type = "hidden";
      hiddenInput.name = this.input.name;
      this.input.insertAdjacentElement("beforebegin", hiddenInput);
      this.dispatch("start");
      this.directUpload.create((error2, attributes) => {
        if (error2) {
          hiddenInput.parentNode.removeChild(hiddenInput);
          this.dispatchError(error2);
        } else {
          hiddenInput.value = attributes.signed_id;
        }
        this.dispatch("end");
        callback(error2);
      });
    }
    uploadRequestDidProgress(event) {
      const progress = event.loaded / event.total * 100;
      if (progress) {
        this.dispatch("progress", {
          progress
        });
      }
    }
    get url() {
      return this.input.getAttribute("data-direct-upload-url");
    }
    dispatch(name, detail = {}) {
      detail.file = this.file;
      detail.id = this.directUpload.id;
      return dispatchEvent2(this.input, `direct-upload:${name}`, {
        detail
      });
    }
    dispatchError(error2) {
      const event = this.dispatch("error", {
        error: error2
      });
      if (!event.defaultPrevented) {
        alert(error2);
      }
    }
    directUploadWillCreateBlobWithXHR(xhr) {
      this.dispatch("before-blob-request", {
        xhr
      });
    }
    directUploadWillStoreFileWithXHR(xhr) {
      this.dispatch("before-storage-request", {
        xhr
      });
      xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
    }
  };
  var inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";
  var DirectUploadsController = class {
    constructor(form) {
      this.form = form;
      this.inputs = findElements(form, inputSelector).filter((input) => input.files.length);
    }
    start(callback) {
      const controllers = this.createDirectUploadControllers();
      const startNextController = () => {
        const controller = controllers.shift();
        if (controller) {
          controller.start((error2) => {
            if (error2) {
              callback(error2);
              this.dispatch("end");
            } else {
              startNextController();
            }
          });
        } else {
          callback();
          this.dispatch("end");
        }
      };
      this.dispatch("start");
      startNextController();
    }
    createDirectUploadControllers() {
      const controllers = [];
      this.inputs.forEach((input) => {
        toArray(input.files).forEach((file) => {
          const controller = new DirectUploadController(input, file);
          controllers.push(controller);
        });
      });
      return controllers;
    }
    dispatch(name, detail = {}) {
      return dispatchEvent2(this.form, `direct-uploads:${name}`, {
        detail
      });
    }
  };
  var processingAttribute = "data-direct-uploads-processing";
  var submitButtonsByForm = /* @__PURE__ */ new WeakMap();
  var started = false;
  function start() {
    if (!started) {
      started = true;
      document.addEventListener("click", didClick, true);
      document.addEventListener("submit", didSubmitForm, true);
      document.addEventListener("ajax:before", didSubmitRemoteElement);
    }
  }
  function didClick(event) {
    const button = event.target.closest("button, input");
    if (button && button.type === "submit" && button.form) {
      submitButtonsByForm.set(button.form, button);
    }
  }
  function didSubmitForm(event) {
    handleFormSubmissionEvent(event);
  }
  function didSubmitRemoteElement(event) {
    if (event.target.tagName == "FORM") {
      handleFormSubmissionEvent(event);
    }
  }
  function handleFormSubmissionEvent(event) {
    const form = event.target;
    if (form.hasAttribute(processingAttribute)) {
      event.preventDefault();
      return;
    }
    const controller = new DirectUploadsController(form);
    const { inputs } = controller;
    if (inputs.length) {
      event.preventDefault();
      form.setAttribute(processingAttribute, "");
      inputs.forEach(disable);
      controller.start((error2) => {
        form.removeAttribute(processingAttribute);
        if (error2) {
          inputs.forEach(enable);
        } else {
          submitForm(form);
        }
      });
    }
  }
  function submitForm(form) {
    let button = submitButtonsByForm.get(form) || findElement(form, "input[type=submit], button[type=submit]");
    if (button) {
      const { disabled } = button;
      button.disabled = false;
      button.focus();
      button.click();
      button.disabled = disabled;
    } else {
      button = document.createElement("input");
      button.type = "submit";
      button.style.display = "none";
      form.appendChild(button);
      button.click();
      form.removeChild(button);
    }
    submitButtonsByForm.delete(form);
  }
  function disable(input) {
    input.disabled = true;
  }
  function enable(input) {
    input.disabled = false;
  }
  function autostart() {
    if (window.ActiveStorage) {
      start();
    }
  }
  setTimeout(autostart, 1);
  var AttachmentUpload = class {
    constructor(attachment, element) {
      this.attachment = attachment;
      this.element = element;
      this.directUpload = new DirectUpload(attachment.file, this.directUploadUrl, this);
    }
    start() {
      this.directUpload.create(this.directUploadDidComplete.bind(this));
      this.dispatch("start");
    }
    directUploadWillStoreFileWithXHR(xhr) {
      xhr.upload.addEventListener("progress", (event) => {
        const progress = event.loaded / event.total * 100;
        this.attachment.setUploadProgress(progress);
        if (progress) {
          this.dispatch("progress", {
            progress
          });
        }
      });
    }
    directUploadDidComplete(error2, attributes) {
      if (error2) {
        this.dispatchError(error2);
      } else {
        this.attachment.setAttributes({
          sgid: attributes.attachable_sgid,
          url: this.createBlobUrl(attributes.signed_id, attributes.filename)
        });
        this.dispatch("end");
      }
    }
    createBlobUrl(signedId, filename) {
      return this.blobUrlTemplate.replace(":signed_id", signedId).replace(":filename", encodeURIComponent(filename));
    }
    dispatch(name, detail = {}) {
      detail.attachment = this.attachment;
      return dispatchEvent2(this.element, `direct-upload:${name}`, {
        detail
      });
    }
    dispatchError(error2) {
      const event = this.dispatch("error", {
        error: error2
      });
      if (!event.defaultPrevented) {
        alert(error2);
      }
    }
    get directUploadUrl() {
      return this.element.dataset.directUploadUrl;
    }
    get blobUrlTemplate() {
      return this.element.dataset.blobUrlTemplate;
    }
  };
  addEventListener("trix-attachment-add", (event) => {
    const { attachment, target } = event;
    if (attachment.file) {
      const upload = new AttachmentUpload(attachment, target);
      upload.start();
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start2,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype) return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "complete", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "complete") {
        this.delegate.completeChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter) {
    const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left, right) {
    return expandURL(left).href == expandURL(right).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i2) => {
      const value = values[i2] == void 0 ? "" : values[i2];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_3, i2) => {
      if (i2 == 8 || i2 == 13 || i2 == 18 || i2 == 23) {
        return "-";
      } else if (i2 == 14) {
        return "4";
      } else if (i2 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value == "string") return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
    }
    return true;
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  function debounce(fn2, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = () => fn2.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method,
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod;
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error2)) {
            this.delegate.requestErrored(this, error2);
          }
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented) await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error2) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error2 }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name, value] of requestBody) {
      if (value instanceof File) continue;
      else entries.push([name, value]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver = class {
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    state = FormSubmissionState.initialized;
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      const method = getMethod(formElement, submitter);
      const action = getAction(getFormAction(formElement, submitter), method);
      const body = buildFormData(formElement, submitter);
      const enctype = getEnctype(formElement, submitter);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      this.submitter?.setAttribute("disabled", "");
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      this.submitter?.removeAttribute("disabled");
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith) return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText) return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter?.getAttribute("name");
    const value = submitter?.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function getFormAction(formElement, submitter) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter?.hasAttribute("formaction")) {
      return submitter.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter) {
    const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter) {
    return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id2) {
      return getPermanentElementById(this.element, id2);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id: id2 } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id2);
        if (newPermanentElement) {
          permanentElementMap[id2] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id2) {
    return node.querySelector(`#${id2}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter) {
    if (submitter?.hasAttribute("formtarget") || form.hasAttribute("target")) {
      const target = submitter?.getAttribute("formtarget") || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var View = class {
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x2, y: y2 }) {
      this.scrollRoot.scrollTo(x2, y2);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender) await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.respondsToEventTarget(event.target)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link = findLinkFromClickTarget(target);
        if (link && doesNotTargetIFrame(link)) {
          const location2 = getLocationForLink(link);
          if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method) form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction) form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream) form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id2 in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id2];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id2 in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id2];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id2) {
      return this.placeholders.find((element) => element.content == id2);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    #activeElement = null;
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement) return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class _ProgressBar {
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  var HeadSnapshot = class extends Snapshot {
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone = clonedSelectElements[index];
        for (const option of clone.selectedOptions) option.selected = false;
        for (const option of source.selectedOptions) clone.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root = this.getSetting("root") ?? "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var ViewTransitioner = class {
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot) this.cacheSnapshot();
          if (this.view.renderPromise) await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise) await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      this.frame = await nextRepaint();
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.#findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter) && this.#shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    #shouldSubmit(form, submitter) {
      const action = getAction$1(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.#findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter) {
      const id2 = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id2 && id2 != "_top") {
        const frame = this.element.querySelector(`#${id2}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState) ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started) return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started) return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false") return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link = target;
        const location2 = getLocationForLink(link);
        if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
          this.#prefetchedLink = link;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "get") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link) {
      const href = link.getAttribute("href");
      if (!href) return false;
      if (unfetchableLink(link)) return false;
      if (linkToTheSamePage(link)) return false;
      if (linkOptsOut(link)) return false;
      if (nonSafeLink(link)) return false;
      if (eventPrevented(link)) return false;
      return true;
    }
  };
  var unfetchableLink = (link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  };
  var linkToTheSamePage = (link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  };
  var linkOptsOut = (link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false") return true;
    if (link.getAttribute("data-turbo") === "false") return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
    return false;
  };
  var nonSafeLink = (link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
    if (isUJS(link)) return true;
    if (link.hasAttribute("data-turbo-confirm")) return true;
    if (link.hasAttribute("data-turbo-stream")) return true;
    return false;
  };
  var isUJS = (link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  };
  var eventPrevented = (link) => {
    const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
    return event.defaultPrevented;
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter, formElement } = formSubmission;
      return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id: id2 } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id2);
        if (elementInStream) {
          permanentElementMap[id2] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus) return elementWithAutofocus;
    }
    return null;
  }
  var StreamObserver = class {
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx = createMorphContext(oldNode, normalizedContent, config);
      return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
      if (ctx.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx.morphStyle === "innerHTML") {
        morphChildren(normalizedNewContent, oldNode, ctx);
        return oldNode.children;
      } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    function morphOldNodeTo(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement) ;
      else if (newContent == null) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx.callbacks.afterNodeAdded(newContent);
        ctx.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx);
        } else {
          syncNodeFrom(newContent, oldNode, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren(newContent, oldNode, ctx);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren(newParent, oldParent, ctx) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx)) {
          morphOldNodeTo(insertionPoint, newChild, ctx);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
          morphOldNodeTo(idSetMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
          morphOldNodeTo(softMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx);
      }
    }
    function ignoreAttribute(attr, to2, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && to2 === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, to2, updateType) === false;
    }
    function syncNodeFrom(from, to2, ctx) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to2.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to2, "update", ctx)) {
            continue;
          }
          if (to2.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to2.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i2 = toAttributes.length - 1; 0 <= i2; i2--) {
          const toAttribute = toAttributes[i2];
          if (ignoreAttribute(toAttribute.name, to2, "remove", ctx)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to2.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to2.nodeValue !== from.nodeValue) {
          to2.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to2, ctx)) {
        syncInputValue(from, to2, ctx);
      }
    }
    function syncBooleanAttribute(from, to2, attributeName, ctx) {
      if (from[attributeName] !== to2[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to2, "update", ctx);
        if (!ignoreUpdate) {
          to2[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to2.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to2, "remove", ctx)) {
            to2.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to2, ctx) {
      if (from instanceof HTMLInputElement && to2 instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to2.value;
        syncBooleanAttribute(from, to2, "checked", ctx);
        syncBooleanAttribute(from, to2, "disabled", ctx);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to2, "remove", ctx)) {
            to2.value = "";
            to2.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to2, "update", ctx)) {
            to2.setAttribute("value", fromValue);
            to2.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to2, "selected", ctx);
      } else if (from instanceof HTMLTextAreaElement && to2 instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to2.value;
        if (ignoreAttribute("value", to2, "update", ctx)) {
          return;
        }
        if (fromValue !== toValue) {
          to2.value = fromValue;
        }
        if (to2.firstChild && to2.firstChild.nodeValue !== fromValue) {
          to2.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function noOp() {
    }
    function mergeDefaults(config) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults);
      Object.assign(finalConfig, config);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults.callbacks);
      Object.assign(finalConfig.callbacks, config.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults.head);
      Object.assign(finalConfig.head, config.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config) {
      config = mergeDefaults(config);
      return {
        target: oldNode,
        newContent,
        config,
        morphStyle: config.morphStyle,
        ignoreActive: config.ignoreActive,
        ignoreActiveValue: config.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config.callbacks,
        head: config.head
      };
    }
    function isIdSetMatch(node1, node2, ctx) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx);
      }
      removeIdsFromConsideration(ctx, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx);
        if (newScore > score) {
          bestElement = currentElement;
          score = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx) {
      removeIdsFromConsideration(ctx, tempNode);
      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx, id2) {
      return !ctx.deadIds.has(id2);
    }
    function idIsWithinNode(ctx, id2, targetNode) {
      let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id2);
    }
    function removeIdsFromConsideration(ctx, node) {
      let idSet = ctx.idMap.get(node) || EMPTY_SET;
      for (const id2 of idSet) {
        ctx.deadIds.add(id2);
      }
    }
    function getIdIntersectionCount(ctx, node1, node2) {
      let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id2 of sourceSet) {
        if (isIdInConsideration(ctx, id2) && idIsWithinNode(ctx, id2, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults
    };
  }();
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphRenderer = class extends PageRenderer {
    async render() {
      if (this.willRender) await this.#morphBody();
    }
    get renderMethod() {
      return "morph";
    }
    // Private
    async #morphBody() {
      this.#morphElements(this.currentElement, this.newElement);
      this.#reloadRemoteFrames();
      dispatch("turbo:morph", {
        detail: {
          currentElement: this.currentElement,
          newElement: this.newElement
        }
      });
    }
    #morphElements(currentElement, newElement, morphStyle = "outerHTML") {
      this.isMorphingTurboFrame = this.#isFrameReloadedWithMorph(currentElement);
      Idiomorph.morph(currentElement, newElement, {
        ignoreActiveValue: true,
        morphStyle,
        callbacks: {
          beforeNodeAdded: this.#shouldAddElement,
          beforeNodeMorphed: this.#shouldMorphElement,
          beforeAttributeUpdated: this.#shouldUpdateAttribute,
          beforeNodeRemoved: this.#shouldRemoveElement,
          afterNodeMorphed: this.#didMorphElement
        }
      });
    }
    #shouldAddElement = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    #shouldMorphElement = (oldNode, newNode) => {
      if (oldNode instanceof HTMLElement) {
        if (!oldNode.hasAttribute("data-turbo-permanent") && (this.isMorphingTurboFrame || !this.#isFrameReloadedWithMorph(oldNode))) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: oldNode,
            detail: {
              newElement: newNode
            }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    #shouldUpdateAttribute = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", { cancelable: true, target, detail: { attributeName, mutationType } });
      return !event.defaultPrevented;
    };
    #didMorphElement = (oldNode, newNode) => {
      if (newNode instanceof HTMLElement) {
        dispatch("turbo:morph-element", {
          target: oldNode,
          detail: {
            newElement: newNode
          }
        });
      }
    };
    #shouldRemoveElement = (node) => {
      return this.#shouldMorphElement(node);
    };
    #reloadRemoteFrames() {
      this.#remoteFrames().forEach((frame) => {
        if (this.#isFrameReloadedWithMorph(frame)) {
          this.#renderFrameWithMorph(frame);
          frame.reload();
        }
      });
    }
    #renderFrameWithMorph(frame) {
      frame.addEventListener("turbo:before-frame-render", (event) => {
        event.detail.render = this.#morphFrameUpdate;
      }, { once: true });
    }
    #morphFrameUpdate = (currentElement, newElement) => {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      this.#morphElements(currentElement, newElement.children, "innerHTML");
    };
    #isFrameReloadedWithMorph(element) {
      return element.src && element.refresh === "morph";
    }
    #remoteFrames() {
      return Array.from(document.querySelectorAll("turbo-frame[src]")).filter((frame) => {
        return !frame.closest("[data-turbo-permanent]");
      });
    }
  };
  var SnapshotCache = class {
    keys = [];
    snapshots = {};
    constructor(size) {
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1) this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_3) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var Session = class {
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    drive = true;
    enabled = true;
    progressBarDelay = 500;
    started = false;
    formMode = "on";
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest) {
        this.cache.exemptPageFromPreview();
        this.visit(url, { action: "replace" });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce(this.debouncedRefresh.bind(this), value);
      this.#pageRefreshDebouncePeriod = value;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter) {
      const action = getAction$1(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render }
      } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start2() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  var Turbo2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    start: start2,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src")) return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.#ignoringChangesToAttribute("complete", () => {
        this.element.removeAttribute("complete");
      });
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    completeChanged() {
      if (this.#isIgnoringChangesTo("complete")) return;
      this.#loadSourceURL();
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return this.#shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.#findFrameElement(link);
      if (frame) form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.#resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render }
      } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame = element.querySelector("#" + this.element.id);
      if (frame && this.previousFrameElement) {
        frame.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise) await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));
      this.#withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action) options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter) {
      const id2 = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return getFrameElementById(id2) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id2 = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id2}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id2}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error2) {
        console.error(error2);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter) {
      const action = getAction$1(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter) {
      const id2 = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id2 == "_top") {
        return false;
      }
      if (id2) {
        const frameElement = getFrameElementById(id2);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      this.#ignoringChangesToAttribute("complete", () => {
        if (value) {
          this.element.setAttribute("complete", "");
        } else {
          this.element.removeAttribute("complete");
        }
      });
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = meta?.content ?? "/";
      return expandURL(root);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id2) {
    if (id2 != null) {
      const element = document.getElementById(id2);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e2) => e2.parentElement?.insertBefore(this.templateContent, e2.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e2) => e2.parentElement?.insertBefore(this.templateContent, e2));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e2) => e2.remove());
    },
    replace() {
      this.targetElements.forEach((e2) => e2.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c2) => c2.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e2) => [...e2.children]).filter((c2) => !!c2.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c2) => !!c2.id).map((c2) => c2.id);
      return existingChildren.filter((c2) => newChildrenIds.includes(c2.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element) return;
    if (element.hasAttribute("data-turbo-suppress-warning")) return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo2, StreamActions };
  start2();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object") return obj;
    if (obj instanceof Date || obj instanceof RegExp) return obj;
    if (Array.isArray(obj)) return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m2, x2) {
        return "_" + x2.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription) this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.name === "_method") {
        return submitter.value;
      } else if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // app/assets/javascripts/administrate/application.js
  var import_selectize_min = __toESM(require_selectize_min());

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left, right) => {
        const leftIndex = left.index, rightIndex = right.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[2];
    let keyFilter = matches[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName,
      eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
      identifier: matches[5],
      methodName: matches[6],
      keyFilter: matches[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_3, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_3, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e2) => e2.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map, key, value) {
    fetch2(map, key).add(value);
  }
  function del(map, key, value) {
    fetch2(map, key).delete(value);
    prune(map, key);
  }
  function fetch2(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
        return match.concat(matches);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_3, index) => [left[index], right[index]]);
  }
  function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a2 = function() {
        this.a.call(this);
      };
      const b2 = extendWithReflect(a2);
      b2.prototype.a = function() {
      };
      return new b2();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c2) => [c2, c2]))), objectFromEntries("0123456789".split("").map((n2) => [n2, n2])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k2, v2]) => Object.assign(Object.assign({}, memo), { [k2]: v2 }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read, writer: write } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // app/assets/javascripts/administrate/controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // app/assets/javascripts/administrate/controllers/select_controller.js
  var import_jquery2 = __toESM(require_jquery());
  var select_controller_default = class extends Controller {
    connect() {
      if (!this.selectize) {
        const options = this.selectizeOptions || {};
        const selectedValues = (0, import_jquery2.default)(this.element).val();
        this.selectize = (0, import_jquery2.default)(this.element).selectize(options)[0].selectize;
        this.selectize.setValue(selectedValues);
      }
    }
    disconnect() {
      if (this.selectize) {
        const selectedValues = this.selectize.getValue();
        if (!this.selectizeOptions) {
          this.selectizeOptions = this.selectize.settings;
        }
        this.selectize.destroy();
        this.selectize = null;
        (0, import_jquery2.default)(this.element).val(selectedValues);
      }
    }
  };

  // app/assets/javascripts/administrate/controllers/table_controller.js
  var import_jquery3 = __toESM(require_jquery());
  var keycodes = { space: 32, enter: 13 };
  var table_controller_default = class extends Controller {
    visitDataUrl(event) {
      if (event.type == "click" || event.keyCode == keycodes.space || event.keyCode == keycodes.enter) {
        if (event.target.href) {
          return;
        }
        var dataUrl = (0, import_jquery3.default)(event.target).closest("tr").data("url");
        var selection = window.getSelection().toString();
        if (selection.length === 0 && dataUrl) {
          Turbo.visit(dataUrl);
        }
      }
    }
  };

  // app/assets/javascripts/administrate/controllers/tooltip_controller.js
  var tooltip_controller_default = class extends Controller {
    static targets = ["popover", "tooltip"];
    connect() {
      this.tooltipTarget.addEventListener("mouseenter", this.showPopover);
      this.tooltipTarget.addEventListener("mouseleave", this.hidePopover);
    }
    disconnect() {
      this.tooltipTarget.removeEventListener("mouseenter", this.showPopover);
      this.tooltipTarget.removeEventListener("mouseleave", this.hidePopover);
    }
    showPopover = () => {
      this.popoverTarget.showPopover();
    };
    hidePopover = () => {
      this.popoverTarget.hidePopover();
    };
  };

  // app/assets/javascripts/administrate/controllers/index.js
  application.register("select", select_controller_default);
  application.register("table", table_controller_default);
  application.register("tooltip", tooltip_controller_default);

  // app/assets/javascripts/administrate/vendor/css-anchor-positioning.js
  var fa = Object.defineProperty;
  var da = Object.defineProperties;
  var ma = Object.getOwnPropertyDescriptors;
  var Mr2 = Object.getOwnPropertySymbols;
  var ga = Object.prototype.hasOwnProperty;
  var ba = Object.prototype.propertyIsEnumerable;
  var Nr2 = (e2, t3, n2) => t3 in e2 ? fa(e2, t3, { enumerable: true, configurable: true, writable: true, value: n2 }) : e2[t3] = n2;
  var _2 = (e2, t3) => {
    for (var n2 in t3 || (t3 = {}))
      ga.call(t3, n2) && Nr2(e2, n2, t3[n2]);
    if (Mr2)
      for (var n2 of Mr2(t3))
        ba.call(t3, n2) && Nr2(e2, n2, t3[n2]);
    return e2;
  };
  var Z2 = (e2, t3) => da(e2, ma(t3));
  var ya = (e2, t3) => () => (t3 || e2((t3 = { exports: {} }).exports, t3), t3.exports);
  var H2 = (e2, t3, n2) => new Promise((r2, i2) => {
    var o2 = (l2) => {
      try {
        c2(n2.next(l2));
      } catch (a2) {
        i2(a2);
      }
    }, s2 = (l2) => {
      try {
        c2(n2.throw(l2));
      } catch (a2) {
        i2(a2);
      }
    }, c2 = (l2) => l2.done ? r2(l2.value) : Promise.resolve(l2.value).then(o2, s2);
    c2((n2 = n2.apply(e2, t3)).next());
  });
  var Qg = ya((Rr2) => {
    const Gn2 = Math.min, lt2 = Math.max, Zt2 = Math.round, Mt2 = Math.floor, $e2 = (e2) => ({
      x: e2,
      y: e2
    });
    function ka(e2, t3) {
      return typeof e2 == "function" ? e2(t3) : e2;
    }
    function xa(e2) {
      return _2({
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }, e2);
    }
    function wa(e2) {
      return typeof e2 != "number" ? xa(e2) : {
        top: e2,
        right: e2,
        bottom: e2,
        left: e2
      };
    }
    function Jt2(e2) {
      const {
        x: t3,
        y: n2,
        width: r2,
        height: i2
      } = e2;
      return {
        width: r2,
        height: i2,
        top: n2,
        left: t3,
        right: t3 + r2,
        bottom: n2 + i2,
        x: t3,
        y: n2
      };
    }
    function va(e2, t3) {
      return H2(this, null, function* () {
        var n2;
        t3 === void 0 && (t3 = {});
        const {
          x: r2,
          y: i2,
          platform: o2,
          rects: s2,
          elements: c2,
          strategy: l2
        } = e2, {
          boundary: a2 = "clippingAncestors",
          rootBoundary: u2 = "viewport",
          elementContext: h2 = "floating",
          altBoundary: d2 = false,
          padding: m2 = 0
        } = ka(t3, e2), w2 = wa(m2), C2 = c2[d2 ? h2 === "floating" ? "reference" : "floating" : h2], b2 = Jt2(yield o2.getClippingRect({
          element: (n2 = yield o2.isElement == null ? void 0 : o2.isElement(C2)) == null || n2 ? C2 : C2.contextElement || (yield o2.getDocumentElement == null ? void 0 : o2.getDocumentElement(c2.floating)),
          boundary: a2,
          rootBoundary: u2,
          strategy: l2
        })), x2 = h2 === "floating" ? {
          x: r2,
          y: i2,
          width: s2.floating.width,
          height: s2.floating.height
        } : s2.reference, T2 = yield o2.getOffsetParent == null ? void 0 : o2.getOffsetParent(c2.floating), v2 = (yield o2.isElement == null ? void 0 : o2.isElement(T2)) ? (yield o2.getScale == null ? void 0 : o2.getScale(T2)) || {
          x: 1,
          y: 1
        } : {
          x: 1,
          y: 1
        }, A2 = Jt2(o2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield o2.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements: c2,
          rect: x2,
          offsetParent: T2,
          strategy: l2
        }) : x2);
        return {
          top: (b2.top - A2.top + w2.top) / v2.y,
          bottom: (A2.bottom - b2.bottom + w2.bottom) / v2.y,
          left: (b2.left - A2.left + w2.left) / v2.x,
          right: (A2.right - b2.right + w2.right) / v2.x
        };
      });
    }
    function hn2() {
      return typeof window != "undefined";
    }
    function bt2(e2) {
      return ro2(e2) ? (e2.nodeName || "").toLowerCase() : "#document";
    }
    function pe2(e2) {
      var t3;
      return (e2 == null || (t3 = e2.ownerDocument) == null ? void 0 : t3.defaultView) || window;
    }
    function Pe2(e2) {
      var t3;
      return (t3 = (ro2(e2) ? e2.ownerDocument : e2.document) || window.document) == null ? void 0 : t3.documentElement;
    }
    function ro2(e2) {
      return hn2() ? e2 instanceof Node || e2 instanceof pe2(e2).Node : false;
    }
    function we2(e2) {
      return hn2() ? e2 instanceof Element || e2 instanceof pe2(e2).Element : false;
    }
    function _e2(e2) {
      return hn2() ? e2 instanceof HTMLElement || e2 instanceof pe2(e2).HTMLElement : false;
    }
    function Dr2(e2) {
      return !hn2() || typeof ShadowRoot == "undefined" ? false : e2 instanceof ShadowRoot || e2 instanceof pe2(e2).ShadowRoot;
    }
    function It2(e2) {
      const {
        overflow: t3,
        overflowX: n2,
        overflowY: r2,
        display: i2
      } = ve2(e2);
      return /auto|scroll|overlay|hidden|clip/.test(t3 + r2 + n2) && !["inline", "contents"].includes(i2);
    }
    function Sa(e2) {
      return ["table", "td", "th"].includes(bt2(e2));
    }
    function pn2(e2) {
      return [":popover-open", ":modal"].some((t3) => {
        try {
          return e2.matches(t3);
        } catch (n2) {
          return false;
        }
      });
    }
    function ur2(e2) {
      const t3 = hr2(), n2 = we2(e2) ? ve2(e2) : e2;
      return n2.transform !== "none" || n2.perspective !== "none" || (n2.containerType ? n2.containerType !== "normal" : false) || !t3 && (n2.backdropFilter ? n2.backdropFilter !== "none" : false) || !t3 && (n2.filter ? n2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((r2) => (n2.willChange || "").includes(r2)) || ["paint", "layout", "strict", "content"].some((r2) => (n2.contain || "").includes(r2));
    }
    function Ca(e2) {
      let t3 = We2(e2);
      for (; _e2(t3) && !pt2(t3); ) {
        if (ur2(t3))
          return t3;
        if (pn2(t3))
          return null;
        t3 = We2(t3);
      }
      return null;
    }
    function hr2() {
      return typeof CSS == "undefined" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
    }
    function pt2(e2) {
      return ["html", "body", "#document"].includes(bt2(e2));
    }
    function ve2(e2) {
      return pe2(e2).getComputedStyle(e2);
    }
    function fn2(e2) {
      return we2(e2) ? {
        scrollLeft: e2.scrollLeft,
        scrollTop: e2.scrollTop
      } : {
        scrollLeft: e2.scrollX,
        scrollTop: e2.scrollY
      };
    }
    function We2(e2) {
      if (bt2(e2) === "html")
        return e2;
      const t3 = (
        // Step into the shadow DOM of the parent of a slotted node.
        e2.assignedSlot || // DOM Element detected.
        e2.parentNode || // ShadowRoot detected.
        Dr2(e2) && e2.host || // Fallback.
        Pe2(e2)
      );
      return Dr2(t3) ? t3.host : t3;
    }
    function io2(e2) {
      const t3 = We2(e2);
      return pt2(t3) ? e2.ownerDocument ? e2.ownerDocument.body : e2.body : _e2(t3) && It2(t3) ? t3 : io2(t3);
    }
    function Lt2(e2, t3, n2) {
      var r2;
      t3 === void 0 && (t3 = []), n2 === void 0 && (n2 = true);
      const i2 = io2(e2), o2 = i2 === ((r2 = e2.ownerDocument) == null ? void 0 : r2.body), s2 = pe2(i2);
      if (o2) {
        const c2 = Vn2(s2);
        return t3.concat(s2, s2.visualViewport || [], It2(i2) ? i2 : [], c2 && n2 ? Lt2(c2) : []);
      }
      return t3.concat(i2, Lt2(i2, [], n2));
    }
    function Vn2(e2) {
      return e2.parent && Object.getPrototypeOf(e2.parent) ? e2.frameElement : null;
    }
    function oo2(e2) {
      const t3 = ve2(e2);
      let n2 = parseFloat(t3.width) || 0, r2 = parseFloat(t3.height) || 0;
      const i2 = _e2(e2), o2 = i2 ? e2.offsetWidth : n2, s2 = i2 ? e2.offsetHeight : r2, c2 = Zt2(n2) !== o2 || Zt2(r2) !== s2;
      return c2 && (n2 = o2, r2 = s2), {
        width: n2,
        height: r2,
        $: c2
      };
    }
    function pr2(e2) {
      return we2(e2) ? e2 : e2.contextElement;
    }
    function ct2(e2) {
      const t3 = pr2(e2);
      if (!_e2(t3))
        return $e2(1);
      const n2 = t3.getBoundingClientRect(), {
        width: r2,
        height: i2,
        $: o2
      } = oo2(t3);
      let s2 = (o2 ? Zt2(n2.width) : n2.width) / r2, c2 = (o2 ? Zt2(n2.height) : n2.height) / i2;
      return (!s2 || !Number.isFinite(s2)) && (s2 = 1), (!c2 || !Number.isFinite(c2)) && (c2 = 1), {
        x: s2,
        y: c2
      };
    }
    const Ta = /* @__PURE__ */ $e2(0);
    function so(e2) {
      const t3 = pe2(e2);
      return !hr2() || !t3.visualViewport ? Ta : {
        x: t3.visualViewport.offsetLeft,
        y: t3.visualViewport.offsetTop
      };
    }
    function Aa(e2, t3, n2) {
      return t3 === void 0 && (t3 = false), !n2 || t3 && n2 !== pe2(e2) ? false : t3;
    }
    function Qe2(e2, t3, n2, r2) {
      t3 === void 0 && (t3 = false), n2 === void 0 && (n2 = false);
      const i2 = e2.getBoundingClientRect(), o2 = pr2(e2);
      let s2 = $e2(1);
      t3 && (r2 ? we2(r2) && (s2 = ct2(r2)) : s2 = ct2(e2));
      const c2 = Aa(o2, n2, r2) ? so(o2) : $e2(0);
      let l2 = (i2.left + c2.x) / s2.x, a2 = (i2.top + c2.y) / s2.y, u2 = i2.width / s2.x, h2 = i2.height / s2.y;
      if (o2) {
        const d2 = pe2(o2), m2 = r2 && we2(r2) ? pe2(r2) : r2;
        let w2 = d2, k2 = Vn2(w2);
        for (; k2 && r2 && m2 !== w2; ) {
          const C2 = ct2(k2), b2 = k2.getBoundingClientRect(), x2 = ve2(k2), T2 = b2.left + (k2.clientLeft + parseFloat(x2.paddingLeft)) * C2.x, v2 = b2.top + (k2.clientTop + parseFloat(x2.paddingTop)) * C2.y;
          l2 *= C2.x, a2 *= C2.y, u2 *= C2.x, h2 *= C2.y, l2 += T2, a2 += v2, w2 = pe2(k2), k2 = Vn2(w2);
        }
      }
      return Jt2({
        width: u2,
        height: h2,
        x: l2,
        y: a2
      });
    }
    function fr2(e2, t3) {
      const n2 = fn2(e2).scrollLeft;
      return t3 ? t3.left + n2 : Qe2(Pe2(e2)).left + n2;
    }
    function ao(e2, t3, n2) {
      n2 === void 0 && (n2 = false);
      const r2 = e2.getBoundingClientRect(), i2 = r2.left + t3.scrollLeft - (n2 ? 0 : (
        // RTL <body> scrollbar.
        fr2(e2, r2)
      )), o2 = r2.top + t3.scrollTop;
      return {
        x: i2,
        y: o2
      };
    }
    function Oa(e2) {
      let {
        elements: t3,
        rect: n2,
        offsetParent: r2,
        strategy: i2
      } = e2;
      const o2 = i2 === "fixed", s2 = Pe2(r2), c2 = t3 ? pn2(t3.floating) : false;
      if (r2 === s2 || c2 && o2)
        return n2;
      let l2 = {
        scrollLeft: 0,
        scrollTop: 0
      }, a2 = $e2(1);
      const u2 = $e2(0), h2 = _e2(r2);
      if ((h2 || !h2 && !o2) && ((bt2(r2) !== "body" || It2(s2)) && (l2 = fn2(r2)), _e2(r2))) {
        const m2 = Qe2(r2);
        a2 = ct2(r2), u2.x = m2.x + r2.clientLeft, u2.y = m2.y + r2.clientTop;
      }
      const d2 = s2 && !h2 && !o2 ? ao(s2, l2, true) : $e2(0);
      return {
        width: n2.width * a2.x,
        height: n2.height * a2.y,
        x: n2.x * a2.x - l2.scrollLeft * a2.x + u2.x + d2.x,
        y: n2.y * a2.y - l2.scrollTop * a2.y + u2.y + d2.y
      };
    }
    function Ea(e2) {
      return Array.from(e2.getClientRects());
    }
    function La(e2) {
      const t3 = Pe2(e2), n2 = fn2(e2), r2 = e2.ownerDocument.body, i2 = lt2(t3.scrollWidth, t3.clientWidth, r2.scrollWidth, r2.clientWidth), o2 = lt2(t3.scrollHeight, t3.clientHeight, r2.scrollHeight, r2.clientHeight);
      let s2 = -n2.scrollLeft + fr2(e2);
      const c2 = -n2.scrollTop;
      return ve2(r2).direction === "rtl" && (s2 += lt2(t3.clientWidth, r2.clientWidth) - i2), {
        width: i2,
        height: o2,
        x: s2,
        y: c2
      };
    }
    function $a(e2, t3) {
      const n2 = pe2(e2), r2 = Pe2(e2), i2 = n2.visualViewport;
      let o2 = r2.clientWidth, s2 = r2.clientHeight, c2 = 0, l2 = 0;
      if (i2) {
        o2 = i2.width, s2 = i2.height;
        const a2 = hr2();
        (!a2 || a2 && t3 === "fixed") && (c2 = i2.offsetLeft, l2 = i2.offsetTop);
      }
      return {
        width: o2,
        height: s2,
        x: c2,
        y: l2
      };
    }
    function _a(e2, t3) {
      const n2 = Qe2(e2, true, t3 === "fixed"), r2 = n2.top + e2.clientTop, i2 = n2.left + e2.clientLeft, o2 = _e2(e2) ? ct2(e2) : $e2(1), s2 = e2.clientWidth * o2.x, c2 = e2.clientHeight * o2.y, l2 = i2 * o2.x, a2 = r2 * o2.y;
      return {
        width: s2,
        height: c2,
        x: l2,
        y: a2
      };
    }
    function jr2(e2, t3, n2) {
      let r2;
      if (t3 === "viewport")
        r2 = $a(e2, n2);
      else if (t3 === "document")
        r2 = La(Pe2(e2));
      else if (we2(t3))
        r2 = _a(t3, n2);
      else {
        const i2 = so(e2);
        r2 = {
          x: t3.x - i2.x,
          y: t3.y - i2.y,
          width: t3.width,
          height: t3.height
        };
      }
      return Jt2(r2);
    }
    function lo(e2, t3) {
      const n2 = We2(e2);
      return n2 === t3 || !we2(n2) || pt2(n2) ? false : ve2(n2).position === "fixed" || lo(n2, t3);
    }
    function Pa(e2, t3) {
      const n2 = t3.get(e2);
      if (n2)
        return n2;
      let r2 = Lt2(e2, [], false).filter((c2) => we2(c2) && bt2(c2) !== "body"), i2 = null;
      const o2 = ve2(e2).position === "fixed";
      let s2 = o2 ? We2(e2) : e2;
      for (; we2(s2) && !pt2(s2); ) {
        const c2 = ve2(s2), l2 = ur2(s2);
        !l2 && c2.position === "fixed" && (i2 = null), (o2 ? !l2 && !i2 : !l2 && c2.position === "static" && !!i2 && ["absolute", "fixed"].includes(i2.position) || It2(s2) && !l2 && lo(e2, s2)) ? r2 = r2.filter((u2) => u2 !== s2) : i2 = c2, s2 = We2(s2);
      }
      return t3.set(e2, r2), r2;
    }
    function za(e2) {
      let {
        element: t3,
        boundary: n2,
        rootBoundary: r2,
        strategy: i2
      } = e2;
      const s2 = [...n2 === "clippingAncestors" ? pn2(t3) ? [] : Pa(t3, this._c) : [].concat(n2), r2], c2 = s2[0], l2 = s2.reduce((a2, u2) => {
        const h2 = jr2(t3, u2, i2);
        return a2.top = lt2(h2.top, a2.top), a2.right = Gn2(h2.right, a2.right), a2.bottom = Gn2(h2.bottom, a2.bottom), a2.left = lt2(h2.left, a2.left), a2;
      }, jr2(t3, c2, i2));
      return {
        width: l2.right - l2.left,
        height: l2.bottom - l2.top,
        x: l2.left,
        y: l2.top
      };
    }
    function Ia(e2) {
      const {
        width: t3,
        height: n2
      } = oo2(e2);
      return {
        width: t3,
        height: n2
      };
    }
    function Ra(e2, t3, n2) {
      const r2 = _e2(t3), i2 = Pe2(t3), o2 = n2 === "fixed", s2 = Qe2(e2, true, o2, t3);
      let c2 = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const l2 = $e2(0);
      if (r2 || !r2 && !o2)
        if ((bt2(t3) !== "body" || It2(i2)) && (c2 = fn2(t3)), r2) {
          const d2 = Qe2(t3, true, o2, t3);
          l2.x = d2.x + t3.clientLeft, l2.y = d2.y + t3.clientTop;
        } else i2 && (l2.x = fr2(i2));
      const a2 = i2 && !r2 && !o2 ? ao(i2, c2) : $e2(0), u2 = s2.left + c2.scrollLeft - l2.x - a2.x, h2 = s2.top + c2.scrollTop - l2.y - a2.y;
      return {
        x: u2,
        y: h2,
        width: s2.width,
        height: s2.height
      };
    }
    function Sn2(e2) {
      return ve2(e2).position === "static";
    }
    function Fr2(e2, t3) {
      if (!_e2(e2) || ve2(e2).position === "fixed")
        return null;
      if (t3)
        return t3(e2);
      let n2 = e2.offsetParent;
      return Pe2(e2) === n2 && (n2 = n2.ownerDocument.body), n2;
    }
    function co(e2, t3) {
      const n2 = pe2(e2);
      if (pn2(e2))
        return n2;
      if (!_e2(e2)) {
        let i2 = We2(e2);
        for (; i2 && !pt2(i2); ) {
          if (we2(i2) && !Sn2(i2))
            return i2;
          i2 = We2(i2);
        }
        return n2;
      }
      let r2 = Fr2(e2, t3);
      for (; r2 && Sa(r2) && Sn2(r2); )
        r2 = Fr2(r2, t3);
      return r2 && pt2(r2) && Sn2(r2) && !ur2(r2) ? n2 : r2 || Ca(e2) || n2;
    }
    const Ma = function(e2) {
      return H2(this, null, function* () {
        const t3 = this.getOffsetParent || co, n2 = this.getDimensions, r2 = yield n2(e2.floating);
        return {
          reference: Ra(e2.reference, yield t3(e2.floating), e2.strategy),
          floating: {
            x: 0,
            y: 0,
            width: r2.width,
            height: r2.height
          }
        };
      });
    };
    function Na(e2) {
      return ve2(e2).direction === "rtl";
    }
    const ee2 = {
      convertOffsetParentRelativeRectToViewportRelativeRect: Oa,
      getDocumentElement: Pe2,
      getClippingRect: za,
      getOffsetParent: co,
      getElementRects: Ma,
      getClientRects: Ea,
      getDimensions: Ia,
      getScale: ct2,
      isElement: we2,
      isRTL: Na
    };
    function Da(e2, t3) {
      let n2 = null, r2;
      const i2 = Pe2(e2);
      function o2() {
        var c2;
        clearTimeout(r2), (c2 = n2) == null || c2.disconnect(), n2 = null;
      }
      function s2(c2, l2) {
        c2 === void 0 && (c2 = false), l2 === void 0 && (l2 = 1), o2();
        const {
          left: a2,
          top: u2,
          width: h2,
          height: d2
        } = e2.getBoundingClientRect();
        if (c2 || t3(), !h2 || !d2)
          return;
        const m2 = Mt2(u2), w2 = Mt2(i2.clientWidth - (a2 + h2)), k2 = Mt2(i2.clientHeight - (u2 + d2)), C2 = Mt2(a2), x2 = {
          rootMargin: -m2 + "px " + -w2 + "px " + -k2 + "px " + -C2 + "px",
          threshold: lt2(0, Gn2(1, l2)) || 1
        };
        let T2 = true;
        function v2(A2) {
          const P2 = A2[0].intersectionRatio;
          if (P2 !== l2) {
            if (!T2)
              return s2();
            P2 ? s2(false, P2) : r2 = setTimeout(() => {
              s2(false, 1e-7);
            }, 1e3);
          }
          T2 = false;
        }
        try {
          n2 = new IntersectionObserver(v2, Z2(_2({}, x2), {
            // Handle <iframe>s
            root: i2.ownerDocument
          }));
        } catch (A2) {
          n2 = new IntersectionObserver(v2, x2);
        }
        n2.observe(e2);
      }
      return s2(true), o2;
    }
    function uo(e2, t3, n2, r2) {
      r2 === void 0 && (r2 = {});
      const {
        ancestorScroll: i2 = true,
        ancestorResize: o2 = true,
        elementResize: s2 = typeof ResizeObserver == "function",
        layoutShift: c2 = typeof IntersectionObserver == "function",
        animationFrame: l2 = false
      } = r2, a2 = pr2(e2), u2 = i2 || o2 ? [...a2 ? Lt2(a2) : [], ...Lt2(t3)] : [];
      u2.forEach((b2) => {
        i2 && b2.addEventListener("scroll", n2, {
          passive: true
        }), o2 && b2.addEventListener("resize", n2);
      });
      const h2 = a2 && c2 ? Da(a2, n2) : null;
      let d2 = -1, m2 = null;
      s2 && (m2 = new ResizeObserver((b2) => {
        let [x2] = b2;
        x2 && x2.target === a2 && m2 && (m2.unobserve(t3), cancelAnimationFrame(d2), d2 = requestAnimationFrame(() => {
          var T2;
          (T2 = m2) == null || T2.observe(t3);
        })), n2();
      }), a2 && !l2 && m2.observe(a2), m2.observe(t3));
      let w2, k2 = l2 ? Qe2(e2) : null;
      l2 && C2();
      function C2() {
        const b2 = Qe2(e2);
        k2 && (b2.x !== k2.x || b2.y !== k2.y || b2.width !== k2.width || b2.height !== k2.height) && n2(), k2 = b2, w2 = requestAnimationFrame(C2);
      }
      return n2(), () => {
        var b2;
        u2.forEach((x2) => {
          i2 && x2.removeEventListener("scroll", n2), o2 && x2.removeEventListener("resize", n2);
        }), h2 == null || h2(), (b2 = m2) == null || b2.disconnect(), m2 = null, l2 && cancelAnimationFrame(w2);
      };
    }
    const ja = va, De2 = 0, y2 = 1, $5 = 2, G2 = 3, F2 = 4, Te2 = 5, dn2 = 6, te2 = 7, se2 = 8, I2 = 9, L2 = 10, B2 = 11, z2 = 12, W2 = 13, Rt2 = 14, ae2 = 15, ne2 = 16, re2 = 17, ce2 = 18, fe2 = 19, Se2 = 20, M2 = 21, E2 = 22, V2 = 23, ue2 = 24, X2 = 25, Fa = 0;
    function Q2(e2) {
      return e2 >= 48 && e2 <= 57;
    }
    function He2(e2) {
      return Q2(e2) || // 0 .. 9
      e2 >= 65 && e2 <= 70 || // A .. F
      e2 >= 97 && e2 <= 102;
    }
    function dr2(e2) {
      return e2 >= 65 && e2 <= 90;
    }
    function Ba(e2) {
      return e2 >= 97 && e2 <= 122;
    }
    function Wa(e2) {
      return dr2(e2) || Ba(e2);
    }
    function Ha(e2) {
      return e2 >= 128;
    }
    function en2(e2) {
      return Wa(e2) || Ha(e2) || e2 === 95;
    }
    function ho(e2) {
      return en2(e2) || Q2(e2) || e2 === 45;
    }
    function Ua(e2) {
      return e2 >= 0 && e2 <= 8 || e2 === 11 || e2 >= 14 && e2 <= 31 || e2 === 127;
    }
    function tn2(e2) {
      return e2 === 10 || e2 === 13 || e2 === 12;
    }
    function Xe2(e2) {
      return tn2(e2) || e2 === 32 || e2 === 9;
    }
    function Le2(e2, t3) {
      return !(e2 !== 92 || tn2(t3) || t3 === Fa);
    }
    function qt2(e2, t3, n2) {
      return e2 === 45 ? en2(t3) || t3 === 45 || Le2(t3, n2) : en2(e2) ? true : e2 === 92 ? Le2(e2, t3) : false;
    }
    function Cn2(e2, t3, n2) {
      return e2 === 43 || e2 === 45 ? Q2(t3) ? 2 : t3 === 46 && Q2(n2) ? 3 : 0 : e2 === 46 ? Q2(t3) ? 2 : 0 : Q2(e2) ? 1 : 0;
    }
    function po(e2) {
      return e2 === 65279 || e2 === 65534 ? 1 : 0;
    }
    const Kn2 = new Array(128), qa = 128, Gt2 = 130, fo = 131, mr2 = 132, mo = 133;
    for (let e2 = 0; e2 < Kn2.length; e2++)
      Kn2[e2] = Xe2(e2) && Gt2 || Q2(e2) && fo || en2(e2) && mr2 || Ua(e2) && mo || e2 || qa;
    function Tn2(e2) {
      return e2 < 128 ? Kn2[e2] : mr2;
    }
    function ut2(e2, t3) {
      return t3 < e2.length ? e2.charCodeAt(t3) : 0;
    }
    function Yn2(e2, t3, n2) {
      return n2 === 13 && ut2(e2, t3 + 1) === 10 ? 2 : 1;
    }
    function ht2(e2, t3, n2) {
      let r2 = e2.charCodeAt(t3);
      return dr2(r2) && (r2 = r2 | 32), r2 === n2;
    }
    function $t2(e2, t3, n2, r2) {
      if (n2 - t3 !== r2.length || t3 < 0 || n2 > e2.length)
        return false;
      for (let i2 = t3; i2 < n2; i2++) {
        const o2 = r2.charCodeAt(i2 - t3);
        let s2 = e2.charCodeAt(i2);
        if (dr2(s2) && (s2 = s2 | 32), s2 !== o2)
          return false;
      }
      return true;
    }
    function Ga(e2, t3) {
      for (; t3 >= 0 && Xe2(e2.charCodeAt(t3)); t3--)
        ;
      return t3 + 1;
    }
    function Nt2(e2, t3) {
      for (; t3 < e2.length && Xe2(e2.charCodeAt(t3)); t3++)
        ;
      return t3;
    }
    function An2(e2, t3) {
      for (; t3 < e2.length && Q2(e2.charCodeAt(t3)); t3++)
        ;
      return t3;
    }
    function ft2(e2, t3) {
      if (t3 += 2, He2(ut2(e2, t3 - 1))) {
        for (const r2 = Math.min(e2.length, t3 + 5); t3 < r2 && He2(ut2(e2, t3)); t3++)
          ;
        const n2 = ut2(e2, t3);
        Xe2(n2) && (t3 += Yn2(e2, t3, n2));
      }
      return t3;
    }
    function Dt2(e2, t3) {
      for (; t3 < e2.length; t3++) {
        const n2 = e2.charCodeAt(t3);
        if (!ho(n2)) {
          if (Le2(n2, ut2(e2, t3 + 1))) {
            t3 = ft2(e2, t3) - 1;
            continue;
          }
          break;
        }
      }
      return t3;
    }
    function mn2(e2, t3) {
      let n2 = e2.charCodeAt(t3);
      if ((n2 === 43 || n2 === 45) && (n2 = e2.charCodeAt(t3 += 1)), Q2(n2) && (t3 = An2(e2, t3 + 1), n2 = e2.charCodeAt(t3)), n2 === 46 && Q2(e2.charCodeAt(t3 + 1)) && (t3 += 2, t3 = An2(e2, t3)), ht2(
        e2,
        t3,
        101
        /* e */
      )) {
        let r2 = 0;
        n2 = e2.charCodeAt(t3 + 1), (n2 === 45 || n2 === 43) && (r2 = 1, n2 = e2.charCodeAt(t3 + 2)), Q2(n2) && (t3 = An2(e2, t3 + 1 + r2 + 1));
      }
      return t3;
    }
    function On2(e2, t3) {
      for (; t3 < e2.length; t3++) {
        const n2 = e2.charCodeAt(t3);
        if (n2 === 41) {
          t3++;
          break;
        }
        Le2(n2, ut2(e2, t3 + 1)) && (t3 = ft2(e2, t3));
      }
      return t3;
    }
    function go(e2) {
      if (e2.length === 1 && !He2(e2.charCodeAt(0)))
        return e2[0];
      let t3 = parseInt(e2, 16);
      return (t3 === 0 || // If this number is zero,
      t3 >= 55296 && t3 <= 57343 || // or is for a surrogate,
      t3 > 1114111) && (t3 = 65533), String.fromCodePoint(t3);
    }
    const bo = [
      "EOF-token",
      "ident-token",
      "function-token",
      "at-keyword-token",
      "hash-token",
      "string-token",
      "bad-string-token",
      "url-token",
      "bad-url-token",
      "delim-token",
      "number-token",
      "percentage-token",
      "dimension-token",
      "whitespace-token",
      "CDO-token",
      "CDC-token",
      "colon-token",
      "semicolon-token",
      "comma-token",
      "[-token",
      "]-token",
      "(-token",
      ")-token",
      "{-token",
      "}-token",
      "comment-token"
    ], Va = 16 * 1024;
    function nn2(e2 = null, t3) {
      return e2 === null || e2.length < t3 ? new Uint32Array(Math.max(t3 + 1024, Va)) : e2;
    }
    const Br2 = 10, Ka = 12, Wr2 = 13;
    function Hr2(e2) {
      const t3 = e2.source, n2 = t3.length, r2 = t3.length > 0 ? po(t3.charCodeAt(0)) : 0, i2 = nn2(e2.lines, n2), o2 = nn2(e2.columns, n2);
      let s2 = e2.startLine, c2 = e2.startColumn;
      for (let l2 = r2; l2 < n2; l2++) {
        const a2 = t3.charCodeAt(l2);
        i2[l2] = s2, o2[l2] = c2++, (a2 === Br2 || a2 === Wr2 || a2 === Ka) && (a2 === Wr2 && l2 + 1 < n2 && t3.charCodeAt(l2 + 1) === Br2 && (l2++, i2[l2] = s2, o2[l2] = c2), s2++, c2 = 1);
      }
      i2[n2] = s2, o2[n2] = c2, e2.lines = i2, e2.columns = o2, e2.computed = true;
    }
    class Ya {
      constructor() {
        this.lines = null, this.columns = null, this.computed = false;
      }
      setSource(t3, n2 = 0, r2 = 1, i2 = 1) {
        this.source = t3, this.startOffset = n2, this.startLine = r2, this.startColumn = i2, this.computed = false;
      }
      getLocation(t3, n2) {
        return this.computed || Hr2(this), {
          source: n2,
          offset: this.startOffset + t3,
          line: this.lines[t3],
          column: this.columns[t3]
        };
      }
      getLocationRange(t3, n2, r2) {
        return this.computed || Hr2(this), {
          source: r2,
          start: {
            offset: this.startOffset + t3,
            line: this.lines[t3],
            column: this.columns[t3]
          },
          end: {
            offset: this.startOffset + n2,
            line: this.lines[n2],
            column: this.columns[n2]
          }
        };
      }
    }
    const de2 = 16777215, Ae2 = 24, Qa = /* @__PURE__ */ new Map([
      [$5, E2],
      [M2, E2],
      [fe2, Se2],
      [V2, ue2]
    ]);
    class Xa {
      constructor(t3, n2) {
        this.setSource(t3, n2);
      }
      reset() {
        this.eof = false, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset;
      }
      setSource(t3 = "", n2 = () => {
      }) {
        t3 = String(t3 || "");
        const r2 = t3.length, i2 = nn2(this.offsetAndType, t3.length + 1), o2 = nn2(this.balance, t3.length + 1);
        let s2 = 0, c2 = 0, l2 = 0, a2 = -1;
        for (this.offsetAndType = null, this.balance = null, n2(t3, (u2, h2, d2) => {
          switch (u2) {
            default:
              o2[s2] = r2;
              break;
            case c2: {
              let m2 = l2 & de2;
              for (l2 = o2[m2], c2 = l2 >> Ae2, o2[s2] = m2, o2[m2++] = s2; m2 < s2; m2++)
                o2[m2] === r2 && (o2[m2] = s2);
              break;
            }
            case M2:
            case $5:
            case fe2:
            case V2:
              o2[s2] = l2, c2 = Qa.get(u2), l2 = c2 << Ae2 | s2;
              break;
          }
          i2[s2++] = u2 << Ae2 | d2, a2 === -1 && (a2 = h2);
        }), i2[s2] = De2 << Ae2 | r2, o2[s2] = r2, o2[r2] = r2; l2 !== 0; ) {
          const u2 = l2 & de2;
          l2 = o2[u2], o2[u2] = r2;
        }
        this.source = t3, this.firstCharOffset = a2 === -1 ? 0 : a2, this.tokenCount = s2, this.offsetAndType = i2, this.balance = o2, this.reset(), this.next();
      }
      lookupType(t3) {
        return t3 += this.tokenIndex, t3 < this.tokenCount ? this.offsetAndType[t3] >> Ae2 : De2;
      }
      lookupTypeNonSC(t3) {
        for (let n2 = this.tokenIndex; n2 < this.tokenCount; n2++) {
          const r2 = this.offsetAndType[n2] >> Ae2;
          if (r2 !== W2 && r2 !== X2 && t3-- === 0)
            return r2;
        }
        return De2;
      }
      lookupOffset(t3) {
        return t3 += this.tokenIndex, t3 < this.tokenCount ? this.offsetAndType[t3 - 1] & de2 : this.source.length;
      }
      lookupOffsetNonSC(t3) {
        for (let n2 = this.tokenIndex; n2 < this.tokenCount; n2++) {
          const r2 = this.offsetAndType[n2] >> Ae2;
          if (r2 !== W2 && r2 !== X2 && t3-- === 0)
            return n2 - this.tokenIndex;
        }
        return De2;
      }
      lookupValue(t3, n2) {
        return t3 += this.tokenIndex, t3 < this.tokenCount ? $t2(
          this.source,
          this.offsetAndType[t3 - 1] & de2,
          this.offsetAndType[t3] & de2,
          n2
        ) : false;
      }
      getTokenStart(t3) {
        return t3 === this.tokenIndex ? this.tokenStart : t3 > 0 ? t3 < this.tokenCount ? this.offsetAndType[t3 - 1] & de2 : this.offsetAndType[this.tokenCount] & de2 : this.firstCharOffset;
      }
      substrToCursor(t3) {
        return this.source.substring(t3, this.tokenStart);
      }
      isBalanceEdge(t3) {
        return this.balance[this.tokenIndex] < t3;
      }
      isDelim(t3, n2) {
        return n2 ? this.lookupType(n2) === I2 && this.source.charCodeAt(this.lookupOffset(n2)) === t3 : this.tokenType === I2 && this.source.charCodeAt(this.tokenStart) === t3;
      }
      skip(t3) {
        let n2 = this.tokenIndex + t3;
        n2 < this.tokenCount ? (this.tokenIndex = n2, this.tokenStart = this.offsetAndType[n2 - 1] & de2, n2 = this.offsetAndType[n2], this.tokenType = n2 >> Ae2, this.tokenEnd = n2 & de2) : (this.tokenIndex = this.tokenCount, this.next());
      }
      next() {
        let t3 = this.tokenIndex + 1;
        t3 < this.tokenCount ? (this.tokenIndex = t3, this.tokenStart = this.tokenEnd, t3 = this.offsetAndType[t3], this.tokenType = t3 >> Ae2, this.tokenEnd = t3 & de2) : (this.eof = true, this.tokenIndex = this.tokenCount, this.tokenType = De2, this.tokenStart = this.tokenEnd = this.source.length);
      }
      skipSC() {
        for (; this.tokenType === W2 || this.tokenType === X2; )
          this.next();
      }
      skipUntilBalanced(t3, n2) {
        let r2 = t3, i2, o2;
        e:
          for (; r2 < this.tokenCount; r2++) {
            if (i2 = this.balance[r2], i2 < t3)
              break e;
            switch (o2 = r2 > 0 ? this.offsetAndType[r2 - 1] & de2 : this.firstCharOffset, n2(this.source.charCodeAt(o2))) {
              case 1:
                break e;
              case 2:
                r2++;
                break e;
              default:
                this.balance[i2] === r2 && (r2 = i2);
            }
          }
        this.skip(r2 - this.tokenIndex);
      }
      forEachToken(t3) {
        for (let n2 = 0, r2 = this.firstCharOffset; n2 < this.tokenCount; n2++) {
          const i2 = r2, o2 = this.offsetAndType[n2], s2 = o2 & de2, c2 = o2 >> Ae2;
          r2 = s2, t3(c2, i2, s2, n2);
        }
      }
      dump() {
        const t3 = new Array(this.tokenCount);
        return this.forEachToken((n2, r2, i2, o2) => {
          t3[o2] = {
            idx: o2,
            type: bo[n2],
            chunk: this.source.substring(r2, i2),
            balance: this.balance[o2]
          };
        }), t3;
      }
    }
    function gn2(e2, t3) {
      function n2(h2) {
        return h2 < c2 ? e2.charCodeAt(h2) : 0;
      }
      function r2() {
        if (a2 = mn2(e2, a2), qt2(n2(a2), n2(a2 + 1), n2(a2 + 2))) {
          u2 = z2, a2 = Dt2(e2, a2);
          return;
        }
        if (n2(a2) === 37) {
          u2 = B2, a2++;
          return;
        }
        u2 = L2;
      }
      function i2() {
        const h2 = a2;
        if (a2 = Dt2(e2, a2), $t2(e2, h2, a2, "url") && n2(a2) === 40) {
          if (a2 = Nt2(e2, a2 + 1), n2(a2) === 34 || n2(a2) === 39) {
            u2 = $5, a2 = h2 + 4;
            return;
          }
          s2();
          return;
        }
        if (n2(a2) === 40) {
          u2 = $5, a2++;
          return;
        }
        u2 = y2;
      }
      function o2(h2) {
        for (h2 || (h2 = n2(a2++)), u2 = Te2; a2 < e2.length; a2++) {
          const d2 = e2.charCodeAt(a2);
          switch (Tn2(d2)) {
            case h2:
              a2++;
              return;
            case Gt2:
              if (tn2(d2)) {
                a2 += Yn2(e2, a2, d2), u2 = dn2;
                return;
              }
              break;
            case 92:
              if (a2 === e2.length - 1)
                break;
              const m2 = n2(a2 + 1);
              tn2(m2) ? a2 += Yn2(e2, a2 + 1, m2) : Le2(d2, m2) && (a2 = ft2(e2, a2) - 1);
              break;
          }
        }
      }
      function s2() {
        for (u2 = te2, a2 = Nt2(e2, a2); a2 < e2.length; a2++) {
          const h2 = e2.charCodeAt(a2);
          switch (Tn2(h2)) {
            case 41:
              a2++;
              return;
            case Gt2:
              if (a2 = Nt2(e2, a2), n2(a2) === 41 || a2 >= e2.length) {
                a2 < e2.length && a2++;
                return;
              }
              a2 = On2(e2, a2), u2 = se2;
              return;
            case 34:
            case 39:
            case 40:
            case mo:
              a2 = On2(e2, a2), u2 = se2;
              return;
            case 92:
              if (Le2(h2, n2(a2 + 1))) {
                a2 = ft2(e2, a2) - 1;
                break;
              }
              a2 = On2(e2, a2), u2 = se2;
              return;
          }
        }
      }
      e2 = String(e2 || "");
      const c2 = e2.length;
      let l2 = po(n2(0)), a2 = l2, u2;
      for (; a2 < c2; ) {
        const h2 = e2.charCodeAt(a2);
        switch (Tn2(h2)) {
          case Gt2:
            u2 = W2, a2 = Nt2(e2, a2 + 1);
            break;
          case 34:
            o2();
            break;
          case 35:
            ho(n2(a2 + 1)) || Le2(n2(a2 + 1), n2(a2 + 2)) ? (u2 = F2, a2 = Dt2(e2, a2 + 1)) : (u2 = I2, a2++);
            break;
          case 39:
            o2();
            break;
          case 40:
            u2 = M2, a2++;
            break;
          case 41:
            u2 = E2, a2++;
            break;
          case 43:
            Cn2(h2, n2(a2 + 1), n2(a2 + 2)) ? r2() : (u2 = I2, a2++);
            break;
          case 44:
            u2 = ce2, a2++;
            break;
          case 45:
            Cn2(h2, n2(a2 + 1), n2(a2 + 2)) ? r2() : n2(a2 + 1) === 45 && n2(a2 + 2) === 62 ? (u2 = ae2, a2 = a2 + 3) : qt2(h2, n2(a2 + 1), n2(a2 + 2)) ? i2() : (u2 = I2, a2++);
            break;
          case 46:
            Cn2(h2, n2(a2 + 1), n2(a2 + 2)) ? r2() : (u2 = I2, a2++);
            break;
          case 47:
            n2(a2 + 1) === 42 ? (u2 = X2, a2 = e2.indexOf("*/", a2 + 2), a2 = a2 === -1 ? e2.length : a2 + 2) : (u2 = I2, a2++);
            break;
          case 58:
            u2 = ne2, a2++;
            break;
          case 59:
            u2 = re2, a2++;
            break;
          case 60:
            n2(a2 + 1) === 33 && n2(a2 + 2) === 45 && n2(a2 + 3) === 45 ? (u2 = Rt2, a2 = a2 + 4) : (u2 = I2, a2++);
            break;
          case 64:
            qt2(n2(a2 + 1), n2(a2 + 2), n2(a2 + 3)) ? (u2 = G2, a2 = Dt2(e2, a2 + 1)) : (u2 = I2, a2++);
            break;
          case 91:
            u2 = fe2, a2++;
            break;
          case 92:
            Le2(h2, n2(a2 + 1)) ? i2() : (u2 = I2, a2++);
            break;
          case 93:
            u2 = Se2, a2++;
            break;
          case 123:
            u2 = V2, a2++;
            break;
          case 125:
            u2 = ue2, a2++;
            break;
          case fo:
            r2();
            break;
          case mr2:
            i2();
            break;
          default:
            u2 = I2, a2++;
        }
        t3(u2, l2, l2 = a2);
      }
    }
    let nt2 = null;
    class q2 {
      static createItem(t3) {
        return {
          prev: null,
          next: null,
          data: t3
        };
      }
      constructor() {
        this.head = null, this.tail = null, this.cursor = null;
      }
      createItem(t3) {
        return q2.createItem(t3);
      }
      // cursor helpers
      allocateCursor(t3, n2) {
        let r2;
        return nt2 !== null ? (r2 = nt2, nt2 = nt2.cursor, r2.prev = t3, r2.next = n2, r2.cursor = this.cursor) : r2 = {
          prev: t3,
          next: n2,
          cursor: this.cursor
        }, this.cursor = r2, r2;
      }
      releaseCursor() {
        const { cursor: t3 } = this;
        this.cursor = t3.cursor, t3.prev = null, t3.next = null, t3.cursor = nt2, nt2 = t3;
      }
      updateCursors(t3, n2, r2, i2) {
        let { cursor: o2 } = this;
        for (; o2 !== null; )
          o2.prev === t3 && (o2.prev = n2), o2.next === r2 && (o2.next = i2), o2 = o2.cursor;
      }
      *[Symbol.iterator]() {
        for (let t3 = this.head; t3 !== null; t3 = t3.next)
          yield t3.data;
      }
      // getters
      get size() {
        let t3 = 0;
        for (let n2 = this.head; n2 !== null; n2 = n2.next)
          t3++;
        return t3;
      }
      get isEmpty() {
        return this.head === null;
      }
      get first() {
        return this.head && this.head.data;
      }
      get last() {
        return this.tail && this.tail.data;
      }
      // convertors
      fromArray(t3) {
        let n2 = null;
        this.head = null;
        for (let r2 of t3) {
          const i2 = q2.createItem(r2);
          n2 !== null ? n2.next = i2 : this.head = i2, i2.prev = n2, n2 = i2;
        }
        return this.tail = n2, this;
      }
      toArray() {
        return [...this];
      }
      toJSON() {
        return [...this];
      }
      // array-like methods
      forEach(t3, n2 = this) {
        const r2 = this.allocateCursor(null, this.head);
        for (; r2.next !== null; ) {
          const i2 = r2.next;
          r2.next = i2.next, t3.call(n2, i2.data, i2, this);
        }
        this.releaseCursor();
      }
      forEachRight(t3, n2 = this) {
        const r2 = this.allocateCursor(this.tail, null);
        for (; r2.prev !== null; ) {
          const i2 = r2.prev;
          r2.prev = i2.prev, t3.call(n2, i2.data, i2, this);
        }
        this.releaseCursor();
      }
      reduce(t3, n2, r2 = this) {
        let i2 = this.allocateCursor(null, this.head), o2 = n2, s2;
        for (; i2.next !== null; )
          s2 = i2.next, i2.next = s2.next, o2 = t3.call(r2, o2, s2.data, s2, this);
        return this.releaseCursor(), o2;
      }
      reduceRight(t3, n2, r2 = this) {
        let i2 = this.allocateCursor(this.tail, null), o2 = n2, s2;
        for (; i2.prev !== null; )
          s2 = i2.prev, i2.prev = s2.prev, o2 = t3.call(r2, o2, s2.data, s2, this);
        return this.releaseCursor(), o2;
      }
      some(t3, n2 = this) {
        for (let r2 = this.head; r2 !== null; r2 = r2.next)
          if (t3.call(n2, r2.data, r2, this))
            return true;
        return false;
      }
      map(t3, n2 = this) {
        const r2 = new q2();
        for (let i2 = this.head; i2 !== null; i2 = i2.next)
          r2.appendData(t3.call(n2, i2.data, i2, this));
        return r2;
      }
      filter(t3, n2 = this) {
        const r2 = new q2();
        for (let i2 = this.head; i2 !== null; i2 = i2.next)
          t3.call(n2, i2.data, i2, this) && r2.appendData(i2.data);
        return r2;
      }
      nextUntil(t3, n2, r2 = this) {
        if (t3 === null)
          return;
        const i2 = this.allocateCursor(null, t3);
        for (; i2.next !== null; ) {
          const o2 = i2.next;
          if (i2.next = o2.next, n2.call(r2, o2.data, o2, this))
            break;
        }
        this.releaseCursor();
      }
      prevUntil(t3, n2, r2 = this) {
        if (t3 === null)
          return;
        const i2 = this.allocateCursor(t3, null);
        for (; i2.prev !== null; ) {
          const o2 = i2.prev;
          if (i2.prev = o2.prev, n2.call(r2, o2.data, o2, this))
            break;
        }
        this.releaseCursor();
      }
      // mutation
      clear() {
        this.head = null, this.tail = null;
      }
      copy() {
        const t3 = new q2();
        for (let n2 of this)
          t3.appendData(n2);
        return t3;
      }
      prepend(t3) {
        return this.updateCursors(null, t3, this.head, t3), this.head !== null ? (this.head.prev = t3, t3.next = this.head) : this.tail = t3, this.head = t3, this;
      }
      prependData(t3) {
        return this.prepend(q2.createItem(t3));
      }
      append(t3) {
        return this.insert(t3);
      }
      appendData(t3) {
        return this.insert(q2.createItem(t3));
      }
      insert(t3, n2 = null) {
        if (n2 !== null)
          if (this.updateCursors(n2.prev, t3, n2, t3), n2.prev === null) {
            if (this.head !== n2)
              throw new Error("before doesn't belong to list");
            this.head = t3, n2.prev = t3, t3.next = n2, this.updateCursors(null, t3);
          } else
            n2.prev.next = t3, t3.prev = n2.prev, n2.prev = t3, t3.next = n2;
        else
          this.updateCursors(this.tail, t3, null, t3), this.tail !== null ? (this.tail.next = t3, t3.prev = this.tail) : this.head = t3, this.tail = t3;
        return this;
      }
      insertData(t3, n2) {
        return this.insert(q2.createItem(t3), n2);
      }
      remove(t3) {
        if (this.updateCursors(t3, t3.prev, t3, t3.next), t3.prev !== null)
          t3.prev.next = t3.next;
        else {
          if (this.head !== t3)
            throw new Error("item doesn't belong to list");
          this.head = t3.next;
        }
        if (t3.next !== null)
          t3.next.prev = t3.prev;
        else {
          if (this.tail !== t3)
            throw new Error("item doesn't belong to list");
          this.tail = t3.prev;
        }
        return t3.prev = null, t3.next = null, t3;
      }
      push(t3) {
        this.insert(q2.createItem(t3));
      }
      pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
      }
      unshift(t3) {
        this.prepend(q2.createItem(t3));
      }
      shift() {
        return this.head !== null ? this.remove(this.head) : null;
      }
      prependList(t3) {
        return this.insertList(t3, this.head);
      }
      appendList(t3) {
        return this.insertList(t3);
      }
      insertList(t3, n2) {
        return t3.head === null ? this : (n2 != null ? (this.updateCursors(n2.prev, t3.tail, n2, t3.head), n2.prev !== null ? (n2.prev.next = t3.head, t3.head.prev = n2.prev) : this.head = t3.head, n2.prev = t3.tail, t3.tail.next = n2) : (this.updateCursors(this.tail, t3.tail, null, t3.head), this.tail !== null ? (this.tail.next = t3.head, t3.head.prev = this.tail) : this.head = t3.head, this.tail = t3.tail), t3.head = null, t3.tail = null, this);
      }
      replace(t3, n2) {
        "head" in n2 ? this.insertList(n2, t3) : this.insert(n2, t3), this.remove(t3);
      }
    }
    function bn2(e2, t3) {
      const n2 = Object.create(SyntaxError.prototype), r2 = new Error();
      return Object.assign(n2, {
        name: e2,
        message: t3,
        get stack() {
          return (r2.stack || "").replace(/^(.+\n){1,3}/, `${e2}: ${t3}
`);
        }
      });
    }
    const En2 = 100, Ur2 = 60, qr2 = "    ";
    function Gr2({ source: e2, line: t3, column: n2, baseLine: r2, baseColumn: i2 }, o2) {
      function s2(w2, k2) {
        return a2.slice(w2, k2).map(
          (C2, b2) => String(w2 + b2 + 1).padStart(d2) + " |" + C2
        ).join(`
`);
      }
      const c2 = `
`.repeat(Math.max(r2 - 1, 0)), l2 = " ".repeat(Math.max(i2 - 1, 0)), a2 = (c2 + l2 + e2).split(/\r\n?|\n|\f/), u2 = Math.max(1, t3 - o2) - 1, h2 = Math.min(t3 + o2, a2.length + 1), d2 = Math.max(4, String(h2).length) + 1;
      let m2 = 0;
      n2 += (qr2.length - 1) * (a2[t3 - 1].substr(0, n2 - 1).match(/\t/g) || []).length, n2 > En2 && (m2 = n2 - Ur2 + 3, n2 = Ur2 - 2);
      for (let w2 = u2; w2 <= h2; w2++)
        w2 >= 0 && w2 < a2.length && (a2[w2] = a2[w2].replace(/\t/g, qr2), a2[w2] = (m2 > 0 && a2[w2].length > m2 ? "\u2026" : "") + a2[w2].substr(m2, En2 - 2) + (a2[w2].length > m2 + En2 - 1 ? "\u2026" : ""));
      return [
        s2(u2, t3),
        new Array(n2 + d2 + 2).join("-") + "^",
        s2(t3, h2)
      ].filter(Boolean).join(`
`).replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
    }
    function Vr2(e2, t3, n2, r2, i2, o2 = 1, s2 = 1) {
      return Object.assign(bn2("SyntaxError", e2), {
        source: t3,
        offset: n2,
        line: r2,
        column: i2,
        sourceFragment(l2) {
          return Gr2({ source: t3, line: r2, column: i2, baseLine: o2, baseColumn: s2 }, isNaN(l2) ? 0 : l2);
        },
        get formattedMessage() {
          return `Parse error: ${e2}
` + Gr2({ source: t3, line: r2, column: i2, baseLine: o2, baseColumn: s2 }, 2);
        }
      });
    }
    function Za(e2) {
      const t3 = this.createList();
      let n2 = false;
      const r2 = {
        recognizer: e2
      };
      for (; !this.eof; ) {
        switch (this.tokenType) {
          case X2:
            this.next();
            continue;
          case W2:
            n2 = true, this.next();
            continue;
        }
        let i2 = e2.getNode.call(this, r2);
        if (i2 === void 0)
          break;
        n2 && (e2.onWhiteSpace && e2.onWhiteSpace.call(this, i2, t3, r2), n2 = false), t3.push(i2);
      }
      return n2 && e2.onWhiteSpace && e2.onWhiteSpace.call(this, null, t3, r2), t3;
    }
    const Kr2 = () => {
    }, Ja = 33, el = 35, Ln2 = 59, Yr2 = 123, Qr2 = 0;
    function tl(e2) {
      return function() {
        return this[e2]();
      };
    }
    function $n2(e2) {
      const t3 = /* @__PURE__ */ Object.create(null);
      for (const n2 of Object.keys(e2)) {
        const r2 = e2[n2], i2 = r2.parse || r2;
        i2 && (t3[n2] = i2);
      }
      return t3;
    }
    function nl(e2) {
      const t3 = {
        context: /* @__PURE__ */ Object.create(null),
        features: Object.assign(/* @__PURE__ */ Object.create(null), e2.features),
        scope: Object.assign(/* @__PURE__ */ Object.create(null), e2.scope),
        atrule: $n2(e2.atrule),
        pseudo: $n2(e2.pseudo),
        node: $n2(e2.node)
      };
      for (const [n2, r2] of Object.entries(e2.parseContext))
        switch (typeof r2) {
          case "function":
            t3.context[n2] = r2;
            break;
          case "string":
            t3.context[n2] = tl(r2);
            break;
        }
      return _2(_2({
        config: t3
      }, t3), t3.node);
    }
    function rl(e2) {
      let t3 = "", n2 = "<unknown>", r2 = false, i2 = Kr2, o2 = false;
      const s2 = new Ya(), c2 = Object.assign(new Xa(), nl(e2 || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,
        readSequence: Za,
        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(a2) {
          return a2 === Yr2 ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(a2) {
          return a2 === Yr2 || a2 === Ln2 ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(a2) {
          return a2 === Ja || a2 === Ln2 ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(a2) {
          return a2 === Ln2 ? 2 : 0;
        },
        createList() {
          return new q2();
        },
        createSingleNodeList(a2) {
          return new q2().appendData(a2);
        },
        getFirstListNode(a2) {
          return a2 && a2.first;
        },
        getLastListNode(a2) {
          return a2 && a2.last;
        },
        parseWithFallback(a2, u2) {
          const h2 = this.tokenIndex;
          try {
            return a2.call(this);
          } catch (d2) {
            if (o2)
              throw d2;
            this.skip(h2 - this.tokenIndex);
            const m2 = u2.call(this);
            return o2 = true, i2(d2, m2), o2 = false, m2;
          }
        },
        lookupNonWSType(a2) {
          let u2;
          do
            if (u2 = this.lookupType(a2++), u2 !== W2 && u2 !== X2)
              return u2;
          while (u2 !== Qr2);
          return Qr2;
        },
        charCodeAt(a2) {
          return a2 >= 0 && a2 < t3.length ? t3.charCodeAt(a2) : 0;
        },
        substring(a2, u2) {
          return t3.substring(a2, u2);
        },
        substrToCursor(a2) {
          return this.source.substring(a2, this.tokenStart);
        },
        cmpChar(a2, u2) {
          return ht2(t3, a2, u2);
        },
        cmpStr(a2, u2, h2) {
          return $t2(t3, a2, u2, h2);
        },
        consume(a2) {
          const u2 = this.tokenStart;
          return this.eat(a2), this.substrToCursor(u2);
        },
        consumeFunctionName() {
          const a2 = t3.substring(this.tokenStart, this.tokenEnd - 1);
          return this.eat($5), a2;
        },
        consumeNumber(a2) {
          const u2 = t3.substring(this.tokenStart, mn2(t3, this.tokenStart));
          return this.eat(a2), u2;
        },
        eat(a2) {
          if (this.tokenType !== a2) {
            const u2 = bo[a2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m2) => m2.toUpperCase());
            let h2 = `${/[[\](){}]/.test(u2) ? `"${u2}"` : u2} is expected`, d2 = this.tokenStart;
            switch (a2) {
              case y2:
                this.tokenType === $5 || this.tokenType === te2 ? (d2 = this.tokenEnd - 1, h2 = "Identifier is expected but function found") : h2 = "Identifier is expected";
                break;
              case F2:
                this.isDelim(el) && (this.next(), d2++, h2 = "Name is expected");
                break;
              case B2:
                this.tokenType === L2 && (d2 = this.tokenEnd, h2 = "Percent sign is expected");
                break;
            }
            this.error(h2, d2);
          }
          this.next();
        },
        eatIdent(a2) {
          (this.tokenType !== y2 || this.lookupValue(0, a2) === false) && this.error(`Identifier "${a2}" is expected`), this.next();
        },
        eatDelim(a2) {
          this.isDelim(a2) || this.error(`Delim "${String.fromCharCode(a2)}" is expected`), this.next();
        },
        getLocation(a2, u2) {
          return r2 ? s2.getLocationRange(
            a2,
            u2,
            n2
          ) : null;
        },
        getLocationFromList(a2) {
          if (r2) {
            const u2 = this.getFirstListNode(a2), h2 = this.getLastListNode(a2);
            return s2.getLocationRange(
              u2 !== null ? u2.loc.start.offset - s2.startOffset : this.tokenStart,
              h2 !== null ? h2.loc.end.offset - s2.startOffset : this.tokenStart,
              n2
            );
          }
          return null;
        },
        error(a2, u2) {
          const h2 = typeof u2 != "undefined" && u2 < t3.length ? s2.getLocation(u2) : this.eof ? s2.getLocation(Ga(t3, t3.length - 1)) : s2.getLocation(this.tokenStart);
          throw new Vr2(
            a2 || "Unexpected input",
            t3,
            h2.offset,
            h2.line,
            h2.column,
            s2.startLine,
            s2.startColumn
          );
        }
      });
      return Object.assign(function(a2, u2) {
        t3 = a2, u2 = u2 || {}, c2.setSource(t3, gn2), s2.setSource(
          t3,
          u2.offset,
          u2.line,
          u2.column
        ), n2 = u2.filename || "<unknown>", r2 = !!u2.positions, i2 = typeof u2.onParseError == "function" ? u2.onParseError : Kr2, o2 = false, c2.parseAtrulePrelude = "parseAtrulePrelude" in u2 ? !!u2.parseAtrulePrelude : true, c2.parseRulePrelude = "parseRulePrelude" in u2 ? !!u2.parseRulePrelude : true, c2.parseValue = "parseValue" in u2 ? !!u2.parseValue : true, c2.parseCustomProperty = "parseCustomProperty" in u2 ? !!u2.parseCustomProperty : false;
        const { context: h2 = "default", onComment: d2 } = u2;
        if (!(h2 in c2.context))
          throw new Error("Unknown context `" + h2 + "`");
        typeof d2 == "function" && c2.forEachToken((w2, k2, C2) => {
          if (w2 === X2) {
            const b2 = c2.getLocation(k2, C2), x2 = $t2(t3, C2 - 2, C2, "*/") ? t3.slice(k2 + 2, C2 - 2) : t3.slice(k2 + 2, C2);
            d2(x2, b2);
          }
        });
        const m2 = c2.context[h2].call(c2, u2);
        return c2.eof || c2.error(), m2;
      }, {
        SyntaxError: Vr2,
        config: c2.config
      });
    }
    var gr2 = {}, br2 = {}, Xr2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    br2.encode = function(e2) {
      if (0 <= e2 && e2 < Xr2.length)
        return Xr2[e2];
      throw new TypeError("Must be between 0 and 63: " + e2);
    };
    br2.decode = function(e2) {
      var t3 = 65, n2 = 90, r2 = 97, i2 = 122, o2 = 48, s2 = 57, c2 = 43, l2 = 47, a2 = 26, u2 = 52;
      return t3 <= e2 && e2 <= n2 ? e2 - t3 : r2 <= e2 && e2 <= i2 ? e2 - r2 + a2 : o2 <= e2 && e2 <= s2 ? e2 - o2 + u2 : e2 == c2 ? 62 : e2 == l2 ? 63 : -1;
    };
    var yo = br2, yr2 = 5, ko = 1 << yr2, xo = ko - 1, wo = ko;
    function il(e2) {
      return e2 < 0 ? (-e2 << 1) + 1 : (e2 << 1) + 0;
    }
    function ol(e2) {
      var t3 = (e2 & 1) === 1, n2 = e2 >> 1;
      return t3 ? -n2 : n2;
    }
    gr2.encode = function(t3) {
      var n2 = "", r2, i2 = il(t3);
      do
        r2 = i2 & xo, i2 >>>= yr2, i2 > 0 && (r2 |= wo), n2 += yo.encode(r2);
      while (i2 > 0);
      return n2;
    };
    gr2.decode = function(t3, n2, r2) {
      var i2 = t3.length, o2 = 0, s2 = 0, c2, l2;
      do {
        if (n2 >= i2)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (l2 = yo.decode(t3.charCodeAt(n2++)), l2 === -1)
          throw new Error("Invalid base64 digit: " + t3.charAt(n2 - 1));
        c2 = !!(l2 & wo), l2 &= xo, o2 = o2 + (l2 << s2), s2 += yr2;
      } while (c2);
      r2.value = ol(o2), r2.rest = n2;
    };
    var yn2 = {};
    (function(e2) {
      function t3(p2, f2, S2) {
        if (f2 in p2)
          return p2[f2];
        if (arguments.length === 3)
          return S2;
        throw new Error('"' + f2 + '" is a required argument.');
      }
      e2.getArg = t3;
      var n2 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r2 = /^data:.+\,.+$/;
      function i2(p2) {
        var f2 = p2.match(n2);
        return f2 ? {
          scheme: f2[1],
          auth: f2[2],
          host: f2[3],
          port: f2[4],
          path: f2[5]
        } : null;
      }
      e2.urlParse = i2;
      function o2(p2) {
        var f2 = "";
        return p2.scheme && (f2 += p2.scheme + ":"), f2 += "//", p2.auth && (f2 += p2.auth + "@"), p2.host && (f2 += p2.host), p2.port && (f2 += ":" + p2.port), p2.path && (f2 += p2.path), f2;
      }
      e2.urlGenerate = o2;
      var s2 = 32;
      function c2(p2) {
        var f2 = [];
        return function(S2) {
          for (var g2 = 0; g2 < f2.length; g2++)
            if (f2[g2].input === S2) {
              var K2 = f2[0];
              return f2[0] = f2[g2], f2[g2] = K2, f2[0].result;
            }
          var R2 = p2(S2);
          return f2.unshift({
            input: S2,
            result: R2
          }), f2.length > s2 && f2.pop(), R2;
        };
      }
      var l2 = c2(function(f2) {
        var S2 = f2, g2 = i2(f2);
        if (g2) {
          if (!g2.path)
            return f2;
          S2 = g2.path;
        }
        for (var K2 = e2.isAbsolute(S2), R2 = [], be2 = 0, Y2 = 0; ; )
          if (be2 = Y2, Y2 = S2.indexOf("/", be2), Y2 === -1) {
            R2.push(S2.slice(be2));
            break;
          } else
            for (R2.push(S2.slice(be2, Y2)); Y2 < S2.length && S2[Y2] === "/"; )
              Y2++;
        for (var ze2, Ue2 = 0, Y2 = R2.length - 1; Y2 >= 0; Y2--)
          ze2 = R2[Y2], ze2 === "." ? R2.splice(Y2, 1) : ze2 === ".." ? Ue2++ : Ue2 > 0 && (ze2 === "" ? (R2.splice(Y2 + 1, Ue2), Ue2 = 0) : (R2.splice(Y2, 2), Ue2--));
        return S2 = R2.join("/"), S2 === "" && (S2 = K2 ? "/" : "."), g2 ? (g2.path = S2, o2(g2)) : S2;
      });
      e2.normalize = l2;
      function a2(p2, f2) {
        p2 === "" && (p2 = "."), f2 === "" && (f2 = ".");
        var S2 = i2(f2), g2 = i2(p2);
        if (g2 && (p2 = g2.path || "/"), S2 && !S2.scheme)
          return g2 && (S2.scheme = g2.scheme), o2(S2);
        if (S2 || f2.match(r2))
          return f2;
        if (g2 && !g2.host && !g2.path)
          return g2.host = f2, o2(g2);
        var K2 = f2.charAt(0) === "/" ? f2 : l2(p2.replace(/\/+$/, "") + "/" + f2);
        return g2 ? (g2.path = K2, o2(g2)) : K2;
      }
      e2.join = a2, e2.isAbsolute = function(p2) {
        return p2.charAt(0) === "/" || n2.test(p2);
      };
      function u2(p2, f2) {
        p2 === "" && (p2 = "."), p2 = p2.replace(/\/$/, "");
        for (var S2 = 0; f2.indexOf(p2 + "/") !== 0; ) {
          var g2 = p2.lastIndexOf("/");
          if (g2 < 0 || (p2 = p2.slice(0, g2), p2.match(/^([^\/]+:\/)?\/*$/)))
            return f2;
          ++S2;
        }
        return Array(S2 + 1).join("../") + f2.substr(p2.length + 1);
      }
      e2.relative = u2;
      var h2 = function() {
        var p2 = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in p2);
      }();
      function d2(p2) {
        return p2;
      }
      function m2(p2) {
        return k2(p2) ? "$" + p2 : p2;
      }
      e2.toSetString = h2 ? d2 : m2;
      function w2(p2) {
        return k2(p2) ? p2.slice(1) : p2;
      }
      e2.fromSetString = h2 ? d2 : w2;
      function k2(p2) {
        if (!p2)
          return false;
        var f2 = p2.length;
        if (f2 < 9 || p2.charCodeAt(f2 - 1) !== 95 || p2.charCodeAt(f2 - 2) !== 95 || p2.charCodeAt(f2 - 3) !== 111 || p2.charCodeAt(f2 - 4) !== 116 || p2.charCodeAt(f2 - 5) !== 111 || p2.charCodeAt(f2 - 6) !== 114 || p2.charCodeAt(f2 - 7) !== 112 || p2.charCodeAt(f2 - 8) !== 95 || p2.charCodeAt(f2 - 9) !== 95)
          return false;
        for (var S2 = f2 - 10; S2 >= 0; S2--)
          if (p2.charCodeAt(S2) !== 36)
            return false;
        return true;
      }
      function C2(p2, f2, S2) {
        var g2 = v2(p2.source, f2.source);
        return g2 !== 0 || (g2 = p2.originalLine - f2.originalLine, g2 !== 0) || (g2 = p2.originalColumn - f2.originalColumn, g2 !== 0 || S2) || (g2 = p2.generatedColumn - f2.generatedColumn, g2 !== 0) || (g2 = p2.generatedLine - f2.generatedLine, g2 !== 0) ? g2 : v2(p2.name, f2.name);
      }
      e2.compareByOriginalPositions = C2;
      function b2(p2, f2, S2) {
        var g2;
        return g2 = p2.originalLine - f2.originalLine, g2 !== 0 || (g2 = p2.originalColumn - f2.originalColumn, g2 !== 0 || S2) || (g2 = p2.generatedColumn - f2.generatedColumn, g2 !== 0) || (g2 = p2.generatedLine - f2.generatedLine, g2 !== 0) ? g2 : v2(p2.name, f2.name);
      }
      e2.compareByOriginalPositionsNoSource = b2;
      function x2(p2, f2, S2) {
        var g2 = p2.generatedLine - f2.generatedLine;
        return g2 !== 0 || (g2 = p2.generatedColumn - f2.generatedColumn, g2 !== 0 || S2) || (g2 = v2(p2.source, f2.source), g2 !== 0) || (g2 = p2.originalLine - f2.originalLine, g2 !== 0) || (g2 = p2.originalColumn - f2.originalColumn, g2 !== 0) ? g2 : v2(p2.name, f2.name);
      }
      e2.compareByGeneratedPositionsDeflated = x2;
      function T2(p2, f2, S2) {
        var g2 = p2.generatedColumn - f2.generatedColumn;
        return g2 !== 0 || S2 || (g2 = v2(p2.source, f2.source), g2 !== 0) || (g2 = p2.originalLine - f2.originalLine, g2 !== 0) || (g2 = p2.originalColumn - f2.originalColumn, g2 !== 0) ? g2 : v2(p2.name, f2.name);
      }
      e2.compareByGeneratedPositionsDeflatedNoLine = T2;
      function v2(p2, f2) {
        return p2 === f2 ? 0 : p2 === null ? 1 : f2 === null ? -1 : p2 > f2 ? 1 : -1;
      }
      function A2(p2, f2) {
        var S2 = p2.generatedLine - f2.generatedLine;
        return S2 !== 0 || (S2 = p2.generatedColumn - f2.generatedColumn, S2 !== 0) || (S2 = v2(p2.source, f2.source), S2 !== 0) || (S2 = p2.originalLine - f2.originalLine, S2 !== 0) || (S2 = p2.originalColumn - f2.originalColumn, S2 !== 0) ? S2 : v2(p2.name, f2.name);
      }
      e2.compareByGeneratedPositionsInflated = A2;
      function P2(p2) {
        return JSON.parse(p2.replace(/^\)]}'[^\n]*\n/, ""));
      }
      e2.parseSourceMapInput = P2;
      function O2(p2, f2, S2) {
        if (f2 = f2 || "", p2 && (p2[p2.length - 1] !== "/" && f2[0] !== "/" && (p2 += "/"), f2 = p2 + f2), S2) {
          var g2 = i2(S2);
          if (!g2)
            throw new Error("sourceMapURL could not be parsed");
          if (g2.path) {
            var K2 = g2.path.lastIndexOf("/");
            K2 >= 0 && (g2.path = g2.path.substring(0, K2 + 1));
          }
          f2 = a2(o2(g2), f2);
        }
        return l2(f2);
      }
      e2.computeSourceURL = O2;
    })(yn2);
    var vo = {}, kr2 = yn2, xr2 = Object.prototype.hasOwnProperty, Ye2 = typeof Map != "undefined";
    function Re2() {
      this._array = [], this._set = Ye2 ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    Re2.fromArray = function(t3, n2) {
      for (var r2 = new Re2(), i2 = 0, o2 = t3.length; i2 < o2; i2++)
        r2.add(t3[i2], n2);
      return r2;
    };
    Re2.prototype.size = function() {
      return Ye2 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    Re2.prototype.add = function(t3, n2) {
      var r2 = Ye2 ? t3 : kr2.toSetString(t3), i2 = Ye2 ? this.has(t3) : xr2.call(this._set, r2), o2 = this._array.length;
      (!i2 || n2) && this._array.push(t3), i2 || (Ye2 ? this._set.set(t3, o2) : this._set[r2] = o2);
    };
    Re2.prototype.has = function(t3) {
      if (Ye2)
        return this._set.has(t3);
      var n2 = kr2.toSetString(t3);
      return xr2.call(this._set, n2);
    };
    Re2.prototype.indexOf = function(t3) {
      if (Ye2) {
        var n2 = this._set.get(t3);
        if (n2 >= 0)
          return n2;
      } else {
        var r2 = kr2.toSetString(t3);
        if (xr2.call(this._set, r2))
          return this._set[r2];
      }
      throw new Error('"' + t3 + '" is not in the set.');
    };
    Re2.prototype.at = function(t3) {
      if (t3 >= 0 && t3 < this._array.length)
        return this._array[t3];
      throw new Error("No element indexed by " + t3);
    };
    Re2.prototype.toArray = function() {
      return this._array.slice();
    };
    vo.ArraySet = Re2;
    var So = {}, Co = yn2;
    function sl(e2, t3) {
      var n2 = e2.generatedLine, r2 = t3.generatedLine, i2 = e2.generatedColumn, o2 = t3.generatedColumn;
      return r2 > n2 || r2 == n2 && o2 >= i2 || Co.compareByGeneratedPositionsInflated(e2, t3) <= 0;
    }
    function kn2() {
      this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    kn2.prototype.unsortedForEach = function(t3, n2) {
      this._array.forEach(t3, n2);
    };
    kn2.prototype.add = function(t3) {
      sl(this._last, t3) ? (this._last = t3, this._array.push(t3)) : (this._sorted = false, this._array.push(t3));
    };
    kn2.prototype.toArray = function() {
      return this._sorted || (this._array.sort(Co.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
    };
    So.MappingList = kn2;
    var yt2 = gr2, U2 = yn2, rn2 = vo.ArraySet, al = So.MappingList;
    function ge2(e2) {
      e2 || (e2 = {}), this._file = U2.getArg(e2, "file", null), this._sourceRoot = U2.getArg(e2, "sourceRoot", null), this._skipValidation = U2.getArg(e2, "skipValidation", false), this._ignoreInvalidMapping = U2.getArg(e2, "ignoreInvalidMapping", false), this._sources = new rn2(), this._names = new rn2(), this._mappings = new al(), this._sourcesContents = null;
    }
    ge2.prototype._version = 3;
    ge2.fromSourceMap = function(t3, n2) {
      var r2 = t3.sourceRoot, i2 = new ge2(Object.assign(n2 || {}, {
        file: t3.file,
        sourceRoot: r2
      }));
      return t3.eachMapping(function(o2) {
        var s2 = {
          generated: {
            line: o2.generatedLine,
            column: o2.generatedColumn
          }
        };
        o2.source != null && (s2.source = o2.source, r2 != null && (s2.source = U2.relative(r2, s2.source)), s2.original = {
          line: o2.originalLine,
          column: o2.originalColumn
        }, o2.name != null && (s2.name = o2.name)), i2.addMapping(s2);
      }), t3.sources.forEach(function(o2) {
        var s2 = o2;
        r2 !== null && (s2 = U2.relative(r2, o2)), i2._sources.has(s2) || i2._sources.add(s2);
        var c2 = t3.sourceContentFor(o2);
        c2 != null && i2.setSourceContent(o2, c2);
      }), i2;
    };
    ge2.prototype.addMapping = function(t3) {
      var n2 = U2.getArg(t3, "generated"), r2 = U2.getArg(t3, "original", null), i2 = U2.getArg(t3, "source", null), o2 = U2.getArg(t3, "name", null);
      !this._skipValidation && this._validateMapping(n2, r2, i2, o2) === false || (i2 != null && (i2 = String(i2), this._sources.has(i2) || this._sources.add(i2)), o2 != null && (o2 = String(o2), this._names.has(o2) || this._names.add(o2)), this._mappings.add({
        generatedLine: n2.line,
        generatedColumn: n2.column,
        originalLine: r2 != null && r2.line,
        originalColumn: r2 != null && r2.column,
        source: i2,
        name: o2
      }));
    };
    ge2.prototype.setSourceContent = function(t3, n2) {
      var r2 = t3;
      this._sourceRoot != null && (r2 = U2.relative(this._sourceRoot, r2)), n2 != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[U2.toSetString(r2)] = n2) : this._sourcesContents && (delete this._sourcesContents[U2.toSetString(r2)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
    };
    ge2.prototype.applySourceMap = function(t3, n2, r2) {
      var i2 = n2;
      if (n2 == null) {
        if (t3.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        i2 = t3.file;
      }
      var o2 = this._sourceRoot;
      o2 != null && (i2 = U2.relative(o2, i2));
      var s2 = new rn2(), c2 = new rn2();
      this._mappings.unsortedForEach(function(l2) {
        if (l2.source === i2 && l2.originalLine != null) {
          var a2 = t3.originalPositionFor({
            line: l2.originalLine,
            column: l2.originalColumn
          });
          a2.source != null && (l2.source = a2.source, r2 != null && (l2.source = U2.join(r2, l2.source)), o2 != null && (l2.source = U2.relative(o2, l2.source)), l2.originalLine = a2.line, l2.originalColumn = a2.column, a2.name != null && (l2.name = a2.name));
        }
        var u2 = l2.source;
        u2 != null && !s2.has(u2) && s2.add(u2);
        var h2 = l2.name;
        h2 != null && !c2.has(h2) && c2.add(h2);
      }, this), this._sources = s2, this._names = c2, t3.sources.forEach(function(l2) {
        var a2 = t3.sourceContentFor(l2);
        a2 != null && (r2 != null && (l2 = U2.join(r2, l2)), o2 != null && (l2 = U2.relative(o2, l2)), this.setSourceContent(l2, a2));
      }, this);
    };
    ge2.prototype._validateMapping = function(t3, n2, r2, i2) {
      if (n2 && typeof n2.line != "number" && typeof n2.column != "number") {
        var o2 = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping)
          return typeof console != "undefined" && console.warn && console.warn(o2), false;
        throw new Error(o2);
      }
      if (!(t3 && "line" in t3 && "column" in t3 && t3.line > 0 && t3.column >= 0 && !n2 && !r2 && !i2)) {
        if (t3 && "line" in t3 && "column" in t3 && n2 && "line" in n2 && "column" in n2 && t3.line > 0 && t3.column >= 0 && n2.line > 0 && n2.column >= 0 && r2)
          return;
        var o2 = "Invalid mapping: " + JSON.stringify({
          generated: t3,
          source: r2,
          original: n2,
          name: i2
        });
        if (this._ignoreInvalidMapping)
          return typeof console != "undefined" && console.warn && console.warn(o2), false;
        throw new Error(o2);
      }
    };
    ge2.prototype._serializeMappings = function() {
      for (var t3 = 0, n2 = 1, r2 = 0, i2 = 0, o2 = 0, s2 = 0, c2 = "", l2, a2, u2, h2, d2 = this._mappings.toArray(), m2 = 0, w2 = d2.length; m2 < w2; m2++) {
        if (a2 = d2[m2], l2 = "", a2.generatedLine !== n2)
          for (t3 = 0; a2.generatedLine !== n2; )
            l2 += ";", n2++;
        else if (m2 > 0) {
          if (!U2.compareByGeneratedPositionsInflated(a2, d2[m2 - 1]))
            continue;
          l2 += ",";
        }
        l2 += yt2.encode(a2.generatedColumn - t3), t3 = a2.generatedColumn, a2.source != null && (h2 = this._sources.indexOf(a2.source), l2 += yt2.encode(h2 - s2), s2 = h2, l2 += yt2.encode(a2.originalLine - 1 - i2), i2 = a2.originalLine - 1, l2 += yt2.encode(a2.originalColumn - r2), r2 = a2.originalColumn, a2.name != null && (u2 = this._names.indexOf(a2.name), l2 += yt2.encode(u2 - o2), o2 = u2)), c2 += l2;
      }
      return c2;
    };
    ge2.prototype._generateSourcesContent = function(t3, n2) {
      return t3.map(function(r2) {
        if (!this._sourcesContents)
          return null;
        n2 != null && (r2 = U2.relative(n2, r2));
        var i2 = U2.toSetString(r2);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, i2) ? this._sourcesContents[i2] : null;
      }, this);
    };
    ge2.prototype.toJSON = function() {
      var t3 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      return this._file != null && (t3.file = this._file), this._sourceRoot != null && (t3.sourceRoot = this._sourceRoot), this._sourcesContents && (t3.sourcesContent = this._generateSourcesContent(t3.sources, t3.sourceRoot)), t3;
    };
    ge2.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    var ll = ge2;
    const Zr2 = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
    function cl(e2) {
      const t3 = new ll(), n2 = {
        line: 1,
        column: 0
      }, r2 = {
        line: 0,
        // should be zero to add first mapping
        column: 0
      }, i2 = {
        line: 1,
        column: 0
      }, o2 = {
        generated: i2
      };
      let s2 = 1, c2 = 0, l2 = false;
      const a2 = e2.node;
      e2.node = function(d2) {
        if (d2.loc && d2.loc.start && Zr2.has(d2.type)) {
          const m2 = d2.loc.start.line, w2 = d2.loc.start.column - 1;
          (r2.line !== m2 || r2.column !== w2) && (r2.line = m2, r2.column = w2, n2.line = s2, n2.column = c2, l2 && (l2 = false, (n2.line !== i2.line || n2.column !== i2.column) && t3.addMapping(o2)), l2 = true, t3.addMapping({
            source: d2.loc.source,
            original: r2,
            generated: n2
          }));
        }
        a2.call(this, d2), l2 && Zr2.has(d2.type) && (i2.line = s2, i2.column = c2);
      };
      const u2 = e2.emit;
      e2.emit = function(d2, m2, w2) {
        for (let k2 = 0; k2 < d2.length; k2++)
          d2.charCodeAt(k2) === 10 ? (s2++, c2 = 0) : c2++;
        u2(d2, m2, w2);
      };
      const h2 = e2.result;
      return e2.result = function() {
        return l2 && t3.addMapping(o2), {
          css: h2(),
          map: t3
        };
      }, e2;
    }
    const ul = 43, hl = 45, _n2 = (e2, t3) => {
      if (e2 === I2 && (e2 = t3), typeof e2 == "string") {
        const n2 = e2.charCodeAt(0);
        return n2 > 127 ? 32768 : n2 << 8;
      }
      return e2;
    }, To = [
      [y2, y2],
      [y2, $5],
      [y2, te2],
      [y2, se2],
      [y2, "-"],
      [y2, L2],
      [y2, B2],
      [y2, z2],
      [y2, ae2],
      [y2, M2],
      [G2, y2],
      [G2, $5],
      [G2, te2],
      [G2, se2],
      [G2, "-"],
      [G2, L2],
      [G2, B2],
      [G2, z2],
      [G2, ae2],
      [F2, y2],
      [F2, $5],
      [F2, te2],
      [F2, se2],
      [F2, "-"],
      [F2, L2],
      [F2, B2],
      [F2, z2],
      [F2, ae2],
      [z2, y2],
      [z2, $5],
      [z2, te2],
      [z2, se2],
      [z2, "-"],
      [z2, L2],
      [z2, B2],
      [z2, z2],
      [z2, ae2],
      ["#", y2],
      ["#", $5],
      ["#", te2],
      ["#", se2],
      ["#", "-"],
      ["#", L2],
      ["#", B2],
      ["#", z2],
      ["#", ae2],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["-", y2],
      ["-", $5],
      ["-", te2],
      ["-", se2],
      ["-", "-"],
      ["-", L2],
      ["-", B2],
      ["-", z2],
      ["-", ae2],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [L2, y2],
      [L2, $5],
      [L2, te2],
      [L2, se2],
      [L2, L2],
      [L2, B2],
      [L2, z2],
      [L2, "%"],
      [L2, ae2],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["@", y2],
      ["@", $5],
      ["@", te2],
      ["@", se2],
      ["@", "-"],
      ["@", ae2],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [".", L2],
      [".", B2],
      [".", z2],
      ["+", L2],
      ["+", B2],
      ["+", z2],
      ["/", "*"]
    ], pl = To.concat([
      [y2, F2],
      [z2, F2],
      [F2, F2],
      [G2, M2],
      [G2, Te2],
      [G2, ne2],
      [B2, B2],
      [B2, z2],
      [B2, $5],
      [B2, "-"],
      [E2, y2],
      [E2, $5],
      [E2, B2],
      [E2, z2],
      [E2, F2],
      [E2, "-"]
    ]);
    function Ao(e2) {
      const t3 = new Set(
        e2.map(([n2, r2]) => _n2(n2) << 16 | _n2(r2))
      );
      return function(n2, r2, i2) {
        const o2 = _n2(r2, i2), s2 = i2.charCodeAt(0);
        return (s2 === hl && r2 !== y2 && r2 !== $5 && r2 !== ae2 || s2 === ul ? t3.has(n2 << 16 | s2 << 8) : t3.has(n2 << 16 | o2)) && this.emit(" ", W2, true), o2;
      };
    }
    const fl = Ao(To), Oo = Ao(pl), Jr2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      safe: Oo,
      spec: fl
    }, Symbol.toStringTag, { value: "Module" })), dl = 92;
    function ml(e2, t3) {
      if (typeof t3 == "function") {
        let n2 = null;
        e2.children.forEach((r2) => {
          n2 !== null && t3.call(this, n2), this.node(r2), n2 = r2;
        });
        return;
      }
      e2.children.forEach(this.node, this);
    }
    function gl(e2) {
      gn2(e2, (t3, n2, r2) => {
        this.token(t3, e2.slice(n2, r2));
      });
    }
    function bl(e2) {
      const t3 = /* @__PURE__ */ new Map();
      for (let [n2, r2] of Object.entries(e2.node))
        typeof (r2.generate || r2) == "function" && t3.set(n2, r2.generate || r2);
      return function(n2, r2) {
        let i2 = "", o2 = 0, s2 = {
          node(l2) {
            if (t3.has(l2.type))
              t3.get(l2.type).call(c2, l2);
            else
              throw new Error("Unknown node type: " + l2.type);
          },
          tokenBefore: Oo,
          token(l2, a2) {
            o2 = this.tokenBefore(o2, l2, a2), this.emit(a2, l2, false), l2 === I2 && a2.charCodeAt(0) === dl && this.emit(`
`, W2, true);
          },
          emit(l2) {
            i2 += l2;
          },
          result() {
            return i2;
          }
        };
        r2 && (typeof r2.decorator == "function" && (s2 = r2.decorator(s2)), r2.sourceMap && (s2 = cl(s2)), r2.mode in Jr2 && (s2.tokenBefore = Jr2[r2.mode]));
        const c2 = {
          node: (l2) => s2.node(l2),
          children: ml,
          token: (l2, a2) => s2.token(l2, a2),
          tokenize: gl
        };
        return s2.node(n2), s2.result();
      };
    }
    function yl(e2) {
      return {
        fromPlainObject(t3) {
          return e2(t3, {
            enter(n2) {
              n2.children && !(n2.children instanceof q2) && (n2.children = new q2().fromArray(n2.children));
            }
          }), t3;
        },
        toPlainObject(t3) {
          return e2(t3, {
            leave(n2) {
              n2.children && n2.children instanceof q2 && (n2.children = n2.children.toArray());
            }
          }), t3;
        }
      };
    }
    const { hasOwnProperty: wr2 } = Object.prototype, xt2 = function() {
    };
    function ei2(e2) {
      return typeof e2 == "function" ? e2 : xt2;
    }
    function ti2(e2, t3) {
      return function(n2, r2, i2) {
        n2.type === t3 && e2.call(this, n2, r2, i2);
      };
    }
    function kl(e2, t3) {
      const n2 = t3.structure, r2 = [];
      for (const i2 in n2) {
        if (wr2.call(n2, i2) === false)
          continue;
        let o2 = n2[i2];
        const s2 = {
          name: i2,
          type: false,
          nullable: false
        };
        Array.isArray(o2) || (o2 = [o2]);
        for (const c2 of o2)
          c2 === null ? s2.nullable = true : typeof c2 == "string" ? s2.type = "node" : Array.isArray(c2) && (s2.type = "list");
        s2.type && r2.push(s2);
      }
      return r2.length ? {
        context: t3.walkContext,
        fields: r2
      } : null;
    }
    function xl(e2) {
      const t3 = {};
      for (const n2 in e2.node)
        if (wr2.call(e2.node, n2)) {
          const r2 = e2.node[n2];
          if (!r2.structure)
            throw new Error("Missed `structure` field in `" + n2 + "` node type definition");
          t3[n2] = kl(n2, r2);
        }
      return t3;
    }
    function ni2(e2, t3) {
      const n2 = e2.fields.slice(), r2 = e2.context, i2 = typeof r2 == "string";
      return t3 && n2.reverse(), function(o2, s2, c2, l2) {
        let a2;
        i2 && (a2 = s2[r2], s2[r2] = o2);
        for (const u2 of n2) {
          const h2 = o2[u2.name];
          if (!u2.nullable || h2) {
            if (u2.type === "list") {
              if (t3 ? h2.reduceRight(l2, false) : h2.reduce(l2, false))
                return true;
            } else if (c2(h2))
              return true;
          }
        }
        i2 && (s2[r2] = a2);
      };
    }
    function ri2({
      StyleSheet: e2,
      Atrule: t3,
      Rule: n2,
      Block: r2,
      DeclarationList: i2
    }) {
      return {
        Atrule: {
          StyleSheet: e2,
          Atrule: t3,
          Rule: n2,
          Block: r2
        },
        Rule: {
          StyleSheet: e2,
          Atrule: t3,
          Rule: n2,
          Block: r2
        },
        Declaration: {
          StyleSheet: e2,
          Atrule: t3,
          Rule: n2,
          Block: r2,
          DeclarationList: i2
        }
      };
    }
    function wl(e2) {
      const t3 = xl(e2), n2 = {}, r2 = {}, i2 = Symbol("break-walk"), o2 = Symbol("skip-node");
      for (const a2 in t3)
        wr2.call(t3, a2) && t3[a2] !== null && (n2[a2] = ni2(t3[a2], false), r2[a2] = ni2(t3[a2], true));
      const s2 = ri2(n2), c2 = ri2(r2), l2 = function(a2, u2) {
        function h2(b2, x2, T2) {
          const v2 = d2.call(C2, b2, x2, T2);
          return v2 === i2 ? true : v2 === o2 ? false : !!(w2.hasOwnProperty(b2.type) && w2[b2.type](b2, C2, h2, k2) || m2.call(C2, b2, x2, T2) === i2);
        }
        let d2 = xt2, m2 = xt2, w2 = n2, k2 = (b2, x2, T2, v2) => b2 || h2(x2, T2, v2);
        const C2 = {
          break: i2,
          skip: o2,
          root: a2,
          stylesheet: null,
          atrule: null,
          atrulePrelude: null,
          rule: null,
          selector: null,
          block: null,
          declaration: null,
          function: null
        };
        if (typeof u2 == "function")
          d2 = u2;
        else if (u2 && (d2 = ei2(u2.enter), m2 = ei2(u2.leave), u2.reverse && (w2 = r2), u2.visit)) {
          if (s2.hasOwnProperty(u2.visit))
            w2 = u2.reverse ? c2[u2.visit] : s2[u2.visit];
          else if (!t3.hasOwnProperty(u2.visit))
            throw new Error("Bad value `" + u2.visit + "` for `visit` option (should be: " + Object.keys(t3).sort().join(", ") + ")");
          d2 = ti2(d2, u2.visit), m2 = ti2(m2, u2.visit);
        }
        if (d2 === xt2 && m2 === xt2)
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        h2(a2);
      };
      return l2.break = i2, l2.skip = o2, l2.find = function(a2, u2) {
        let h2 = null;
        return l2(a2, function(d2, m2, w2) {
          if (u2.call(this, d2, m2, w2))
            return h2 = d2, i2;
        }), h2;
      }, l2.findLast = function(a2, u2) {
        let h2 = null;
        return l2(a2, {
          reverse: true,
          enter(d2, m2, w2) {
            if (u2.call(this, d2, m2, w2))
              return h2 = d2, i2;
          }
        }), h2;
      }, l2.findAll = function(a2, u2) {
        const h2 = [];
        return l2(a2, function(d2, m2, w2) {
          u2.call(this, d2, m2, w2) && h2.push(d2);
        }), h2;
      }, l2;
    }
    function vl(e2) {
      return e2;
    }
    function Sl(e2) {
      const { min: t3, max: n2, comma: r2 } = e2;
      return t3 === 0 && n2 === 0 ? r2 ? "#?" : "*" : t3 === 0 && n2 === 1 ? "?" : t3 === 1 && n2 === 0 ? r2 ? "#" : "+" : t3 === 1 && n2 === 1 ? "" : (r2 ? "#" : "") + (t3 === n2 ? "{" + t3 + "}" : "{" + t3 + "," + (n2 !== 0 ? n2 : "") + "}");
    }
    function Cl(e2) {
      switch (e2.type) {
        case "Range":
          return " [" + (e2.min === null ? "-\u221E" : e2.min) + "," + (e2.max === null ? "\u221E" : e2.max) + "]";
        default:
          throw new Error("Unknown node type `" + e2.type + "`");
      }
    }
    function Tl(e2, t3, n2, r2) {
      const i2 = e2.combinator === " " || r2 ? e2.combinator : " " + e2.combinator + " ", o2 = e2.terms.map((s2) => vr2(s2, t3, n2, r2)).join(i2);
      return e2.explicit || n2 ? (r2 || o2[0] === "," ? "[" : "[ ") + o2 + (r2 ? "]" : " ]") : o2;
    }
    function vr2(e2, t3, n2, r2) {
      let i2;
      switch (e2.type) {
        case "Group":
          i2 = Tl(e2, t3, n2, r2) + (e2.disallowEmpty ? "!" : "");
          break;
        case "Multiplier":
          return vr2(e2.term, t3, n2, r2) + t3(Sl(e2), e2);
        case "Type":
          i2 = "<" + e2.name + (e2.opts ? t3(Cl(e2.opts), e2.opts) : "") + ">";
          break;
        case "Property":
          i2 = "<'" + e2.name + "'>";
          break;
        case "Keyword":
          i2 = e2.name;
          break;
        case "AtKeyword":
          i2 = "@" + e2.name;
          break;
        case "Function":
          i2 = e2.name + "(";
          break;
        case "String":
        case "Token":
          i2 = e2.value;
          break;
        case "Comma":
          i2 = ",";
          break;
        default:
          throw new Error("Unknown node type `" + e2.type + "`");
      }
      return t3(i2, e2);
    }
    function Sr2(e2, t3) {
      let n2 = vl, r2 = false, i2 = false;
      return typeof t3 == "function" ? n2 = t3 : t3 && (r2 = !!t3.forceBraces, i2 = !!t3.compact, typeof t3.decorate == "function" && (n2 = t3.decorate)), vr2(e2, n2, r2, i2);
    }
    const ii2 = { offset: 0, line: 1, column: 1 };
    function Al(e2, t3) {
      const n2 = e2.tokens, r2 = e2.longestMatch, i2 = r2 < n2.length && n2[r2].node || null, o2 = i2 !== t3 ? i2 : null;
      let s2 = 0, c2 = 0, l2 = 0, a2 = "", u2, h2;
      for (let d2 = 0; d2 < n2.length; d2++) {
        const m2 = n2[d2].value;
        d2 === r2 && (c2 = m2.length, s2 = a2.length), o2 !== null && n2[d2].node === o2 && (d2 <= r2 ? l2++ : l2 = 0), a2 += m2;
      }
      return r2 === n2.length || l2 > 1 ? (u2 = jt2(o2 || t3, "end") || wt2(ii2, a2), h2 = wt2(u2)) : (u2 = jt2(o2, "start") || wt2(jt2(t3, "start") || ii2, a2.slice(0, s2)), h2 = jt2(o2, "end") || wt2(u2, a2.substr(s2, c2))), {
        css: a2,
        mismatchOffset: s2,
        mismatchLength: c2,
        start: u2,
        end: h2
      };
    }
    function jt2(e2, t3) {
      const n2 = e2 && e2.loc && e2.loc[t3];
      return n2 ? "line" in n2 ? wt2(n2) : n2 : null;
    }
    function wt2({ offset: e2, line: t3, column: n2 }, r2) {
      const i2 = {
        offset: e2,
        line: t3,
        column: n2
      };
      if (r2) {
        const o2 = r2.split(/\n|\r\n?|\f/);
        i2.offset += r2.length, i2.line += o2.length - 1, i2.column = o2.length === 1 ? i2.column + r2.length : o2.pop().length + 1;
      }
      return i2;
    }
    const kt2 = function(e2, t3) {
      const n2 = bn2(
        "SyntaxReferenceError",
        e2 + (t3 ? " `" + t3 + "`" : "")
      );
      return n2.reference = t3, n2;
    }, Ol = function(e2, t3, n2, r2) {
      const i2 = bn2("SyntaxMatchError", e2), {
        css: o2,
        mismatchOffset: s2,
        mismatchLength: c2,
        start: l2,
        end: a2
      } = Al(r2, n2);
      return i2.rawMessage = e2, i2.syntax = t3 ? Sr2(t3) : "<generic>", i2.css = o2, i2.mismatchOffset = s2, i2.mismatchLength = c2, i2.message = e2 + `
  syntax: ` + i2.syntax + `
   value: ` + (o2 || "<empty string>") + `
  --------` + new Array(i2.mismatchOffset + 1).join("-") + "^", Object.assign(i2, l2), i2.loc = {
        source: n2 && n2.loc && n2.loc.source || "<unknown>",
        start: l2,
        end: a2
      }, i2;
    }, Ft2 = /* @__PURE__ */ new Map(), rt2 = /* @__PURE__ */ new Map(), on2 = 45, Pn2 = El, oi2 = Ll;
    function Cr2(e2, t3) {
      return t3 = t3 || 0, e2.length - t3 >= 2 && e2.charCodeAt(t3) === on2 && e2.charCodeAt(t3 + 1) === on2;
    }
    function Eo(e2, t3) {
      if (t3 = t3 || 0, e2.length - t3 >= 3 && e2.charCodeAt(t3) === on2 && e2.charCodeAt(t3 + 1) !== on2) {
        const n2 = e2.indexOf("-", t3 + 2);
        if (n2 !== -1)
          return e2.substring(t3, n2 + 1);
      }
      return "";
    }
    function El(e2) {
      if (Ft2.has(e2))
        return Ft2.get(e2);
      const t3 = e2.toLowerCase();
      let n2 = Ft2.get(t3);
      if (n2 === void 0) {
        const r2 = Cr2(t3, 0), i2 = r2 ? "" : Eo(t3, 0);
        n2 = Object.freeze({
          basename: t3.substr(i2.length),
          name: t3,
          prefix: i2,
          vendor: i2,
          custom: r2
        });
      }
      return Ft2.set(e2, n2), n2;
    }
    function Ll(e2) {
      if (rt2.has(e2))
        return rt2.get(e2);
      let t3 = e2, n2 = e2[0];
      n2 === "/" ? n2 = e2[1] === "/" ? "//" : "/" : n2 !== "_" && n2 !== "*" && n2 !== "$" && n2 !== "#" && n2 !== "+" && n2 !== "&" && (n2 = "");
      const r2 = Cr2(t3, n2.length);
      if (!r2 && (t3 = t3.toLowerCase(), rt2.has(t3))) {
        const c2 = rt2.get(t3);
        return rt2.set(e2, c2), c2;
      }
      const i2 = r2 ? "" : Eo(t3, n2.length), o2 = t3.substr(0, n2.length + i2.length), s2 = Object.freeze({
        basename: t3.substr(o2.length),
        name: t3.substr(n2.length),
        hack: n2,
        vendor: i2,
        prefix: o2,
        custom: r2
      });
      return rt2.set(e2, s2), s2;
    }
    const Lo = [
      "initial",
      "inherit",
      "unset",
      "revert",
      "revert-layer"
    ], _t2 = 43, Oe2 = 45, zn2 = 110, it2 = true, $l = false;
    function Qn2(e2, t3) {
      return e2 !== null && e2.type === I2 && e2.value.charCodeAt(0) === t3;
    }
    function Tt2(e2, t3, n2) {
      for (; e2 !== null && (e2.type === W2 || e2.type === X2); )
        e2 = n2(++t3);
      return t3;
    }
    function Ne2(e2, t3, n2, r2) {
      if (!e2)
        return 0;
      const i2 = e2.value.charCodeAt(t3);
      if (i2 === _t2 || i2 === Oe2) {
        if (n2)
          return 0;
        t3++;
      }
      for (; t3 < e2.value.length; t3++)
        if (!Q2(e2.value.charCodeAt(t3)))
          return 0;
      return r2 + 1;
    }
    function In2(e2, t3, n2) {
      let r2 = false, i2 = Tt2(e2, t3, n2);
      if (e2 = n2(i2), e2 === null)
        return t3;
      if (e2.type !== L2)
        if (Qn2(e2, _t2) || Qn2(e2, Oe2)) {
          if (r2 = true, i2 = Tt2(n2(++i2), i2, n2), e2 = n2(i2), e2 === null || e2.type !== L2)
            return 0;
        } else
          return t3;
      if (!r2) {
        const o2 = e2.value.charCodeAt(0);
        if (o2 !== _t2 && o2 !== Oe2)
          return 0;
      }
      return Ne2(e2, r2 ? 0 : 1, r2, i2);
    }
    function _l(e2, t3) {
      let n2 = 0;
      if (!e2)
        return 0;
      if (e2.type === L2)
        return Ne2(e2, 0, $l, n2);
      if (e2.type === y2 && e2.value.charCodeAt(0) === Oe2) {
        if (!ht2(e2.value, 1, zn2))
          return 0;
        switch (e2.value.length) {
          case 2:
            return In2(t3(++n2), n2, t3);
          case 3:
            return e2.value.charCodeAt(2) !== Oe2 ? 0 : (n2 = Tt2(t3(++n2), n2, t3), e2 = t3(n2), Ne2(e2, 0, it2, n2));
          default:
            return e2.value.charCodeAt(2) !== Oe2 ? 0 : Ne2(e2, 3, it2, n2);
        }
      } else if (e2.type === y2 || Qn2(e2, _t2) && t3(n2 + 1).type === y2) {
        if (e2.type !== y2 && (e2 = t3(++n2)), e2 === null || !ht2(e2.value, 0, zn2))
          return 0;
        switch (e2.value.length) {
          case 1:
            return In2(t3(++n2), n2, t3);
          case 2:
            return e2.value.charCodeAt(1) !== Oe2 ? 0 : (n2 = Tt2(t3(++n2), n2, t3), e2 = t3(n2), Ne2(e2, 0, it2, n2));
          default:
            return e2.value.charCodeAt(1) !== Oe2 ? 0 : Ne2(e2, 2, it2, n2);
        }
      } else if (e2.type === z2) {
        let r2 = e2.value.charCodeAt(0), i2 = r2 === _t2 || r2 === Oe2 ? 1 : 0, o2 = i2;
        for (; o2 < e2.value.length && Q2(e2.value.charCodeAt(o2)); o2++)
          ;
        return o2 === i2 || !ht2(e2.value, o2, zn2) ? 0 : o2 + 1 === e2.value.length ? In2(t3(++n2), n2, t3) : e2.value.charCodeAt(o2 + 1) !== Oe2 ? 0 : o2 + 2 === e2.value.length ? (n2 = Tt2(t3(++n2), n2, t3), e2 = t3(n2), Ne2(e2, 0, it2, n2)) : Ne2(e2, o2 + 2, it2, n2);
      }
      return 0;
    }
    const Pl = 43, $o = 45, _o = 63, zl = 117;
    function Xn2(e2, t3) {
      return e2 !== null && e2.type === I2 && e2.value.charCodeAt(0) === t3;
    }
    function Il(e2, t3) {
      return e2.value.charCodeAt(0) === t3;
    }
    function vt2(e2, t3, n2) {
      let r2 = 0;
      for (let i2 = t3; i2 < e2.value.length; i2++) {
        const o2 = e2.value.charCodeAt(i2);
        if (o2 === $o && n2 && r2 !== 0)
          return vt2(e2, t3 + r2 + 1, false), 6;
        if (!He2(o2) || ++r2 > 6)
          return 0;
      }
      return r2;
    }
    function Bt2(e2, t3, n2) {
      if (!e2)
        return 0;
      for (; Xn2(n2(t3), _o); ) {
        if (++e2 > 6)
          return 0;
        t3++;
      }
      return t3;
    }
    function Rl(e2, t3) {
      let n2 = 0;
      if (e2 === null || e2.type !== y2 || !ht2(e2.value, 0, zl) || (e2 = t3(++n2), e2 === null))
        return 0;
      if (Xn2(e2, Pl))
        return e2 = t3(++n2), e2 === null ? 0 : e2.type === y2 ? Bt2(vt2(e2, 0, true), ++n2, t3) : Xn2(e2, _o) ? Bt2(1, ++n2, t3) : 0;
      if (e2.type === L2) {
        const r2 = vt2(e2, 1, true);
        return r2 === 0 ? 0 : (e2 = t3(++n2), e2 === null ? n2 : e2.type === z2 || e2.type === L2 ? !Il(e2, $o) || !vt2(e2, 1, false) ? 0 : n2 + 1 : Bt2(r2, n2, t3));
      }
      return e2.type === z2 ? Bt2(vt2(e2, 1, true), ++n2, t3) : 0;
    }
    const Ml = ["calc(", "-moz-calc(", "-webkit-calc("], Tr2 = /* @__PURE__ */ new Map([
      [$5, E2],
      [M2, E2],
      [fe2, Se2],
      [V2, ue2]
    ]);
    function xe2(e2, t3) {
      return t3 < e2.length ? e2.charCodeAt(t3) : 0;
    }
    function Po(e2, t3) {
      return $t2(e2, 0, e2.length, t3);
    }
    function zo(e2, t3) {
      for (let n2 = 0; n2 < t3.length; n2++)
        if (Po(e2, t3[n2]))
          return true;
      return false;
    }
    function Io(e2, t3) {
      return t3 !== e2.length - 2 ? false : xe2(e2, t3) === 92 && // U+005C REVERSE SOLIDUS (\)
      Q2(xe2(e2, t3 + 1));
    }
    function xn2(e2, t3, n2) {
      if (e2 && e2.type === "Range") {
        const r2 = Number(
          n2 !== void 0 && n2 !== t3.length ? t3.substr(0, n2) : t3
        );
        if (isNaN(r2) || e2.min !== null && r2 < e2.min && typeof e2.min != "string" || e2.max !== null && r2 > e2.max && typeof e2.max != "string")
          return true;
      }
      return false;
    }
    function Nl(e2, t3) {
      let n2 = 0, r2 = [], i2 = 0;
      e:
        do {
          switch (e2.type) {
            case ue2:
            case E2:
            case Se2:
              if (e2.type !== n2)
                break e;
              if (n2 = r2.pop(), r2.length === 0) {
                i2++;
                break e;
              }
              break;
            case $5:
            case M2:
            case fe2:
            case V2:
              r2.push(n2), n2 = Tr2.get(e2.type);
              break;
          }
          i2++;
        } while (e2 = t3(i2));
      return i2;
    }
    function me2(e2) {
      return function(t3, n2, r2) {
        return t3 === null ? 0 : t3.type === $5 && zo(t3.value, Ml) ? Nl(t3, n2) : e2(t3, n2, r2);
      };
    }
    function j2(e2) {
      return function(t3) {
        return t3 === null || t3.type !== e2 ? 0 : 1;
      };
    }
    function Dl(e2) {
      if (e2 === null || e2.type !== y2)
        return 0;
      const t3 = e2.value.toLowerCase();
      return zo(t3, Lo) || Po(t3, "default") ? 0 : 1;
    }
    function Ro(e2) {
      return e2 === null || e2.type !== y2 || xe2(e2.value, 0) !== 45 || xe2(e2.value, 1) !== 45 ? 0 : 1;
    }
    function jl(e2) {
      return !Ro(e2) || e2.value === "--" ? 0 : 1;
    }
    function Fl(e2) {
      if (e2 === null || e2.type !== F2)
        return 0;
      const t3 = e2.value.length;
      if (t3 !== 4 && t3 !== 5 && t3 !== 7 && t3 !== 9)
        return 0;
      for (let n2 = 1; n2 < t3; n2++)
        if (!He2(xe2(e2.value, n2)))
          return 0;
      return 1;
    }
    function Bl(e2) {
      return e2 === null || e2.type !== F2 || !qt2(xe2(e2.value, 1), xe2(e2.value, 2), xe2(e2.value, 3)) ? 0 : 1;
    }
    function Wl(e2, t3) {
      if (!e2)
        return 0;
      let n2 = 0, r2 = [], i2 = 0;
      e:
        do {
          switch (e2.type) {
            case dn2:
            case se2:
              break e;
            case ue2:
            case E2:
            case Se2:
              if (e2.type !== n2)
                break e;
              n2 = r2.pop();
              break;
            case re2:
              if (n2 === 0)
                break e;
              break;
            case I2:
              if (n2 === 0 && e2.value === "!")
                break e;
              break;
            case $5:
            case M2:
            case fe2:
            case V2:
              r2.push(n2), n2 = Tr2.get(e2.type);
              break;
          }
          i2++;
        } while (e2 = t3(i2));
      return i2;
    }
    function Hl(e2, t3) {
      if (!e2)
        return 0;
      let n2 = 0, r2 = [], i2 = 0;
      e:
        do {
          switch (e2.type) {
            case dn2:
            case se2:
              break e;
            case ue2:
            case E2:
            case Se2:
              if (e2.type !== n2)
                break e;
              n2 = r2.pop();
              break;
            case $5:
            case M2:
            case fe2:
            case V2:
              r2.push(n2), n2 = Tr2.get(e2.type);
              break;
          }
          i2++;
        } while (e2 = t3(i2));
      return i2;
    }
    function Ie2(e2) {
      return e2 && (e2 = new Set(e2)), function(t3, n2, r2) {
        if (t3 === null || t3.type !== z2)
          return 0;
        const i2 = mn2(t3.value, 0);
        if (e2 !== null) {
          const o2 = t3.value.indexOf("\\", i2), s2 = o2 === -1 || !Io(t3.value, o2) ? t3.value.substr(i2) : t3.value.substring(i2, o2);
          if (e2.has(s2.toLowerCase()) === false)
            return 0;
        }
        return xn2(r2, t3.value, i2) ? 0 : 1;
      };
    }
    function Ul(e2, t3, n2) {
      return e2 === null || e2.type !== B2 || xn2(n2, e2.value, e2.value.length - 1) ? 0 : 1;
    }
    function Mo(e2) {
      return typeof e2 != "function" && (e2 = function() {
        return 0;
      }), function(t3, n2, r2) {
        return t3 !== null && t3.type === L2 && Number(t3.value) === 0 ? 1 : e2(t3, n2, r2);
      };
    }
    function ql(e2, t3, n2) {
      if (e2 === null)
        return 0;
      const r2 = mn2(e2.value, 0);
      return !(r2 === e2.value.length) && !Io(e2.value, r2) || xn2(n2, e2.value, r2) ? 0 : 1;
    }
    function Gl(e2, t3, n2) {
      if (e2 === null || e2.type !== L2)
        return 0;
      let r2 = xe2(e2.value, 0) === 43 || // U+002B PLUS SIGN (+)
      xe2(e2.value, 0) === 45 ? 1 : 0;
      for (; r2 < e2.value.length; r2++)
        if (!Q2(xe2(e2.value, r2)))
          return 0;
      return xn2(n2, e2.value, r2) ? 0 : 1;
    }
    const Vl = {
      "ident-token": j2(y2),
      "function-token": j2($5),
      "at-keyword-token": j2(G2),
      "hash-token": j2(F2),
      "string-token": j2(Te2),
      "bad-string-token": j2(dn2),
      "url-token": j2(te2),
      "bad-url-token": j2(se2),
      "delim-token": j2(I2),
      "number-token": j2(L2),
      "percentage-token": j2(B2),
      "dimension-token": j2(z2),
      "whitespace-token": j2(W2),
      "CDO-token": j2(Rt2),
      "CDC-token": j2(ae2),
      "colon-token": j2(ne2),
      "semicolon-token": j2(re2),
      "comma-token": j2(ce2),
      "[-token": j2(fe2),
      "]-token": j2(Se2),
      "(-token": j2(M2),
      ")-token": j2(E2),
      "{-token": j2(V2),
      "}-token": j2(ue2)
    }, Kl = {
      // token type aliases
      string: j2(Te2),
      ident: j2(y2),
      // percentage
      percentage: me2(Ul),
      // numeric
      zero: Mo(),
      number: me2(ql),
      integer: me2(Gl),
      // complex types
      "custom-ident": Dl,
      "dashed-ident": Ro,
      "custom-property-name": jl,
      "hex-color": Fl,
      "id-selector": Bl,
      // element( <id-selector> )
      "an-plus-b": _l,
      urange: Rl,
      "declaration-value": Wl,
      "any-value": Hl
    };
    function Yl(e2) {
      const {
        angle: t3,
        decibel: n2,
        frequency: r2,
        flex: i2,
        length: o2,
        resolution: s2,
        semitones: c2,
        time: l2
      } = e2 || {};
      return {
        dimension: me2(Ie2(null)),
        angle: me2(Ie2(t3)),
        decibel: me2(Ie2(n2)),
        frequency: me2(Ie2(r2)),
        flex: me2(Ie2(i2)),
        length: me2(Mo(Ie2(o2))),
        resolution: me2(Ie2(s2)),
        semitones: me2(Ie2(c2)),
        time: me2(Ie2(l2))
      };
    }
    function Ql(e2) {
      return _2(_2(_2({}, Vl), Kl), Yl(e2));
    }
    const Xl = [
      // absolute length units https://www.w3.org/TR/css-values-3/#lengths
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ], Zl = ["deg", "grad", "rad", "turn"], Jl = ["s", "ms"], ec = ["hz", "khz"], tc = ["dpi", "dpcm", "dppx", "x"], nc = ["fr"], rc = ["db"], ic = ["st"], si2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      angle: Zl,
      decibel: rc,
      flex: nc,
      frequency: ec,
      length: Xl,
      resolution: tc,
      semitones: ic,
      time: Jl
    }, Symbol.toStringTag, { value: "Module" }));
    function oc(e2, t3, n2) {
      return Object.assign(bn2("SyntaxError", e2), {
        input: t3,
        offset: n2,
        rawMessage: e2,
        message: e2 + `
  ` + t3 + `
--` + new Array((n2 || t3.length) + 1).join("-") + "^"
      });
    }
    const sc = 9, ac = 10, lc = 12, cc = 13, uc = 32;
    class hc {
      constructor(t3) {
        this.str = t3, this.pos = 0;
      }
      charCodeAt(t3) {
        return t3 < this.str.length ? this.str.charCodeAt(t3) : 0;
      }
      charCode() {
        return this.charCodeAt(this.pos);
      }
      nextCharCode() {
        return this.charCodeAt(this.pos + 1);
      }
      nextNonWsCode(t3) {
        return this.charCodeAt(this.findWsEnd(t3));
      }
      skipWs() {
        this.pos = this.findWsEnd(this.pos);
      }
      findWsEnd(t3) {
        for (; t3 < this.str.length; t3++) {
          const n2 = this.str.charCodeAt(t3);
          if (n2 !== cc && n2 !== ac && n2 !== lc && n2 !== uc && n2 !== sc)
            break;
        }
        return t3;
      }
      substringToPos(t3) {
        return this.str.substring(this.pos, this.pos = t3);
      }
      eat(t3) {
        this.charCode() !== t3 && this.error("Expect `" + String.fromCharCode(t3) + "`"), this.pos++;
      }
      peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
      }
      error(t3) {
        throw new oc(t3, this.str, this.pos);
      }
    }
    const pc = 9, fc = 10, dc = 12, mc = 13, gc = 32, No = 33, Ar2 = 35, ai2 = 38, sn2 = 39, Do = 40, bc = 41, jo = 42, Or2 = 43, Er2 = 44, li2 = 45, Lr2 = 60, Fo = 62, Zn2 = 63, yc = 64, wn2 = 91, $r2 = 93, an2 = 123, ci2 = 124, ui2 = 125, hi2 = 8734, Pt2 = new Uint8Array(128).map(
      (e2, t3) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(t3)) ? 1 : 0
    ), pi2 = {
      " ": 1,
      "&&": 2,
      "||": 3,
      "|": 4
    };
    function ln2(e2) {
      return e2.substringToPos(
        e2.findWsEnd(e2.pos)
      );
    }
    function dt2(e2) {
      let t3 = e2.pos;
      for (; t3 < e2.str.length; t3++) {
        const n2 = e2.str.charCodeAt(t3);
        if (n2 >= 128 || Pt2[n2] === 0)
          break;
      }
      return e2.pos === t3 && e2.error("Expect a keyword"), e2.substringToPos(t3);
    }
    function cn2(e2) {
      let t3 = e2.pos;
      for (; t3 < e2.str.length; t3++) {
        const n2 = e2.str.charCodeAt(t3);
        if (n2 < 48 || n2 > 57)
          break;
      }
      return e2.pos === t3 && e2.error("Expect a number"), e2.substringToPos(t3);
    }
    function kc(e2) {
      const t3 = e2.str.indexOf("'", e2.pos + 1);
      return t3 === -1 && (e2.pos = e2.str.length, e2.error("Expect an apostrophe")), e2.substringToPos(t3 + 1);
    }
    function fi2(e2) {
      let t3 = null, n2 = null;
      return e2.eat(an2), e2.skipWs(), t3 = cn2(e2), e2.skipWs(), e2.charCode() === Er2 ? (e2.pos++, e2.skipWs(), e2.charCode() !== ui2 && (n2 = cn2(e2), e2.skipWs())) : n2 = t3, e2.eat(ui2), {
        min: Number(t3),
        max: n2 ? Number(n2) : 0
      };
    }
    function xc(e2) {
      let t3 = null, n2 = false;
      switch (e2.charCode()) {
        case jo:
          e2.pos++, t3 = {
            min: 0,
            max: 0
          };
          break;
        case Or2:
          e2.pos++, t3 = {
            min: 1,
            max: 0
          };
          break;
        case Zn2:
          e2.pos++, t3 = {
            min: 0,
            max: 1
          };
          break;
        case Ar2:
          e2.pos++, n2 = true, e2.charCode() === an2 ? t3 = fi2(e2) : e2.charCode() === Zn2 ? (e2.pos++, t3 = {
            min: 0,
            max: 0
          }) : t3 = {
            min: 1,
            max: 0
          };
          break;
        case an2:
          t3 = fi2(e2);
          break;
        default:
          return null;
      }
      return {
        type: "Multiplier",
        comma: n2,
        min: t3.min,
        max: t3.max,
        term: null
      };
    }
    function mt2(e2, t3) {
      const n2 = xc(e2);
      return n2 !== null ? (n2.term = t3, e2.charCode() === Ar2 && e2.charCodeAt(e2.pos - 1) === Or2 ? mt2(e2, n2) : n2) : t3;
    }
    function Rn2(e2) {
      const t3 = e2.peek();
      return t3 === "" ? null : {
        type: "Token",
        value: t3
      };
    }
    function wc(e2) {
      let t3;
      return e2.eat(Lr2), e2.eat(sn2), t3 = dt2(e2), e2.eat(sn2), e2.eat(Fo), mt2(e2, {
        type: "Property",
        name: t3
      });
    }
    function vc(e2) {
      let t3 = null, n2 = null, r2 = 1;
      return e2.eat(wn2), e2.charCode() === li2 && (e2.peek(), r2 = -1), r2 == -1 && e2.charCode() === hi2 ? e2.peek() : (t3 = r2 * Number(cn2(e2)), Pt2[e2.charCode()] !== 0 && (t3 += dt2(e2))), ln2(e2), e2.eat(Er2), ln2(e2), e2.charCode() === hi2 ? e2.peek() : (r2 = 1, e2.charCode() === li2 && (e2.peek(), r2 = -1), n2 = r2 * Number(cn2(e2)), Pt2[e2.charCode()] !== 0 && (n2 += dt2(e2))), e2.eat($r2), {
        type: "Range",
        min: t3,
        max: n2
      };
    }
    function Sc(e2) {
      let t3, n2 = null;
      return e2.eat(Lr2), t3 = dt2(e2), e2.charCode() === Do && e2.nextCharCode() === bc && (e2.pos += 2, t3 += "()"), e2.charCodeAt(e2.findWsEnd(e2.pos)) === wn2 && (ln2(e2), n2 = vc(e2)), e2.eat(Fo), mt2(e2, {
        type: "Type",
        name: t3,
        opts: n2
      });
    }
    function Cc(e2) {
      const t3 = dt2(e2);
      return e2.charCode() === Do ? (e2.pos++, {
        type: "Function",
        name: t3
      }) : mt2(e2, {
        type: "Keyword",
        name: t3
      });
    }
    function Tc(e2, t3) {
      function n2(i2, o2) {
        return {
          type: "Group",
          terms: i2,
          combinator: o2,
          disallowEmpty: false,
          explicit: false
        };
      }
      let r2;
      for (t3 = Object.keys(t3).sort((i2, o2) => pi2[i2] - pi2[o2]); t3.length > 0; ) {
        r2 = t3.shift();
        let i2 = 0, o2 = 0;
        for (; i2 < e2.length; i2++) {
          const s2 = e2[i2];
          s2.type === "Combinator" && (s2.value === r2 ? (o2 === -1 && (o2 = i2 - 1), e2.splice(i2, 1), i2--) : (o2 !== -1 && i2 - o2 > 1 && (e2.splice(
            o2,
            i2 - o2,
            n2(e2.slice(o2, i2), r2)
          ), i2 = o2 + 1), o2 = -1));
        }
        o2 !== -1 && t3.length && e2.splice(
          o2,
          i2 - o2,
          n2(e2.slice(o2, i2), r2)
        );
      }
      return r2;
    }
    function Bo(e2) {
      const t3 = [], n2 = {};
      let r2, i2 = null, o2 = e2.pos;
      for (; r2 = Oc(e2); )
        r2.type !== "Spaces" && (r2.type === "Combinator" ? ((i2 === null || i2.type === "Combinator") && (e2.pos = o2, e2.error("Unexpected combinator")), n2[r2.value] = true) : i2 !== null && i2.type !== "Combinator" && (n2[" "] = true, t3.push({
          type: "Combinator",
          value: " "
        })), t3.push(r2), i2 = r2, o2 = e2.pos);
      return i2 !== null && i2.type === "Combinator" && (e2.pos -= o2, e2.error("Unexpected combinator")), {
        type: "Group",
        terms: t3,
        combinator: Tc(t3, n2) || " ",
        disallowEmpty: false,
        explicit: false
      };
    }
    function Ac(e2) {
      let t3;
      return e2.eat(wn2), t3 = Bo(e2), e2.eat($r2), t3.explicit = true, e2.charCode() === No && (e2.pos++, t3.disallowEmpty = true), t3;
    }
    function Oc(e2) {
      let t3 = e2.charCode();
      if (t3 < 128 && Pt2[t3] === 1)
        return Cc(e2);
      switch (t3) {
        case $r2:
          break;
        case wn2:
          return mt2(e2, Ac(e2));
        case Lr2:
          return e2.nextCharCode() === sn2 ? wc(e2) : Sc(e2);
        case ci2:
          return {
            type: "Combinator",
            value: e2.substringToPos(
              e2.pos + (e2.nextCharCode() === ci2 ? 2 : 1)
            )
          };
        case ai2:
          return e2.pos++, e2.eat(ai2), {
            type: "Combinator",
            value: "&&"
          };
        case Er2:
          return e2.pos++, {
            type: "Comma"
          };
        case sn2:
          return mt2(e2, {
            type: "String",
            value: kc(e2)
          });
        case gc:
        case pc:
        case fc:
        case mc:
        case dc:
          return {
            type: "Spaces",
            value: ln2(e2)
          };
        case yc:
          return t3 = e2.nextCharCode(), t3 < 128 && Pt2[t3] === 1 ? (e2.pos++, {
            type: "AtKeyword",
            name: dt2(e2)
          }) : Rn2(e2);
        case jo:
        case Or2:
        case Zn2:
        case Ar2:
        case No:
          break;
        case an2:
          if (t3 = e2.nextCharCode(), t3 < 48 || t3 > 57)
            return Rn2(e2);
          break;
        default:
          return Rn2(e2);
      }
    }
    function Wo(e2) {
      const t3 = new hc(e2), n2 = Bo(t3);
      return t3.pos !== e2.length && t3.error("Unexpected input"), n2.terms.length === 1 && n2.terms[0].type === "Group" ? n2.terms[0] : n2;
    }
    const St2 = function() {
    };
    function di2(e2) {
      return typeof e2 == "function" ? e2 : St2;
    }
    function Ec(e2, t3, n2) {
      function r2(s2) {
        switch (i2.call(n2, s2), s2.type) {
          case "Group":
            s2.terms.forEach(r2);
            break;
          case "Multiplier":
            r2(s2.term);
            break;
          case "Type":
          case "Property":
          case "Keyword":
          case "AtKeyword":
          case "Function":
          case "String":
          case "Token":
          case "Comma":
            break;
          default:
            throw new Error("Unknown type: " + s2.type);
        }
        o2.call(n2, s2);
      }
      let i2 = St2, o2 = St2;
      if (typeof t3 == "function" ? i2 = t3 : t3 && (i2 = di2(t3.enter), o2 = di2(t3.leave)), i2 === St2 && o2 === St2)
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      r2(e2);
    }
    const Lc = {
      decorator(e2) {
        const t3 = [];
        let n2 = null;
        return Z2(_2({}, e2), {
          node(r2) {
            const i2 = n2;
            n2 = r2, e2.node.call(this, r2), n2 = i2;
          },
          emit(r2, i2, o2) {
            t3.push({
              type: i2,
              value: r2,
              node: o2 ? null : n2
            });
          },
          result() {
            return t3;
          }
        });
      }
    };
    function $c(e2) {
      const t3 = [];
      return gn2(
        e2,
        (n2, r2, i2) => t3.push({
          type: n2,
          value: e2.slice(r2, i2),
          node: null
        })
      ), t3;
    }
    function _c(e2, t3) {
      return typeof e2 == "string" ? $c(e2) : t3.generate(e2, Lc);
    }
    const N2 = { type: "Match" }, D2 = { type: "Mismatch" }, _r2 = { type: "DisallowEmpty" }, Pc = 40, zc = 41;
    function J2(e2, t3, n2) {
      return t3 === N2 && n2 === D2 || e2 === N2 && t3 === N2 && n2 === N2 ? e2 : (e2.type === "If" && e2.else === D2 && t3 === N2 && (t3 = e2.then, e2 = e2.match), {
        type: "If",
        match: e2,
        then: t3,
        else: n2
      });
    }
    function Ho(e2) {
      return e2.length > 2 && e2.charCodeAt(e2.length - 2) === Pc && e2.charCodeAt(e2.length - 1) === zc;
    }
    function mi2(e2) {
      return e2.type === "Keyword" || e2.type === "AtKeyword" || e2.type === "Function" || e2.type === "Type" && Ho(e2.name);
    }
    function Jn2(e2, t3, n2) {
      switch (e2) {
        case " ": {
          let r2 = N2;
          for (let i2 = t3.length - 1; i2 >= 0; i2--) {
            const o2 = t3[i2];
            r2 = J2(
              o2,
              r2,
              D2
            );
          }
          return r2;
        }
        case "|": {
          let r2 = D2, i2 = null;
          for (let o2 = t3.length - 1; o2 >= 0; o2--) {
            let s2 = t3[o2];
            if (mi2(s2) && (i2 === null && o2 > 0 && mi2(t3[o2 - 1]) && (i2 = /* @__PURE__ */ Object.create(null), r2 = J2(
              {
                type: "Enum",
                map: i2
              },
              N2,
              r2
            )), i2 !== null)) {
              const c2 = (Ho(s2.name) ? s2.name.slice(0, -1) : s2.name).toLowerCase();
              if (!(c2 in i2)) {
                i2[c2] = s2;
                continue;
              }
            }
            i2 = null, r2 = J2(
              s2,
              N2,
              r2
            );
          }
          return r2;
        }
        case "&&": {
          if (t3.length > 5)
            return {
              type: "MatchOnce",
              terms: t3,
              all: true
            };
          let r2 = D2;
          for (let i2 = t3.length - 1; i2 >= 0; i2--) {
            const o2 = t3[i2];
            let s2;
            t3.length > 1 ? s2 = Jn2(
              e2,
              t3.filter(function(c2) {
                return c2 !== o2;
              }),
              false
            ) : s2 = N2, r2 = J2(
              o2,
              s2,
              r2
            );
          }
          return r2;
        }
        case "||": {
          if (t3.length > 5)
            return {
              type: "MatchOnce",
              terms: t3,
              all: false
            };
          let r2 = n2 ? N2 : D2;
          for (let i2 = t3.length - 1; i2 >= 0; i2--) {
            const o2 = t3[i2];
            let s2;
            t3.length > 1 ? s2 = Jn2(
              e2,
              t3.filter(function(c2) {
                return c2 !== o2;
              }),
              true
            ) : s2 = N2, r2 = J2(
              o2,
              s2,
              r2
            );
          }
          return r2;
        }
      }
    }
    function Ic(e2) {
      let t3 = N2, n2 = Pr2(e2.term);
      if (e2.max === 0)
        n2 = J2(
          n2,
          _r2,
          D2
        ), t3 = J2(
          n2,
          null,
          // will be a loop
          D2
        ), t3.then = J2(
          N2,
          N2,
          t3
          // make a loop
        ), e2.comma && (t3.then.else = J2(
          { type: "Comma", syntax: e2 },
          t3,
          D2
        ));
      else
        for (let r2 = e2.min || 1; r2 <= e2.max; r2++)
          e2.comma && t3 !== N2 && (t3 = J2(
            { type: "Comma", syntax: e2 },
            t3,
            D2
          )), t3 = J2(
            n2,
            J2(
              N2,
              N2,
              t3
            ),
            D2
          );
      if (e2.min === 0)
        t3 = J2(
          N2,
          N2,
          t3
        );
      else
        for (let r2 = 0; r2 < e2.min - 1; r2++)
          e2.comma && t3 !== N2 && (t3 = J2(
            { type: "Comma", syntax: e2 },
            t3,
            D2
          )), t3 = J2(
            n2,
            t3,
            D2
          );
      return t3;
    }
    function Pr2(e2) {
      if (typeof e2 == "function")
        return {
          type: "Generic",
          fn: e2
        };
      switch (e2.type) {
        case "Group": {
          let t3 = Jn2(
            e2.combinator,
            e2.terms.map(Pr2),
            false
          );
          return e2.disallowEmpty && (t3 = J2(
            t3,
            _r2,
            D2
          )), t3;
        }
        case "Multiplier":
          return Ic(e2);
        case "Type":
        case "Property":
          return {
            type: e2.type,
            name: e2.name,
            syntax: e2
          };
        case "Keyword":
          return {
            type: e2.type,
            name: e2.name.toLowerCase(),
            syntax: e2
          };
        case "AtKeyword":
          return {
            type: e2.type,
            name: "@" + e2.name.toLowerCase(),
            syntax: e2
          };
        case "Function":
          return {
            type: e2.type,
            name: e2.name.toLowerCase() + "(",
            syntax: e2
          };
        case "String":
          return e2.value.length === 3 ? {
            type: "Token",
            value: e2.value.charAt(1),
            syntax: e2
          } : {
            type: e2.type,
            value: e2.value.substr(1, e2.value.length - 2).replace(/\\'/g, "'"),
            syntax: e2
          };
        case "Token":
          return {
            type: e2.type,
            value: e2.value,
            syntax: e2
          };
        case "Comma":
          return {
            type: e2.type,
            syntax: e2
          };
        default:
          throw new Error("Unknown node type:", e2.type);
      }
    }
    function Vt2(e2, t3) {
      return typeof e2 == "string" && (e2 = Wo(e2)), {
        type: "MatchGraph",
        match: Pr2(e2),
        syntax: t3 || null,
        source: e2
      };
    }
    const { hasOwnProperty: gi2 } = Object.prototype, Rc = 0, Mc = 1, er2 = 2, Uo = 3, bi2 = "Match", Nc = "Mismatch", Dc = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)", yi2 = 15e3;
    function jc(e2) {
      let t3 = null, n2 = null, r2 = e2;
      for (; r2 !== null; )
        n2 = r2.prev, r2.prev = t3, t3 = r2, r2 = n2;
      return t3;
    }
    function Mn2(e2, t3) {
      if (e2.length !== t3.length)
        return false;
      for (let n2 = 0; n2 < e2.length; n2++) {
        const r2 = t3.charCodeAt(n2);
        let i2 = e2.charCodeAt(n2);
        if (i2 >= 65 && i2 <= 90 && (i2 = i2 | 32), i2 !== r2)
          return false;
      }
      return true;
    }
    function Fc(e2) {
      return e2.type !== I2 ? false : e2.value !== "?";
    }
    function ki2(e2) {
      return e2 === null ? true : e2.type === ce2 || e2.type === $5 || e2.type === M2 || e2.type === fe2 || e2.type === V2 || Fc(e2);
    }
    function xi2(e2) {
      return e2 === null ? true : e2.type === E2 || e2.type === Se2 || e2.type === ue2 || e2.type === I2 && e2.value === "/";
    }
    function Bc(e2, t3, n2) {
      function r2() {
        do
          x2++, b2 = x2 < e2.length ? e2[x2] : null;
        while (b2 !== null && (b2.type === W2 || b2.type === X2));
      }
      function i2(A2) {
        const P2 = x2 + A2;
        return P2 < e2.length ? e2[P2] : null;
      }
      function o2(A2, P2) {
        return {
          nextState: A2,
          matchStack: v2,
          syntaxStack: h2,
          thenStack: d2,
          tokenIndex: x2,
          prev: P2
        };
      }
      function s2(A2) {
        d2 = {
          nextState: A2,
          matchStack: v2,
          syntaxStack: h2,
          prev: d2
        };
      }
      function c2(A2) {
        m2 = o2(A2, m2);
      }
      function l2() {
        v2 = {
          type: Mc,
          syntax: t3.syntax,
          token: b2,
          prev: v2
        }, r2(), w2 = null, x2 > T2 && (T2 = x2);
      }
      function a2() {
        h2 = {
          syntax: t3.syntax,
          opts: t3.syntax.opts || h2 !== null && h2.opts || null,
          prev: h2
        }, v2 = {
          type: er2,
          syntax: t3.syntax,
          token: v2.token,
          prev: v2
        };
      }
      function u2() {
        v2.type === er2 ? v2 = v2.prev : v2 = {
          type: Uo,
          syntax: h2.syntax,
          token: v2.token,
          prev: v2
        }, h2 = h2.prev;
      }
      let h2 = null, d2 = null, m2 = null, w2 = null, k2 = 0, C2 = null, b2 = null, x2 = -1, T2 = 0, v2 = {
        type: Rc,
        syntax: null,
        token: null,
        prev: null
      };
      for (r2(); C2 === null && ++k2 < yi2; )
        switch (t3.type) {
          case "Match":
            if (d2 === null) {
              if (b2 !== null && (x2 !== e2.length - 1 || b2.value !== "\\0" && b2.value !== "\\9")) {
                t3 = D2;
                break;
              }
              C2 = bi2;
              break;
            }
            if (t3 = d2.nextState, t3 === _r2)
              if (d2.matchStack === v2) {
                t3 = D2;
                break;
              } else
                t3 = N2;
            for (; d2.syntaxStack !== h2; )
              u2();
            d2 = d2.prev;
            break;
          case "Mismatch":
            if (w2 !== null && w2 !== false)
              (m2 === null || x2 > m2.tokenIndex) && (m2 = w2, w2 = false);
            else if (m2 === null) {
              C2 = Nc;
              break;
            }
            t3 = m2.nextState, d2 = m2.thenStack, h2 = m2.syntaxStack, v2 = m2.matchStack, x2 = m2.tokenIndex, b2 = x2 < e2.length ? e2[x2] : null, m2 = m2.prev;
            break;
          case "MatchGraph":
            t3 = t3.match;
            break;
          case "If":
            t3.else !== D2 && c2(t3.else), t3.then !== N2 && s2(t3.then), t3 = t3.match;
            break;
          case "MatchOnce":
            t3 = {
              type: "MatchOnceBuffer",
              syntax: t3,
              index: 0,
              mask: 0
            };
            break;
          case "MatchOnceBuffer": {
            const O2 = t3.syntax.terms;
            if (t3.index === O2.length) {
              if (t3.mask === 0 || t3.syntax.all) {
                t3 = D2;
                break;
              }
              t3 = N2;
              break;
            }
            if (t3.mask === (1 << O2.length) - 1) {
              t3 = N2;
              break;
            }
            for (; t3.index < O2.length; t3.index++) {
              const p2 = 1 << t3.index;
              if (!(t3.mask & p2)) {
                c2(t3), s2({
                  type: "AddMatchOnce",
                  syntax: t3.syntax,
                  mask: t3.mask | p2
                }), t3 = O2[t3.index++];
                break;
              }
            }
            break;
          }
          case "AddMatchOnce":
            t3 = {
              type: "MatchOnceBuffer",
              syntax: t3.syntax,
              index: 0,
              mask: t3.mask
            };
            break;
          case "Enum":
            if (b2 !== null) {
              let O2 = b2.value.toLowerCase();
              if (O2.indexOf("\\") !== -1 && (O2 = O2.replace(/\\[09].*$/, "")), gi2.call(t3.map, O2)) {
                t3 = t3.map[O2];
                break;
              }
            }
            t3 = D2;
            break;
          case "Generic": {
            const O2 = h2 !== null ? h2.opts : null, p2 = x2 + Math.floor(t3.fn(b2, i2, O2));
            if (!isNaN(p2) && p2 > x2) {
              for (; x2 < p2; )
                l2();
              t3 = N2;
            } else
              t3 = D2;
            break;
          }
          case "Type":
          case "Property": {
            const O2 = t3.type === "Type" ? "types" : "properties", p2 = gi2.call(n2, O2) ? n2[O2][t3.name] : null;
            if (!p2 || !p2.match)
              throw new Error(
                "Bad syntax reference: " + (t3.type === "Type" ? "<" + t3.name + ">" : "<'" + t3.name + "'>")
              );
            if (w2 !== false && b2 !== null && t3.type === "Type" && // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            (t3.name === "custom-ident" && b2.type === y2 || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            t3.name === "length" && b2.value === "0")) {
              w2 === null && (w2 = o2(t3, m2)), t3 = D2;
              break;
            }
            a2(), t3 = p2.matchRef || p2.match;
            break;
          }
          case "Keyword": {
            const O2 = t3.name;
            if (b2 !== null) {
              let p2 = b2.value;
              if (p2.indexOf("\\") !== -1 && (p2 = p2.replace(/\\[09].*$/, "")), Mn2(p2, O2)) {
                l2(), t3 = N2;
                break;
              }
            }
            t3 = D2;
            break;
          }
          case "AtKeyword":
          case "Function":
            if (b2 !== null && Mn2(b2.value, t3.name)) {
              l2(), t3 = N2;
              break;
            }
            t3 = D2;
            break;
          case "Token":
            if (b2 !== null && b2.value === t3.value) {
              l2(), t3 = N2;
              break;
            }
            t3 = D2;
            break;
          case "Comma":
            b2 !== null && b2.type === ce2 ? ki2(v2.token) ? t3 = D2 : (l2(), t3 = xi2(b2) ? D2 : N2) : t3 = ki2(v2.token) || xi2(b2) ? N2 : D2;
            break;
          case "String":
            let A2 = "", P2 = x2;
            for (; P2 < e2.length && A2.length < t3.value.length; P2++)
              A2 += e2[P2].value;
            if (Mn2(A2, t3.value)) {
              for (; x2 < P2; )
                l2();
              t3 = N2;
            } else
              t3 = D2;
            break;
          default:
            throw new Error("Unknown node type: " + t3.type);
        }
      switch (C2) {
        case null:
          console.warn("[csstree-match] BREAK after " + yi2 + " iterations"), C2 = Dc, v2 = null;
          break;
        case bi2:
          for (; h2 !== null; )
            u2();
          break;
        default:
          v2 = null;
      }
      return {
        tokens: e2,
        reason: C2,
        iterations: k2,
        match: v2,
        longestMatch: T2
      };
    }
    function wi2(e2, t3, n2) {
      const r2 = Bc(e2, t3, n2 || {});
      if (r2.match === null)
        return r2;
      let i2 = r2.match, o2 = r2.match = {
        syntax: t3.syntax || null,
        match: []
      };
      const s2 = [o2];
      for (i2 = jc(i2).prev; i2 !== null; ) {
        switch (i2.type) {
          case er2:
            o2.match.push(o2 = {
              syntax: i2.syntax,
              match: []
            }), s2.push(o2);
            break;
          case Uo:
            s2.pop(), o2 = s2[s2.length - 1];
            break;
          default:
            o2.match.push({
              syntax: i2.syntax || null,
              token: i2.token.value,
              node: i2.token.node
            });
        }
        i2 = i2.prev;
      }
      return r2;
    }
    function qo(e2) {
      function t3(i2) {
        return i2 === null ? false : i2.type === "Type" || i2.type === "Property" || i2.type === "Keyword";
      }
      function n2(i2) {
        if (Array.isArray(i2.match)) {
          for (let o2 = 0; o2 < i2.match.length; o2++)
            if (n2(i2.match[o2]))
              return t3(i2.syntax) && r2.unshift(i2.syntax), true;
        } else if (i2.node === e2)
          return r2 = t3(i2.syntax) ? [i2.syntax] : [], true;
        return false;
      }
      let r2 = null;
      return this.matched !== null && n2(this.matched), r2;
    }
    function Wc(e2, t3) {
      return zr2(this, e2, (n2) => n2.type === "Type" && n2.name === t3);
    }
    function Hc(e2, t3) {
      return zr2(this, e2, (n2) => n2.type === "Property" && n2.name === t3);
    }
    function Uc(e2) {
      return zr2(this, e2, (t3) => t3.type === "Keyword");
    }
    function zr2(e2, t3, n2) {
      const r2 = qo.call(e2, t3);
      return r2 === null ? false : r2.some(n2);
    }
    const qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      getTrace: qo,
      isKeyword: Uc,
      isProperty: Hc,
      isType: Wc
    }, Symbol.toStringTag, { value: "Module" }));
    function Go(e2) {
      return "node" in e2 ? e2.node : Go(e2.match[0]);
    }
    function Vo(e2) {
      return "node" in e2 ? e2.node : Vo(e2.match[e2.match.length - 1]);
    }
    function vi2(e2, t3, n2, r2, i2) {
      function o2(c2) {
        if (c2.syntax !== null && c2.syntax.type === r2 && c2.syntax.name === i2) {
          const l2 = Go(c2), a2 = Vo(c2);
          e2.syntax.walk(t3, function(u2, h2, d2) {
            if (u2 === l2) {
              const m2 = new q2();
              do {
                if (m2.appendData(h2.data), h2.data === a2)
                  break;
                h2 = h2.next;
              } while (h2 !== null);
              s2.push({
                parent: d2,
                nodes: m2
              });
            }
          });
        }
        Array.isArray(c2.match) && c2.match.forEach(o2);
      }
      const s2 = [];
      return n2.matched !== null && o2(n2.matched), s2;
    }
    const { hasOwnProperty: At2 } = Object.prototype;
    function Nn2(e2) {
      return typeof e2 == "number" && isFinite(e2) && Math.floor(e2) === e2 && e2 >= 0;
    }
    function Si2(e2) {
      return !!e2 && Nn2(e2.offset) && Nn2(e2.line) && Nn2(e2.column);
    }
    function Gc(e2, t3) {
      return function(r2, i2) {
        if (!r2 || r2.constructor !== Object)
          return i2(r2, "Type of node should be an Object");
        for (let o2 in r2) {
          let s2 = true;
          if (At2.call(r2, o2) !== false) {
            if (o2 === "type")
              r2.type !== e2 && i2(r2, "Wrong node type `" + r2.type + "`, expected `" + e2 + "`");
            else if (o2 === "loc") {
              if (r2.loc === null)
                continue;
              if (r2.loc && r2.loc.constructor === Object)
                if (typeof r2.loc.source != "string")
                  o2 += ".source";
                else if (!Si2(r2.loc.start))
                  o2 += ".start";
                else if (!Si2(r2.loc.end))
                  o2 += ".end";
                else
                  continue;
              s2 = false;
            } else if (t3.hasOwnProperty(o2)) {
              s2 = false;
              for (let c2 = 0; !s2 && c2 < t3[o2].length; c2++) {
                const l2 = t3[o2][c2];
                switch (l2) {
                  case String:
                    s2 = typeof r2[o2] == "string";
                    break;
                  case Boolean:
                    s2 = typeof r2[o2] == "boolean";
                    break;
                  case null:
                    s2 = r2[o2] === null;
                    break;
                  default:
                    typeof l2 == "string" ? s2 = r2[o2] && r2[o2].type === l2 : Array.isArray(l2) && (s2 = r2[o2] instanceof q2);
                }
              }
            } else
              i2(r2, "Unknown field `" + o2 + "` for " + e2 + " node type");
            s2 || i2(r2, "Bad value for `" + e2 + "." + o2 + "`");
          }
        }
        for (const o2 in t3)
          At2.call(t3, o2) && At2.call(r2, o2) === false && i2(r2, "Field `" + e2 + "." + o2 + "` is missed");
      };
    }
    function Ko(e2, t3) {
      const n2 = [];
      for (let r2 = 0; r2 < e2.length; r2++) {
        const i2 = e2[r2];
        if (i2 === String || i2 === Boolean)
          n2.push(i2.name.toLowerCase());
        else if (i2 === null)
          n2.push("null");
        else if (typeof i2 == "string")
          n2.push(i2);
        else if (Array.isArray(i2))
          n2.push("List<" + (Ko(i2, t3) || "any") + ">");
        else
          throw new Error("Wrong value `" + i2 + "` in `" + t3 + "` structure definition");
      }
      return n2.join(" | ");
    }
    function Vc(e2, t3) {
      const n2 = t3.structure, r2 = {
        type: String,
        loc: true
      }, i2 = {
        type: '"' + e2 + '"'
      };
      for (const o2 in n2) {
        if (At2.call(n2, o2) === false)
          continue;
        const s2 = r2[o2] = Array.isArray(n2[o2]) ? n2[o2].slice() : [n2[o2]];
        i2[o2] = Ko(s2, e2 + "." + o2);
      }
      return {
        docs: i2,
        check: Gc(e2, r2)
      };
    }
    function Kc(e2) {
      const t3 = {};
      if (e2.node) {
        for (const n2 in e2.node)
          if (At2.call(e2.node, n2)) {
            const r2 = e2.node[n2];
            if (r2.structure)
              t3[n2] = Vc(n2, r2);
            else
              throw new Error("Missed `structure` field in `" + n2 + "` node type definition");
          }
      }
      return t3;
    }
    const Yc = Vt2(Lo.join(" | "));
    function tr2(e2, t3, n2) {
      const r2 = {};
      for (const i2 in e2)
        e2[i2].syntax && (r2[i2] = n2 ? e2[i2].syntax : Sr2(e2[i2].syntax, { compact: t3 }));
      return r2;
    }
    function Qc(e2, t3, n2) {
      const r2 = {};
      for (const [i2, o2] of Object.entries(e2))
        r2[i2] = {
          prelude: o2.prelude && (n2 ? o2.prelude.syntax : Sr2(o2.prelude.syntax, { compact: t3 })),
          descriptors: o2.descriptors && tr2(o2.descriptors, t3, n2)
        };
      return r2;
    }
    function Xc(e2) {
      for (let t3 = 0; t3 < e2.length; t3++)
        if (e2[t3].value.toLowerCase() === "var(")
          return true;
      return false;
    }
    function Zc(e2) {
      const t3 = e2.terms[0];
      return e2.explicit === false && e2.terms.length === 1 && t3.type === "Multiplier" && t3.comma === true;
    }
    function ye2(e2, t3, n2) {
      return _2({
        matched: e2,
        iterations: n2,
        error: t3
      }, qc);
    }
    function ot2(e2, t3, n2, r2) {
      const i2 = _c(n2, e2.syntax);
      let o2;
      return Xc(i2) ? ye2(null, new Error("Matching for a tree with var() is not supported")) : (r2 && (o2 = wi2(i2, e2.cssWideKeywordsSyntax, e2)), (!r2 || !o2.match) && (o2 = wi2(i2, t3.match, e2), !o2.match) ? ye2(
        null,
        new Ol(o2.reason, t3.syntax, n2, o2),
        o2.iterations
      ) : ye2(o2.match, null, o2.iterations));
    }
    class Ci2 {
      constructor(t3, n2, r2) {
        if (this.cssWideKeywordsSyntax = Yc, this.syntax = n2, this.generic = false, this.units = _2({}, si2), this.atrules = /* @__PURE__ */ Object.create(null), this.properties = /* @__PURE__ */ Object.create(null), this.types = /* @__PURE__ */ Object.create(null), this.structure = r2 || Kc(t3), t3) {
          if (t3.units)
            for (const i2 of Object.keys(si2))
              Array.isArray(t3.units[i2]) && (this.units[i2] = t3.units[i2]);
          if (t3.types)
            for (const [i2, o2] of Object.entries(t3.types))
              this.addType_(i2, o2);
          if (t3.generic) {
            this.generic = true;
            for (const [i2, o2] of Object.entries(Ql(this.units)))
              this.addType_(i2, o2);
          }
          if (t3.atrules)
            for (const [i2, o2] of Object.entries(t3.atrules))
              this.addAtrule_(i2, o2);
          if (t3.properties)
            for (const [i2, o2] of Object.entries(t3.properties))
              this.addProperty_(i2, o2);
        }
      }
      checkStructure(t3) {
        function n2(o2, s2) {
          i2.push({ node: o2, message: s2 });
        }
        const r2 = this.structure, i2 = [];
        return this.syntax.walk(t3, function(o2) {
          r2.hasOwnProperty(o2.type) ? r2[o2.type].check(o2, n2) : n2(o2, "Unknown node type `" + o2.type + "`");
        }), i2.length ? i2 : false;
      }
      createDescriptor(t3, n2, r2, i2 = null) {
        const o2 = {
          type: n2,
          name: r2
        }, s2 = {
          type: n2,
          name: r2,
          parent: i2,
          serializable: typeof t3 == "string" || t3 && typeof t3.type == "string",
          syntax: null,
          match: null,
          matchRef: null
          // used for properties when a syntax referenced as <'property'> in other syntax definitions
        };
        return typeof t3 == "function" ? s2.match = Vt2(t3, o2) : (typeof t3 == "string" ? Object.defineProperty(s2, "syntax", {
          get() {
            return Object.defineProperty(s2, "syntax", {
              value: Wo(t3)
            }), s2.syntax;
          }
        }) : s2.syntax = t3, Object.defineProperty(s2, "match", {
          get() {
            return Object.defineProperty(s2, "match", {
              value: Vt2(s2.syntax, o2)
            }), s2.match;
          }
        }), n2 === "Property" && Object.defineProperty(s2, "matchRef", {
          get() {
            const c2 = s2.syntax, l2 = Zc(c2) ? Vt2(Z2(_2({}, c2), {
              terms: [c2.terms[0].term]
            }), o2) : null;
            return Object.defineProperty(s2, "matchRef", {
              value: l2
            }), l2;
          }
        })), s2;
      }
      addAtrule_(t3, n2) {
        n2 && (this.atrules[t3] = {
          type: "Atrule",
          name: t3,
          prelude: n2.prelude ? this.createDescriptor(n2.prelude, "AtrulePrelude", t3) : null,
          descriptors: n2.descriptors ? Object.keys(n2.descriptors).reduce(
            (r2, i2) => (r2[i2] = this.createDescriptor(n2.descriptors[i2], "AtruleDescriptor", i2, t3), r2),
            /* @__PURE__ */ Object.create(null)
          ) : null
        });
      }
      addProperty_(t3, n2) {
        n2 && (this.properties[t3] = this.createDescriptor(n2, "Property", t3));
      }
      addType_(t3, n2) {
        n2 && (this.types[t3] = this.createDescriptor(n2, "Type", t3));
      }
      checkAtruleName(t3) {
        if (!this.getAtrule(t3))
          return new kt2("Unknown at-rule", "@" + t3);
      }
      checkAtrulePrelude(t3, n2) {
        const r2 = this.checkAtruleName(t3);
        if (r2)
          return r2;
        const i2 = this.getAtrule(t3);
        if (!i2.prelude && n2)
          return new SyntaxError("At-rule `@" + t3 + "` should not contain a prelude");
        if (i2.prelude && !n2 && !ot2(this, i2.prelude, "", false).matched)
          return new SyntaxError("At-rule `@" + t3 + "` should contain a prelude");
      }
      checkAtruleDescriptorName(t3, n2) {
        const r2 = this.checkAtruleName(t3);
        if (r2)
          return r2;
        const i2 = this.getAtrule(t3), o2 = Pn2(n2);
        if (!i2.descriptors)
          return new SyntaxError("At-rule `@" + t3 + "` has no known descriptors");
        if (!i2.descriptors[o2.name] && !i2.descriptors[o2.basename])
          return new kt2("Unknown at-rule descriptor", n2);
      }
      checkPropertyName(t3) {
        if (!this.getProperty(t3))
          return new kt2("Unknown property", t3);
      }
      matchAtrulePrelude(t3, n2) {
        const r2 = this.checkAtrulePrelude(t3, n2);
        if (r2)
          return ye2(null, r2);
        const i2 = this.getAtrule(t3);
        return i2.prelude ? ot2(this, i2.prelude, n2 || "", false) : ye2(null, null);
      }
      matchAtruleDescriptor(t3, n2, r2) {
        const i2 = this.checkAtruleDescriptorName(t3, n2);
        if (i2)
          return ye2(null, i2);
        const o2 = this.getAtrule(t3), s2 = Pn2(n2);
        return ot2(this, o2.descriptors[s2.name] || o2.descriptors[s2.basename], r2, false);
      }
      matchDeclaration(t3) {
        return t3.type !== "Declaration" ? ye2(null, new Error("Not a Declaration node")) : this.matchProperty(t3.property, t3.value);
      }
      matchProperty(t3, n2) {
        if (oi2(t3).custom)
          return ye2(null, new Error("Lexer matching doesn't applicable for custom properties"));
        const r2 = this.checkPropertyName(t3);
        return r2 ? ye2(null, r2) : ot2(this, this.getProperty(t3), n2, true);
      }
      matchType(t3, n2) {
        const r2 = this.getType(t3);
        return r2 ? ot2(this, r2, n2, false) : ye2(null, new kt2("Unknown type", t3));
      }
      match(t3, n2) {
        return typeof t3 != "string" && (!t3 || !t3.type) ? ye2(null, new kt2("Bad syntax")) : ((typeof t3 == "string" || !t3.match) && (t3 = this.createDescriptor(t3, "Type", "anonymous")), ot2(this, t3, n2, false));
      }
      findValueFragments(t3, n2, r2, i2) {
        return vi2(this, n2, this.matchProperty(t3, n2), r2, i2);
      }
      findDeclarationValueFragments(t3, n2, r2) {
        return vi2(this, t3.value, this.matchDeclaration(t3), n2, r2);
      }
      findAllFragments(t3, n2, r2) {
        const i2 = [];
        return this.syntax.walk(t3, {
          visit: "Declaration",
          enter: (o2) => {
            i2.push.apply(i2, this.findDeclarationValueFragments(o2, n2, r2));
          }
        }), i2;
      }
      getAtrule(t3, n2 = true) {
        const r2 = Pn2(t3);
        return (r2.vendor && n2 ? this.atrules[r2.name] || this.atrules[r2.basename] : this.atrules[r2.name]) || null;
      }
      getAtrulePrelude(t3, n2 = true) {
        const r2 = this.getAtrule(t3, n2);
        return r2 && r2.prelude || null;
      }
      getAtruleDescriptor(t3, n2) {
        return this.atrules.hasOwnProperty(t3) && this.atrules.declarators && this.atrules[t3].declarators[n2] || null;
      }
      getProperty(t3, n2 = true) {
        const r2 = oi2(t3);
        return (r2.vendor && n2 ? this.properties[r2.name] || this.properties[r2.basename] : this.properties[r2.name]) || null;
      }
      getType(t3) {
        return hasOwnProperty.call(this.types, t3) ? this.types[t3] : null;
      }
      validate() {
        function t3(i2, o2, s2, c2) {
          if (s2.has(o2))
            return s2.get(o2);
          s2.set(o2, false), c2.syntax !== null && Ec(c2.syntax, function(l2) {
            if (l2.type !== "Type" && l2.type !== "Property")
              return;
            const a2 = l2.type === "Type" ? i2.types : i2.properties, u2 = l2.type === "Type" ? n2 : r2;
            (!hasOwnProperty.call(a2, l2.name) || t3(i2, l2.name, u2, a2[l2.name])) && s2.set(o2, true);
          }, this);
        }
        let n2 = /* @__PURE__ */ new Map(), r2 = /* @__PURE__ */ new Map();
        for (const i2 in this.types)
          t3(this, i2, n2, this.types[i2]);
        for (const i2 in this.properties)
          t3(this, i2, r2, this.properties[i2]);
        return n2 = [...n2.keys()].filter((i2) => n2.get(i2)), r2 = [...r2.keys()].filter((i2) => r2.get(i2)), n2.length || r2.length ? {
          types: n2,
          properties: r2
        } : null;
      }
      dump(t3, n2) {
        return {
          generic: this.generic,
          units: this.units,
          types: tr2(this.types, !n2, t3),
          properties: tr2(this.properties, !n2, t3),
          atrules: Qc(this.atrules, !n2, t3)
        };
      }
      toString() {
        return JSON.stringify(this.dump());
      }
    }
    function Dn2(e2, t3) {
      return typeof t3 == "string" && /^\s*\|/.test(t3) ? typeof e2 == "string" ? e2 + t3 : t3.replace(/^\s*\|\s*/, "") : t3 || null;
    }
    function Ti2(e2, t3) {
      const n2 = /* @__PURE__ */ Object.create(null);
      for (const [r2, i2] of Object.entries(e2))
        if (i2) {
          n2[r2] = {};
          for (const o2 of Object.keys(i2))
            t3.includes(o2) && (n2[r2][o2] = i2[o2]);
        }
      return n2;
    }
    function nr2(e2, t3) {
      const n2 = _2({}, e2);
      for (const [r2, i2] of Object.entries(t3))
        switch (r2) {
          case "generic":
            n2[r2] = !!i2;
            break;
          case "units":
            n2[r2] = _2({}, e2[r2]);
            for (const [o2, s2] of Object.entries(i2))
              n2[r2][o2] = Array.isArray(s2) ? s2 : [];
            break;
          case "atrules":
            n2[r2] = _2({}, e2[r2]);
            for (const [o2, s2] of Object.entries(i2)) {
              const c2 = n2[r2][o2] || {}, l2 = n2[r2][o2] = {
                prelude: c2.prelude || null,
                descriptors: _2({}, c2.descriptors)
              };
              if (s2) {
                l2.prelude = s2.prelude ? Dn2(l2.prelude, s2.prelude) : l2.prelude || null;
                for (const [a2, u2] of Object.entries(s2.descriptors || {}))
                  l2.descriptors[a2] = u2 ? Dn2(l2.descriptors[a2], u2) : null;
                Object.keys(l2.descriptors).length || (l2.descriptors = null);
              }
            }
            break;
          case "types":
          case "properties":
            n2[r2] = _2({}, e2[r2]);
            for (const [o2, s2] of Object.entries(i2))
              n2[r2][o2] = Dn2(n2[r2][o2], s2);
            break;
          case "scope":
          case "features":
            n2[r2] = _2({}, e2[r2]);
            for (const [o2, s2] of Object.entries(i2))
              n2[r2][o2] = _2(_2({}, n2[r2][o2]), s2);
            break;
          case "parseContext":
            n2[r2] = _2(_2({}, e2[r2]), i2);
            break;
          case "atrule":
          case "pseudo":
            n2[r2] = _2(_2({}, e2[r2]), Ti2(i2, ["parse"]));
            break;
          case "node":
            n2[r2] = _2(_2({}, e2[r2]), Ti2(i2, ["name", "structure", "parse", "generate", "walkContext"]));
            break;
        }
      return n2;
    }
    function Yo(e2) {
      const t3 = rl(e2), n2 = wl(e2), r2 = bl(e2), { fromPlainObject: i2, toPlainObject: o2 } = yl(n2), s2 = {
        lexer: null,
        createLexer: (c2) => new Ci2(c2, s2, s2.lexer.structure),
        tokenize: gn2,
        parse: t3,
        generate: r2,
        walk: n2,
        find: n2.find,
        findLast: n2.findLast,
        findAll: n2.findAll,
        fromPlainObject: i2,
        toPlainObject: o2,
        fork(c2) {
          const l2 = nr2({}, e2);
          return Yo(
            typeof c2 == "function" ? c2(l2, Object.assign) : nr2(l2, c2)
          );
        }
      };
      return s2.lexer = new Ci2({
        generic: e2.generic,
        units: e2.units,
        types: e2.types,
        atrules: e2.atrules,
        properties: e2.properties,
        node: e2.node
      }, s2), s2;
    }
    const Jc = (e2) => Yo(nr2({}, e2)), eu = {
      generic: true,
      units: {
        angle: [
          "deg",
          "grad",
          "rad",
          "turn"
        ],
        decibel: [
          "db"
        ],
        flex: [
          "fr"
        ],
        frequency: [
          "hz",
          "khz"
        ],
        length: [
          "cm",
          "mm",
          "q",
          "in",
          "pt",
          "pc",
          "px",
          "em",
          "rem",
          "ex",
          "rex",
          "cap",
          "rcap",
          "ch",
          "rch",
          "ic",
          "ric",
          "lh",
          "rlh",
          "vw",
          "svw",
          "lvw",
          "dvw",
          "vh",
          "svh",
          "lvh",
          "dvh",
          "vi",
          "svi",
          "lvi",
          "dvi",
          "vb",
          "svb",
          "lvb",
          "dvb",
          "vmin",
          "svmin",
          "lvmin",
          "dvmin",
          "vmax",
          "svmax",
          "lvmax",
          "dvmax",
          "cqw",
          "cqh",
          "cqi",
          "cqb",
          "cqmin",
          "cqmax"
        ],
        resolution: [
          "dpi",
          "dpcm",
          "dppx",
          "x"
        ],
        semitones: [
          "st"
        ],
        time: [
          "s",
          "ms"
        ]
      },
      types: {
        "abs()": "abs( <calc-sum> )",
        "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
        "acos()": "acos( <calc-sum> )",
        "alpha-value": "<number>|<percentage>",
        "angle-percentage": "<angle>|<percentage>",
        "angular-color-hint": "<angle-percentage>",
        "angular-color-stop": "<color>&&<color-stop-angle>?",
        "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
        "animateable-feature": "scroll-position|contents|<custom-ident>",
        "asin()": "asin( <calc-sum> )",
        "atan()": "atan( <calc-sum> )",
        "atan2()": "atan2( <calc-sum> , <calc-sum> )",
        attachment: "scroll|fixed|local",
        "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
        "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
        "attr-modifier": "i|s",
        "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
        "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
        "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
        axis: "block|inline|vertical|horizontal",
        "baseline-position": "[first|last]? baseline",
        "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
        "bg-image": "none|<image>",
        "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
        "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
        "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
        "blur()": "blur( <length> )",
        "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
        box: "border-box|padding-box|content-box",
        "brightness()": "brightness( <number-percentage> )",
        "calc()": "calc( <calc-sum> )",
        "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
        "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
        "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
        "calc-constant": "e|pi|infinity|-infinity|NaN",
        "cf-final-image": "<image>|<color>",
        "cf-mixing-image": "<percentage>?&&<image>",
        "circle()": "circle( [<shape-radius>]? [at <position>]? )",
        "clamp()": "clamp( <calc-sum>#{3} )",
        "class-selector": "'.' <ident-token>",
        "clip-source": "<url>",
        color: "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>",
        "color-stop": "<color-stop-length>|<color-stop-angle>",
        "color-stop-angle": "<angle-percentage>{1,2}",
        "color-stop-length": "<length-percentage>{1,2}",
        "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
        combinator: "'>'|'+'|'~'|['|' '|']",
        "common-lig-values": "[common-ligatures|no-common-ligatures]",
        "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
        "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
        "compositing-operator": "add|subtract|intersect|exclude",
        "compound-selector": "[<type-selector>? <subclass-selector>*]!",
        "compound-selector-list": "<compound-selector>#",
        "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*",
        "complex-selector-list": "<complex-selector>#",
        "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
        "contextual-alt-values": "[contextual|no-contextual]",
        "content-distribution": "space-between|space-around|space-evenly|stretch",
        "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
        "content-position": "center|start|end|flex-start|flex-end",
        "content-replacement": "<image>",
        "contrast()": "contrast( [<number-percentage>] )",
        "cos()": "cos( <calc-sum> )",
        counter: "<counter()>|<counters()>",
        "counter()": "counter( <counter-name> , <counter-style>? )",
        "counter-name": "<custom-ident>",
        "counter-style": "<counter-style-name>|symbols( )",
        "counter-style-name": "<custom-ident>",
        "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
        "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
        "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
        "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
        "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
        "display-box": "contents|none",
        "display-inside": "flow|flow-root|table|flex|grid|ruby",
        "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
        "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
        "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
        "display-outside": "block|inline|run-in",
        "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
        "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
        "east-asian-width-values": "[full-width|proportional-width]",
        "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
        "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
        "ending-shape": "circle|ellipse",
        "env()": "env( <custom-ident> , <declaration-value>? )",
        "exp()": "exp( <calc-sum> )",
        "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
        "family-name": "<string>|<custom-ident>+",
        "feature-tag-value": "<string> [<integer>|on|off]?",
        "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
        "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
        "feature-value-block-list": "<feature-value-block>+",
        "feature-value-declaration": "<custom-ident> : <integer>+ ;",
        "feature-value-declaration-list": "<feature-value-declaration>",
        "feature-value-name": "<custom-ident>",
        "fill-rule": "nonzero|evenodd",
        "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
        "filter-function-list": "[<filter-function>|<url>]+",
        "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
        "fixed-breadth": "<length-percentage>",
        "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
        "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
        "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
        "font-variant-css21": "[normal|small-caps]",
        "font-weight-absolute": "normal|bold|<number [1,1000]>",
        "frequency-percentage": "<frequency>|<percentage>",
        "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]",
        "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>",
        "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
        "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
        gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
        "grayscale()": "grayscale( <number-percentage> )",
        "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
        "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
        "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
        "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
        hue: "<number>|<angle>",
        "hue-rotate()": "hue-rotate( <angle> )",
        "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
        "hypot()": "hypot( <calc-sum># )",
        image: "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
        "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
        "image-set()": "image-set( <image-set-option># )",
        "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
        "image-src": "<url>|<string>",
        "image-tags": "ltr|rtl",
        "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
        "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
        "invert()": "invert( <number-percentage> )",
        "keyframes-name": "<custom-ident>|<string>",
        "keyframe-block": "<keyframe-selector># { <declaration-list> }",
        "keyframe-block-list": "<keyframe-block>+",
        "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>",
        "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
        "layer()": "layer( <layer-name> )",
        "layer-name": "<ident> ['.' <ident>]*",
        "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
        "leader()": "leader( <leader-type> )",
        "leader-type": "dotted|solid|space|<string>",
        "length-percentage": "<length>|<percentage>",
        "light-dark()": "light-dark( <color> , <color> )",
        "line-names": "'[' <custom-ident>* ']'",
        "line-name-list": "[<line-names>|<name-repeat>]+",
        "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
        "line-width": "<length>|thin|medium|thick",
        "linear-color-hint": "<length-percentage>",
        "linear-color-stop": "<color> <color-stop-length>?",
        "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
        "log()": "log( <calc-sum> , <calc-sum>? )",
        "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
        "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
        "mask-reference": "none|<image>|<mask-source>",
        "mask-source": "<url>",
        "masking-mode": "alpha|luminance|match-source",
        "matrix()": "matrix( <number>#{6} )",
        "matrix3d()": "matrix3d( <number>#{16} )",
        "max()": "max( <calc-sum># )",
        "media-and": "<media-in-parens> [and <media-in-parens>]+",
        "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
        "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
        "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
        "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
        "media-not": "not <media-in-parens>",
        "media-or": "<media-in-parens> [or <media-in-parens>]+",
        "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
        "media-query-list": "<media-query>#",
        "media-type": "<ident>",
        "mf-boolean": "<mf-name>",
        "mf-name": "<ident>",
        "mf-plain": "<mf-name> : <mf-value>",
        "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
        "mf-value": "<number>|<dimension>|<ident>|<ratio>",
        "min()": "min( <calc-sum># )",
        "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
        "mod()": "mod( <calc-sum> , <calc-sum> )",
        "name-repeat": "repeat( [<integer [1,\u221E]>|auto-fill] , <line-names>+ )",
        "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen",
        "namespace-prefix": "<ident>",
        "ns-prefix": "[<ident-token>|'*']? '|'",
        "number-percentage": "<number>|<percentage>",
        "numeric-figure-values": "[lining-nums|oldstyle-nums]",
        "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
        "numeric-spacing-values": "[proportional-nums|tabular-nums]",
        nth: "<an-plus-b>|even|odd",
        "opacity()": "opacity( [<number-percentage>] )",
        "overflow-position": "unsafe|safe",
        "outline-radius": "<length>|<percentage>",
        "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
        "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
        "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
        "page-selector-list": "[<page-selector>#]?",
        "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
        "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
        "path()": "path( [<fill-rule> ,]? <string> )",
        "paint()": "paint( <ident> , <declaration-value>? )",
        "perspective()": "perspective( [<length [0,\u221E]>|none] )",
        "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
        position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
        "pow()": "pow( <calc-sum> , <calc-sum> )",
        "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
        "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>",
        "pseudo-page": ": [left|right|first|blank]",
        quote: "open-quote|close-quote|no-open-quote|no-close-quote",
        "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
        ratio: "<number [0,\u221E]> [/ <number [0,\u221E]>]?",
        "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )",
        "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides",
        "relative-selector": "<combinator>? <complex-selector>",
        "relative-selector-list": "<relative-selector>#",
        "relative-size": "larger|smaller",
        "rem()": "rem( <calc-sum> , <calc-sum> )",
        "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
        "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
        "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
        "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
        "reversed-counter-name": "reversed( <counter-name> )",
        "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
        "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
        "rotate()": "rotate( [<angle>|<zero>] )",
        "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
        "rotateX()": "rotateX( [<angle>|<zero>] )",
        "rotateY()": "rotateY( [<angle>|<zero>] )",
        "rotateZ()": "rotateZ( [<angle>|<zero>] )",
        "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
        "rounding-strategy": "nearest|up|down|to-zero",
        "saturate()": "saturate( <number-percentage> )",
        "scale()": "scale( [<number>|<percentage>]#{1,2} )",
        "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
        "scaleX()": "scaleX( [<number>|<percentage>] )",
        "scaleY()": "scaleY( [<number>|<percentage>] )",
        "scaleZ()": "scaleZ( [<number>|<percentage>] )",
        "scroll()": "scroll( [<axis>||<scroller>]? )",
        scroller: "root|nearest",
        "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
        "shape-radius": "<length-percentage>|closest-side|farthest-side",
        "sign()": "sign( <calc-sum> )",
        "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
        "skewX()": "skewX( [<angle>|<zero>] )",
        "skewY()": "skewY( [<angle>|<zero>] )",
        "sepia()": "sepia( <number-percentage> )",
        shadow: "inset?&&<length>{2,4}&&<color>?",
        "shadow-t": "[<length>{2,3}&&<color>?]",
        shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
        "shape-box": "<box>|margin-box",
        "side-or-corner": "[left|right]||[top|bottom]",
        "sin()": "sin( <calc-sum> )",
        "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>",
        "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
        "single-animation-fill-mode": "none|forwards|backwards|both",
        "single-animation-iteration-count": "infinite|<number>",
        "single-animation-play-state": "running|paused",
        "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>",
        "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>",
        "single-transition-property": "all|<custom-ident>",
        size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
        "sqrt()": "sqrt( <calc-sum> )",
        "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
        "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
        "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
        "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
        "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
        "supports-feature": "<supports-decl>|<supports-selector-fn>",
        "supports-decl": "( <declaration> )",
        "supports-selector-fn": "selector( <complex-selector> )",
        symbol: "<string>|<image>|<custom-ident>",
        "tan()": "tan( <calc-sum> )",
        target: "<target-counter()>|<target-counters()>|<target-text()>",
        "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
        "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
        "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
        "time-percentage": "<time>|<percentage>",
        "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing",
        "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
        "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
        "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
        "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )",
        "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
        "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
        "transform-list": "<transform-function>+",
        "transition-behavior-value": "normal|allow-discrete",
        "translate()": "translate( <length-percentage> , <length-percentage>? )",
        "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
        "translateX()": "translateX( <length-percentage> )",
        "translateY()": "translateY( <length-percentage> )",
        "translateZ()": "translateZ( <length> )",
        "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
        "type-selector": "<wq-name>|<ns-prefix>? '*'",
        "var()": "var( <custom-property-name> , <declaration-value>? )",
        "view()": "view( [<axis>||<'view-timeline-inset'>]? )",
        "viewport-length": "auto|<length-percentage>",
        "visual-box": "content-box|padding-box|border-box",
        "wq-name": "<ns-prefix>? <ident-token>",
        "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
        "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
        "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
        "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
        "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
        "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
        "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
        "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
        "-legacy-radial-gradient-shape": "circle|ellipse",
        "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
        "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
        "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
        "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
        "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content",
        "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
        "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
        "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
        "-webkit-gradient-radius": "<length>|<percentage>",
        "-webkit-gradient-type": "linear|radial",
        "-webkit-mask-box-repeat": "repeat|stretch|round",
        "-ms-filter-function-list": "<-ms-filter-function>+",
        "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
        "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
        "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
        "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent",
        "absolute-color-function": "rgb( ) >|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
        age: "child|young|old",
        "attr-name": "<wq-name>",
        "attr-fallback": "<any-value>",
        "bg-clip": "<box>|border|text",
        bottom: "<length>|auto",
        "container-name": "<custom-ident>",
        "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
        "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box",
        "generic-voice": "[<age>? <gender> <integer>?]",
        gender: "male|female|neutral",
        "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )",
        "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace",
        "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded",
        "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont",
        left: "<length>|auto",
        "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent",
        "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
        "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText",
        "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>",
        "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )",
        "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )",
        "cmyk-component": "<number>|<percentage>|none",
        "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )",
        "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]",
        "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>",
        "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65",
        "polar-color-space": "hsl|hwb|lch|oklch",
        "custom-color-space": "<dashed-ident>",
        "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue",
        paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
        "palette-identifier": "<dashed-ident>",
        right: "<length>|auto",
        "scope-start": "<forgiving-selector-list>",
        "scope-end": "<forgiving-selector-list>",
        "forgiving-selector-list": "<complex-real-selector-list>",
        "forgiving-relative-selector-list": "<relative-real-selector-list>",
        "selector-list": "<complex-selector-list>",
        "complex-real-selector-list": "<complex-real-selector>#",
        "simple-selector-list": "<simple-selector>#",
        "relative-real-selector-list": "<relative-real-selector>#",
        "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!",
        "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
        "relative-real-selector": "<combinator>? <complex-real-selector>",
        "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*",
        "simple-selector": "<type-selector>|<subclass-selector>",
        "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]",
        "single-animation-composition": "replace|add|accumulate",
        "svg-length": "<percentage>|<length>|<number>",
        "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
        top: "<length>|auto",
        x: "<number>",
        y: "<number>",
        declaration: "<ident-token> : <declaration-value>? ['!' important]?",
        "declaration-list": "[<declaration>? ';']* <declaration>?",
        url: "url( <string> <url-modifier>* )|<url-token>",
        "url-modifier": "<ident>|<function-token> <any-value> )",
        "number-zero-one": "<number [0,1]>",
        "number-one-or-greater": "<number [1,\u221E]>",
        "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )",
        "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]",
        "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}",
        "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020",
        "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}",
        "xyz-space": "xyz|xyz-d50|xyz-d65",
        "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
        "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
        "offset-path": "<ray()>|<url>|<basic-shape>",
        "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
        "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
        "style-feature": "<declaration>",
        "style-query": "<style-condition>|<style-feature>",
        "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
        "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
        "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
        "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
        "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
        "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )",
        "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center",
        "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )",
        "anchor-size": "width|height|block|inline|self-block|self-inline",
        "anchor-element": "<dashed-ident>",
        "try-size": "most-width|most-height|most-block-size|most-inline-size",
        "try-tactic": "flip-block||flip-inline||flip-start",
        "font-variant-css2": "normal|small-caps",
        "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
        "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar"
      },
      properties: {
        "--*": "<declaration-value>",
        "-ms-accelerator": "false|true",
        "-ms-block-progression": "tb|rl|bt|lr",
        "-ms-content-zoom-chaining": "none|chained",
        "-ms-content-zooming": "none|zoom",
        "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        "-ms-content-zoom-limit-max": "<percentage>",
        "-ms-content-zoom-limit-min": "<percentage>",
        "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
        "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
        "-ms-content-zoom-snap-type": "none|proximity|mandatory",
        "-ms-filter": "<string>",
        "-ms-flow-from": "[none|<custom-ident>]#",
        "-ms-flow-into": "[none|<custom-ident>]#",
        "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
        "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
        "-ms-high-contrast-adjust": "auto|none",
        "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
        "-ms-hyphenate-limit-lines": "no-limit|<integer>",
        "-ms-hyphenate-limit-zone": "<percentage>|<length>",
        "-ms-ime-align": "auto|after",
        "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
        "-ms-scrollbar-3dlight-color": "<color>",
        "-ms-scrollbar-arrow-color": "<color>",
        "-ms-scrollbar-base-color": "<color>",
        "-ms-scrollbar-darkshadow-color": "<color>",
        "-ms-scrollbar-face-color": "<color>",
        "-ms-scrollbar-highlight-color": "<color>",
        "-ms-scrollbar-shadow-color": "<color>",
        "-ms-scrollbar-track-color": "<color>",
        "-ms-scroll-chaining": "chained|none",
        "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        "-ms-scroll-limit-x-max": "auto|<length>",
        "-ms-scroll-limit-x-min": "<length>",
        "-ms-scroll-limit-y-max": "auto|<length>",
        "-ms-scroll-limit-y-min": "<length>",
        "-ms-scroll-rails": "none|railed",
        "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
        "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
        "-ms-scroll-snap-type": "none|proximity|mandatory",
        "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        "-ms-scroll-translation": "none|vertical-to-horizontal",
        "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
        "-ms-touch-select": "grippers|none",
        "-ms-user-select": "none|element|text",
        "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
        "-ms-wrap-margin": "<length>",
        "-ms-wrap-through": "wrap|none",
        "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
        "-moz-binding": "<url>|none",
        "-moz-border-bottom-colors": "<color>+|none",
        "-moz-border-left-colors": "<color>+|none",
        "-moz-border-right-colors": "<color>+|none",
        "-moz-border-top-colors": "<color>+|none",
        "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
        "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
        "-moz-force-broken-image-icon": "0|1",
        "-moz-image-region": "<shape>|auto",
        "-moz-orient": "inline|block|horizontal|vertical",
        "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
        "-moz-outline-radius-bottomleft": "<outline-radius>",
        "-moz-outline-radius-bottomright": "<outline-radius>",
        "-moz-outline-radius-topleft": "<outline-radius>",
        "-moz-outline-radius-topright": "<outline-radius>",
        "-moz-stack-sizing": "ignore|stretch-to-fit",
        "-moz-text-blink": "none|blink",
        "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
        "-moz-user-input": "auto|none|enabled|disabled",
        "-moz-user-modify": "read-only|read-write|write-only",
        "-moz-window-dragging": "drag|no-drag",
        "-moz-window-shadow": "default|menu|tooltip|sheet|none",
        "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
        "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
        "-webkit-border-before-color": "<color>",
        "-webkit-border-before-style": "<'border-style'>",
        "-webkit-border-before-width": "<'border-width'>",
        "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
        "-webkit-line-clamp": "none|<integer>",
        "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
        "-webkit-mask-attachment": "<attachment>#",
        "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
        "-webkit-mask-composite": "<composite-style>#",
        "-webkit-mask-image": "<mask-reference>#",
        "-webkit-mask-origin": "[<box>|border|padding|content]#",
        "-webkit-mask-position": "<position>#",
        "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
        "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
        "-webkit-mask-repeat": "<repeat-style>#",
        "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
        "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
        "-webkit-mask-size": "<bg-size>#",
        "-webkit-overflow-scrolling": "auto|touch",
        "-webkit-tap-highlight-color": "<color>",
        "-webkit-text-fill-color": "<color>",
        "-webkit-text-stroke": "<length>||<color>",
        "-webkit-text-stroke-color": "<color>",
        "-webkit-text-stroke-width": "<length>",
        "-webkit-touch-callout": "default|none",
        "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
        "accent-color": "auto|<color>",
        "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
        "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
        "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
        "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
        all: "initial|inherit|unset|revert|revert-layer",
        "anchor-name": "none|<dashed-ident>#",
        "anchor-scope": "none|all|<dashed-ident>#",
        animation: "<single-animation>#",
        "animation-composition": "<single-animation-composition>#",
        "animation-delay": "<time>#",
        "animation-direction": "<single-animation-direction>#",
        "animation-duration": "<time>#",
        "animation-fill-mode": "<single-animation-fill-mode>#",
        "animation-iteration-count": "<single-animation-iteration-count>#",
        "animation-name": "[none|<keyframes-name>]#",
        "animation-play-state": "<single-animation-play-state>#",
        "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#",
        "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
        "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
        "animation-timing-function": "<easing-function>#",
        "animation-timeline": "<single-animation-timeline>#",
        appearance: "none|auto|textfield|menulist-button|<compat-auto>",
        "aspect-ratio": "auto|<ratio>",
        azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
        "backdrop-filter": "none|<filter-function-list>",
        "backface-visibility": "visible|hidden",
        background: "[<bg-layer> ,]* <final-bg-layer>",
        "background-attachment": "<attachment>#",
        "background-blend-mode": "<blend-mode>#",
        "background-clip": "<bg-clip>#",
        "background-color": "<color>",
        "background-image": "<bg-image>#",
        "background-origin": "<box>#",
        "background-position": "<bg-position>#",
        "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
        "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
        "background-repeat": "<repeat-style>#",
        "background-size": "<bg-size>#",
        "block-size": "<'width'>",
        border: "<line-width>||<line-style>||<color>",
        "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-block-color": "<'border-top-color'>{1,2}",
        "border-block-style": "<'border-top-style'>",
        "border-block-width": "<'border-top-width'>",
        "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-block-end-color": "<'border-top-color'>",
        "border-block-end-style": "<'border-top-style'>",
        "border-block-end-width": "<'border-top-width'>",
        "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-block-start-color": "<'border-top-color'>",
        "border-block-start-style": "<'border-top-style'>",
        "border-block-start-width": "<'border-top-width'>",
        "border-bottom": "<line-width>||<line-style>||<color>",
        "border-bottom-color": "<'border-top-color'>",
        "border-bottom-left-radius": "<length-percentage>{1,2}",
        "border-bottom-right-radius": "<length-percentage>{1,2}",
        "border-bottom-style": "<line-style>",
        "border-bottom-width": "<line-width>",
        "border-collapse": "collapse|separate",
        "border-color": "<color>{1,4}",
        "border-end-end-radius": "<length-percentage>{1,2}",
        "border-end-start-radius": "<length-percentage>{1,2}",
        "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
        "border-image-outset": "[<length>|<number>]{1,4}",
        "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
        "border-image-slice": "<number-percentage>{1,4}&&fill?",
        "border-image-source": "none|<image>",
        "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
        "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-inline-color": "<'border-top-color'>{1,2}",
        "border-inline-style": "<'border-top-style'>",
        "border-inline-width": "<'border-top-width'>",
        "border-inline-end-color": "<'border-top-color'>",
        "border-inline-end-style": "<'border-top-style'>",
        "border-inline-end-width": "<'border-top-width'>",
        "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-inline-start-color": "<'border-top-color'>",
        "border-inline-start-style": "<'border-top-style'>",
        "border-inline-start-width": "<'border-top-width'>",
        "border-left": "<line-width>||<line-style>||<color>",
        "border-left-color": "<color>",
        "border-left-style": "<line-style>",
        "border-left-width": "<line-width>",
        "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
        "border-right": "<line-width>||<line-style>||<color>",
        "border-right-color": "<color>",
        "border-right-style": "<line-style>",
        "border-right-width": "<line-width>",
        "border-spacing": "<length> <length>?",
        "border-start-end-radius": "<length-percentage>{1,2}",
        "border-start-start-radius": "<length-percentage>{1,2}",
        "border-style": "<line-style>{1,4}",
        "border-top": "<line-width>||<line-style>||<color>",
        "border-top-color": "<color>",
        "border-top-left-radius": "<length-percentage>{1,2}",
        "border-top-right-radius": "<length-percentage>{1,2}",
        "border-top-style": "<line-style>",
        "border-top-width": "<line-width>",
        "border-width": "<line-width>{1,4}",
        bottom: "<length>|<percentage>|auto",
        "box-align": "start|center|end|baseline|stretch",
        "box-decoration-break": "slice|clone",
        "box-direction": "normal|reverse|inherit",
        "box-flex": "<number>",
        "box-flex-group": "<integer>",
        "box-lines": "single|multiple",
        "box-ordinal-group": "<integer>",
        "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
        "box-pack": "start|center|end|justify",
        "box-shadow": "none|<shadow>#",
        "box-sizing": "content-box|border-box",
        "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
        "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
        "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
        "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
        caret: "<'caret-color'>||<'caret-shape'>",
        "caret-color": "auto|<color>",
        "caret-shape": "auto|bar|block|underscore",
        clear: "none|left|right|both|inline-start|inline-end",
        clip: "<shape>|auto",
        "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
        "clip-rule": "nonzero|evenodd",
        color: "<color>",
        "color-interpolation-filters": "auto|sRGB|linearRGB",
        "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
        "column-count": "<integer>|auto",
        "column-fill": "auto|balance|balance-all",
        "column-gap": "normal|<length-percentage>",
        "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
        "column-rule-color": "<color>",
        "column-rule-style": "<'border-style'>",
        "column-rule-width": "<'border-width'>",
        "column-span": "none|all",
        "column-width": "<length>|auto",
        columns: "<'column-width'>||<'column-count'>",
        contain: "none|strict|content|[[size||inline-size]||layout||style||paint]",
        "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}",
        "contain-intrinsic-block-size": "auto? [none|<length>]",
        "contain-intrinsic-height": "auto? [none|<length>]",
        "contain-intrinsic-inline-size": "auto? [none|<length>]",
        "contain-intrinsic-width": "auto? [none|<length>]",
        container: "<'container-name'> [/ <'container-type'>]?",
        "container-name": "none|<custom-ident>+",
        "container-type": "normal||[size|inline-size]",
        content: "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
        "content-visibility": "visible|auto|hidden",
        "counter-increment": "[<counter-name> <integer>?]+|none",
        "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
        "counter-set": "[<counter-name> <integer>?]+|none",
        cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
        d: "none|path( <string> )",
        cx: "<length>|<percentage>",
        cy: "<length>|<percentage>",
        direction: "ltr|rtl",
        display: "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
        "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
        "empty-cells": "show|hide",
        "field-sizing": "content|fixed",
        fill: "<paint>",
        "fill-opacity": "<number-zero-one>",
        "fill-rule": "nonzero|evenodd",
        filter: "none|<filter-function-list>|<-ms-filter-function-list>",
        flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
        "flex-basis": "content|<'width'>",
        "flex-direction": "row|row-reverse|column|column-reverse",
        "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
        "flex-grow": "<number>",
        "flex-shrink": "<number>",
        "flex-wrap": "nowrap|wrap|wrap-reverse",
        float: "left|right|none|inline-start|inline-end",
        font: "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>",
        "font-family": "[<family-name>|<generic-family>]#",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-kerning": "auto|normal|none",
        "font-language-override": "normal|<string>",
        "font-optical-sizing": "auto|none",
        "font-palette": "normal|light|dark|<palette-identifier>",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
        "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
        "font-smooth": "auto|never|always|<absolute-size>|<length>",
        "font-stretch": "<font-stretch-absolute>",
        "font-style": "normal|italic|oblique <angle>?",
        "font-synthesis": "none|[weight||style||small-caps||position]",
        "font-synthesis-position": "auto|none",
        "font-synthesis-small-caps": "auto|none",
        "font-synthesis-style": "auto|none",
        "font-synthesis-weight": "auto|none",
        "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
        "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
        "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "font-variant-emoji": "normal|text|emoji|unicode",
        "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
        "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
        "font-variant-position": "normal|sub|super",
        "font-weight": "<font-weight-absolute>|bolder|lighter",
        "forced-color-adjust": "auto|none",
        gap: "<'row-gap'> <'column-gap'>?",
        grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
        "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
        "grid-auto-columns": "<track-size>+",
        "grid-auto-flow": "[row|column]||dense",
        "grid-auto-rows": "<track-size>+",
        "grid-column": "<grid-line> [/ <grid-line>]?",
        "grid-column-end": "<grid-line>",
        "grid-column-gap": "<length-percentage>",
        "grid-column-start": "<grid-line>",
        "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
        "grid-row": "<grid-line> [/ <grid-line>]?",
        "grid-row-end": "<grid-line>",
        "grid-row-gap": "<length-percentage>",
        "grid-row-start": "<grid-line>",
        "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
        "grid-template-areas": "none|<string>+",
        "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
        "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
        "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
        height: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
        "hyphenate-character": "auto|<string>",
        "hyphenate-limit-chars": "[auto|<integer>]{1,3}",
        hyphens: "none|manual|auto",
        "image-orientation": "from-image|<angle>|[<angle>? flip]",
        "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
        "image-resolution": "[from-image||<resolution>]&&snap?",
        "ime-mode": "auto|normal|active|inactive|disabled",
        "initial-letter": "normal|[<number> <integer>?]",
        "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
        "inline-size": "<'width'>",
        "input-security": "auto|none",
        inset: "<'top'>{1,4}",
        "inset-area": "none|<inset-area>",
        "inset-block": "<'top'>{1,2}",
        "inset-block-end": "<'top'>",
        "inset-block-start": "<'top'>",
        "inset-inline": "<'top'>{1,2}",
        "inset-inline-end": "<'top'>",
        "inset-inline-start": "<'top'>",
        isolation: "auto|isolate",
        "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
        "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
        "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
        "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
        left: "<length>|<percentage>|auto",
        "letter-spacing": "normal|<length-percentage>",
        "line-break": "auto|loose|normal|strict|anywhere",
        "line-clamp": "none|<integer>",
        "line-height": "normal|<number>|<length>|<percentage>",
        "line-height-step": "<length>",
        "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
        "list-style-image": "<image>|none",
        "list-style-position": "inside|outside",
        "list-style-type": "<counter-style>|<string>|none",
        margin: "[<length>|<percentage>|auto]{1,4}",
        "margin-block": "<'margin-left'>{1,2}",
        "margin-block-end": "<'margin-left'>",
        "margin-block-start": "<'margin-left'>",
        "margin-bottom": "<length>|<percentage>|auto",
        "margin-inline": "<'margin-left'>{1,2}",
        "margin-inline-end": "<'margin-left'>",
        "margin-inline-start": "<'margin-left'>",
        "margin-left": "<length>|<percentage>|auto",
        "margin-right": "<length>|<percentage>|auto",
        "margin-top": "<length>|<percentage>|auto",
        "margin-trim": "none|in-flow|all",
        marker: "none|<url>",
        "marker-end": "none|<url>",
        "marker-mid": "none|<url>",
        "marker-start": "none|<url>",
        mask: "<mask-layer>#",
        "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
        "mask-border-mode": "luminance|alpha",
        "mask-border-outset": "[<length>|<number>]{1,4}",
        "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
        "mask-border-slice": "<number-percentage>{1,4} fill?",
        "mask-border-source": "none|<image>",
        "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
        "mask-clip": "[<geometry-box>|no-clip]#",
        "mask-composite": "<compositing-operator>#",
        "mask-image": "<mask-reference>#",
        "mask-mode": "<masking-mode>#",
        "mask-origin": "<geometry-box>#",
        "mask-position": "<position>#",
        "mask-repeat": "<repeat-style>#",
        "mask-size": "<bg-size>#",
        "mask-type": "luminance|alpha",
        "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
        "math-depth": "auto-add|add( <integer> )|<integer>",
        "math-shift": "normal|compact",
        "math-style": "normal|compact",
        "max-block-size": "<'max-width'>",
        "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
        "max-inline-size": "<'max-width'>",
        "max-lines": "none|<integer>",
        "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
        "min-block-size": "<'min-width'>",
        "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
        "min-inline-size": "<'min-width'>",
        "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
        "mix-blend-mode": "<blend-mode>|plus-lighter",
        "object-fit": "fill|contain|cover|none|scale-down",
        "object-position": "<position>",
        offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
        "offset-anchor": "auto|<position>",
        "offset-distance": "<length-percentage>",
        "offset-path": "none|<offset-path>||<coord-box>",
        "offset-position": "normal|auto|<position>",
        "offset-rotate": "[auto|reverse]||<angle>",
        opacity: "<alpha-value>",
        order: "<integer>",
        orphans: "<integer>",
        outline: "[<'outline-width'>||<'outline-style'>||<'outline-color'>]",
        "outline-color": "auto|<color>",
        "outline-offset": "<length>",
        "outline-style": "auto|<'border-style'>",
        "outline-width": "<line-width>",
        overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
        "overflow-anchor": "auto|none",
        "overflow-block": "visible|hidden|clip|scroll|auto",
        "overflow-clip-box": "padding-box|content-box",
        "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>",
        "overflow-inline": "visible|hidden|clip|scroll|auto",
        "overflow-wrap": "normal|break-word|anywhere",
        "overflow-x": "visible|hidden|clip|scroll|auto",
        "overflow-y": "visible|hidden|clip|scroll|auto",
        overlay: "none|auto",
        "overscroll-behavior": "[contain|none|auto]{1,2}",
        "overscroll-behavior-block": "contain|none|auto",
        "overscroll-behavior-inline": "contain|none|auto",
        "overscroll-behavior-x": "contain|none|auto",
        "overscroll-behavior-y": "contain|none|auto",
        padding: "[<length>|<percentage>]{1,4}",
        "padding-block": "<'padding-left'>{1,2}",
        "padding-block-end": "<'padding-left'>",
        "padding-block-start": "<'padding-left'>",
        "padding-bottom": "<length>|<percentage>",
        "padding-inline": "<'padding-left'>{1,2}",
        "padding-inline-end": "<'padding-left'>",
        "padding-inline-start": "<'padding-left'>",
        "padding-left": "<length>|<percentage>",
        "padding-right": "<length>|<percentage>",
        "padding-top": "<length>|<percentage>",
        page: "auto|<custom-ident>",
        "page-break-after": "auto|always|avoid|left|right|recto|verso",
        "page-break-before": "auto|always|avoid|left|right|recto|verso",
        "page-break-inside": "auto|avoid",
        "paint-order": "normal|[fill||stroke||markers]",
        perspective: "none|<length>",
        "perspective-origin": "<position>",
        "place-content": "<'align-content'> <'justify-content'>?",
        "place-items": "<'align-items'> <'justify-items'>?",
        "place-self": "<'align-self'> <'justify-self'>?",
        "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
        position: "static|relative|absolute|sticky|fixed|-webkit-sticky",
        "position-anchor": "<anchor-element>",
        "position-try": "<'position-try-order'>? <'position-try-fallbacks'>",
        "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#",
        "position-try-order": "normal|<try-size>",
        "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]",
        "print-color-adjust": "economy|exact",
        quotes: "none|auto|[<string> <string>]+",
        r: "<length>|<percentage>",
        resize: "none|both|horizontal|vertical|block|inline",
        right: "<length>|<percentage>|auto",
        rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
        "row-gap": "normal|<length-percentage>",
        "ruby-align": "start|center|space-between|space-around",
        "ruby-merge": "separate|collapse|auto",
        "ruby-position": "[alternate||[over|under]]|inter-character",
        rx: "<length>|<percentage>",
        ry: "<length>|<percentage>",
        scale: "none|<number>{1,3}",
        "scrollbar-color": "auto|<color>{2}",
        "scrollbar-gutter": "auto|stable&&both-edges?",
        "scrollbar-width": "auto|thin|none",
        "scroll-behavior": "auto|smooth",
        "scroll-margin": "<length>{1,4}",
        "scroll-margin-block": "<length>{1,2}",
        "scroll-margin-block-start": "<length>",
        "scroll-margin-block-end": "<length>",
        "scroll-margin-bottom": "<length>",
        "scroll-margin-inline": "<length>{1,2}",
        "scroll-margin-inline-start": "<length>",
        "scroll-margin-inline-end": "<length>",
        "scroll-margin-left": "<length>",
        "scroll-margin-right": "<length>",
        "scroll-margin-top": "<length>",
        "scroll-padding": "[auto|<length-percentage>]{1,4}",
        "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
        "scroll-padding-block-start": "auto|<length-percentage>",
        "scroll-padding-block-end": "auto|<length-percentage>",
        "scroll-padding-bottom": "auto|<length-percentage>",
        "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
        "scroll-padding-inline-start": "auto|<length-percentage>",
        "scroll-padding-inline-end": "auto|<length-percentage>",
        "scroll-padding-left": "auto|<length-percentage>",
        "scroll-padding-right": "auto|<length-percentage>",
        "scroll-padding-top": "auto|<length-percentage>",
        "scroll-snap-align": "[none|start|end|center]{1,2}",
        "scroll-snap-coordinate": "none|<position>#",
        "scroll-snap-destination": "<position>",
        "scroll-snap-points-x": "none|repeat( <length-percentage> )",
        "scroll-snap-points-y": "none|repeat( <length-percentage> )",
        "scroll-snap-stop": "normal|always",
        "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
        "scroll-snap-type-x": "none|mandatory|proximity",
        "scroll-snap-type-y": "none|mandatory|proximity",
        "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#",
        "scroll-timeline-axis": "[block|inline|x|y]#",
        "scroll-timeline-name": "[none|<dashed-ident>]#",
        "shape-image-threshold": "<alpha-value>",
        "shape-margin": "<length-percentage>",
        "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
        "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
        "tab-size": "<integer>|<length>",
        "table-layout": "auto|fixed",
        "text-align": "start|end|left|right|center|justify|match-parent",
        "text-align-last": "auto|start|end|left|right|center|justify",
        "text-anchor": "start|middle|end",
        "text-combine-upright": "none|all|[digits <integer>?]",
        "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
        "text-decoration-color": "<color>",
        "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
        "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
        "text-decoration-skip-ink": "auto|all|none",
        "text-decoration-style": "solid|double|dotted|dashed|wavy",
        "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
        "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
        "text-emphasis-color": "<color>",
        "text-emphasis-position": "[over|under]&&[right|left]",
        "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
        "text-indent": "<length-percentage>&&hanging?&&each-line?",
        "text-justify": "auto|inter-character|inter-word|none",
        "text-orientation": "mixed|upright|sideways",
        "text-overflow": "[clip|ellipsis|<string>]{1,2}",
        "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
        "text-shadow": "none|<shadow-t>#",
        "text-size-adjust": "none|auto|<percentage>",
        "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto",
        "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
        "text-underline-offset": "auto|<length>|<percentage>",
        "text-underline-position": "auto|from-font|[under||[left|right]]",
        "text-wrap": "wrap|nowrap|balance|stable|pretty",
        "text-wrap-mode": "auto|wrap|nowrap",
        "text-wrap-style": "auto|balance|stable|pretty",
        "timeline-scope": "none|<dashed-ident>#",
        top: "<length>|<percentage>|auto",
        "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
        transform: "none|<transform-list>",
        "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
        "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
        "transform-style": "flat|preserve-3d",
        transition: "<single-transition>#",
        "transition-behavior": "<transition-behavior-value>#",
        "transition-delay": "<time>#",
        "transition-duration": "<time>#",
        "transition-property": "none|<single-transition-property>#",
        "transition-timing-function": "<easing-function>#",
        translate: "none|<length-percentage> [<length-percentage> <length>?]?",
        "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
        "user-select": "auto|text|none|contain|all",
        "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position",
        "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
        "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#",
        "view-timeline-axis": "[block|inline|x|y]#",
        "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#",
        "view-timeline-name": "none|<dashed-ident>#",
        "view-transition-name": "none|<custom-ident>",
        visibility: "visible|hidden|collapse",
        "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]",
        "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces",
        widows: "<integer>",
        width: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
        "will-change": "auto|<animateable-feature>#",
        "word-break": "normal|break-all|keep-all|break-word|auto-phrase",
        "word-spacing": "normal|<length>",
        "word-wrap": "normal|break-word",
        "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
        x: "<length>|<percentage>",
        y: "<length>|<percentage>",
        "z-index": "auto|<integer>",
        zoom: "normal|reset|<number>|<percentage>",
        "-moz-background-clip": "padding|border",
        "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
        "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
        "-moz-border-radius-topleft": "<'border-top-left-radius'>",
        "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
        "-moz-control-character-visibility": "visible|hidden",
        "-moz-osx-font-smoothing": "auto|grayscale",
        "-moz-user-select": "none|text|all|-moz-none",
        "-ms-flex-align": "start|end|center|baseline|stretch",
        "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
        "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
        "-ms-flex-negative": "<'flex-shrink'>",
        "-ms-flex-pack": "start|end|center|justify|distribute",
        "-ms-flex-order": "<integer>",
        "-ms-flex-positive": "<'flex-grow'>",
        "-ms-flex-preferred-size": "<'flex-basis'>",
        "-ms-interpolation-mode": "nearest-neighbor|bicubic",
        "-ms-grid-column-align": "start|end|center|stretch",
        "-ms-grid-row-align": "start|end|center|stretch",
        "-ms-hyphenate-limit-last": "none|always|column|page|spread",
        "-webkit-background-clip": "[<box>|border|padding|content|text]#",
        "-webkit-column-break-after": "always|auto|avoid",
        "-webkit-column-break-before": "always|auto|avoid",
        "-webkit-column-break-inside": "always|auto|avoid",
        "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
        "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
        "-webkit-print-color-adjust": "economy|exact",
        "-webkit-text-security": "none|circle|disc|square",
        "-webkit-user-drag": "none|element|auto",
        "-webkit-user-select": "auto|none|text|all",
        "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
        "baseline-shift": "baseline|sub|super|<svg-length>",
        behavior: "<url>+",
        cue: "<'cue-before'> <'cue-after'>?",
        "cue-after": "<url> <decibel>?|none",
        "cue-before": "<url> <decibel>?|none",
        "glyph-orientation-horizontal": "<angle>",
        "glyph-orientation-vertical": "<angle>",
        kerning: "auto|<svg-length>",
        pause: "<'pause-before'> <'pause-after'>?",
        "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
        "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
        rest: "<'rest-before'> <'rest-after'>?",
        "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
        "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
        src: "[<url> [format( <string># )]?|local( <family-name> )]#",
        speak: "auto|never|always",
        "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
        stroke: "<paint>",
        "stroke-dasharray": "none|[<svg-length>+]#",
        "stroke-dashoffset": "<svg-length>",
        "stroke-linecap": "butt|round|square",
        "stroke-linejoin": "miter|round|bevel",
        "stroke-miterlimit": "<number-one-or-greater>",
        "stroke-opacity": "<number-zero-one>",
        "stroke-width": "<svg-length>",
        "unicode-range": "<urange>#",
        "voice-balance": "<number>|left|center|right|leftwards|rightwards",
        "voice-duration": "auto|<time>",
        "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
        "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
        "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
        "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
        "voice-stress": "normal|strong|moderate|none|reduced",
        "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]",
        "white-space-trim": "none|discard-before||discard-after||discard-inner",
        "position-area": "none|<position-area>"
      },
      atrules: {
        charset: {
          prelude: "<string>",
          descriptors: null
        },
        "counter-style": {
          prelude: "<counter-style-name>",
          descriptors: {
            "additive-symbols": "[<integer>&&<symbol>]#",
            fallback: "<counter-style-name>",
            negative: "<symbol> <symbol>?",
            pad: "<integer>&&<symbol>",
            prefix: "<symbol>",
            range: "[[<integer>|infinite]{2}]#|auto",
            "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
            suffix: "<symbol>",
            symbols: "<symbol>+",
            system: "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
          }
        },
        document: {
          prelude: "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
          descriptors: null
        },
        "font-palette-values": {
          prelude: "<dashed-ident>",
          descriptors: {
            "base-palette": "light|dark|<integer [0,\u221E]>",
            "font-family": "<family-name>#",
            "override-colors": "[<integer [0,\u221E]> <absolute-color-base>]#"
          }
        },
        "font-face": {
          prelude: null,
          descriptors: {
            "ascent-override": "normal|<percentage>",
            "descent-override": "normal|<percentage>",
            "font-display": "[auto|block|swap|fallback|optional]",
            "font-family": "<family-name>",
            "font-feature-settings": "normal|<feature-tag-value>#",
            "font-variation-settings": "normal|[<string> <number>]#",
            "font-stretch": "<font-stretch-absolute>{1,2}",
            "font-style": "normal|italic|oblique <angle>{0,2}",
            "font-weight": "<font-weight-absolute>{1,2}",
            "line-gap-override": "normal|<percentage>",
            "size-adjust": "<percentage>",
            src: "[<url> [format( <string># )]?|local( <family-name> )]#",
            "unicode-range": "<urange>#"
          }
        },
        "font-feature-values": {
          prelude: "<family-name>#",
          descriptors: null
        },
        import: {
          prelude: "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
          descriptors: null
        },
        keyframes: {
          prelude: "<keyframes-name>",
          descriptors: null
        },
        layer: {
          prelude: "[<layer-name>#|<layer-name>?]",
          descriptors: null
        },
        media: {
          prelude: "<media-query-list>",
          descriptors: null
        },
        namespace: {
          prelude: "<namespace-prefix>? [<string>|<url>]",
          descriptors: null
        },
        page: {
          prelude: "<page-selector-list>",
          descriptors: {
            bleed: "auto|<length>",
            marks: "none|[crop||cross]",
            "page-orientation": "upright|rotate-left|rotate-right",
            size: "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
          }
        },
        "position-try": {
          prelude: "<dashed-ident>",
          descriptors: {
            top: "<'top'>",
            left: "<'left'>",
            bottom: "<'bottom'>",
            right: "<'right'>",
            "inset-block-start": "<'inset-block-start'>",
            "inset-block-end": "<'inset-block-end'>",
            "inset-inline-start": "<'inset-inline-start'>",
            "inset-inline-end": "<'inset-inline-end'>",
            "inset-block": "<'inset-block'>",
            "inset-inline": "<'inset-inline'>",
            inset: "<'inset'>",
            "margin-top": "<'margin-top'>",
            "margin-left": "<'margin-left'>",
            "margin-bottom": "<'margin-bottom'>",
            "margin-right": "<'margin-right'>",
            "margin-block-start": "<'margin-block-start'>",
            "margin-block-end": "<'margin-block-end'>",
            "margin-inline-start": "<'margin-inline-start'>",
            "margin-inline-end": "<'margin-inline-end'>",
            margin: "<'margin'>",
            "margin-block": "<'margin-block'>",
            "margin-inline": "<'margin-inline'>",
            width: "<'width'>",
            height: "<'height'>",
            "min-width": "<'min-width'>",
            "min-height": "<'min-height'>",
            "max-width": "<'max-width'>",
            "max-height": "<'max-height'>",
            "block-size": "<'block-size'>",
            "inline-size": "<'inline-size'>",
            "min-block-size": "<'min-block-size'>",
            "min-inline-size": "<'min-inline-size'>",
            "max-block-size": "<'max-block-size'>",
            "max-inline-size": "<'max-inline-size'>",
            "align-self": "<'align-self'>|anchor-center",
            "justify-self": "<'justify-self'>|anchor-center"
          }
        },
        property: {
          prelude: "<custom-property-name>",
          descriptors: {
            syntax: "<string>",
            inherits: "true|false",
            "initial-value": "<declaration-value>?"
          }
        },
        scope: {
          prelude: "[( <scope-start> )]? [to ( <scope-end> )]?",
          descriptors: null
        },
        "starting-style": {
          prelude: null,
          descriptors: null
        },
        supports: {
          prelude: "<supports-condition>",
          descriptors: null
        },
        container: {
          prelude: "[<container-name>]? <container-condition>",
          descriptors: null
        },
        nest: {
          prelude: "<complex-selector-list>",
          descriptors: null
        }
      }
    }, Ee2 = 43, he2 = 45, Kt2 = 110, Ge2 = true, tu = false;
    function Yt2(e2, t3) {
      let n2 = this.tokenStart + e2;
      const r2 = this.charCodeAt(n2);
      for ((r2 === Ee2 || r2 === he2) && (t3 && this.error("Number sign is not allowed"), n2++); n2 < this.tokenEnd; n2++)
        Q2(this.charCodeAt(n2)) || this.error("Integer is expected", n2);
    }
    function st2(e2) {
      return Yt2.call(this, 0, e2);
    }
    function Me2(e2, t3) {
      if (!this.cmpChar(this.tokenStart + e2, t3)) {
        let n2 = "";
        switch (t3) {
          case Kt2:
            n2 = "N is expected";
            break;
          case he2:
            n2 = "HyphenMinus is expected";
            break;
        }
        this.error(n2, this.tokenStart + e2);
      }
    }
    function jn2() {
      let e2 = 0, t3 = 0, n2 = this.tokenType;
      for (; n2 === W2 || n2 === X2; )
        n2 = this.lookupType(++e2);
      if (n2 !== L2)
        if (this.isDelim(Ee2, e2) || this.isDelim(he2, e2)) {
          t3 = this.isDelim(Ee2, e2) ? Ee2 : he2;
          do
            n2 = this.lookupType(++e2);
          while (n2 === W2 || n2 === X2);
          n2 !== L2 && (this.skip(e2), st2.call(this, Ge2));
        } else
          return null;
      return e2 > 0 && this.skip(e2), t3 === 0 && (n2 = this.charCodeAt(this.tokenStart), n2 !== Ee2 && n2 !== he2 && this.error("Number sign is expected")), st2.call(this, t3 !== 0), t3 === he2 ? "-" + this.consume(L2) : this.consume(L2);
    }
    const nu = "AnPlusB", ru = {
      a: [String, null],
      b: [String, null]
    };
    function Qo() {
      const e2 = this.tokenStart;
      let t3 = null, n2 = null;
      if (this.tokenType === L2)
        st2.call(this, tu), n2 = this.consume(L2);
      else if (this.tokenType === y2 && this.cmpChar(this.tokenStart, he2))
        switch (t3 = "-1", Me2.call(this, 1, Kt2), this.tokenEnd - this.tokenStart) {
          case 2:
            this.next(), n2 = jn2.call(this);
            break;
          case 3:
            Me2.call(this, 2, he2), this.next(), this.skipSC(), st2.call(this, Ge2), n2 = "-" + this.consume(L2);
            break;
          default:
            Me2.call(this, 2, he2), Yt2.call(this, 3, Ge2), this.next(), n2 = this.substrToCursor(e2 + 2);
        }
      else if (this.tokenType === y2 || this.isDelim(Ee2) && this.lookupType(1) === y2) {
        let r2 = 0;
        switch (t3 = "1", this.isDelim(Ee2) && (r2 = 1, this.next()), Me2.call(this, 0, Kt2), this.tokenEnd - this.tokenStart) {
          case 1:
            this.next(), n2 = jn2.call(this);
            break;
          case 2:
            Me2.call(this, 1, he2), this.next(), this.skipSC(), st2.call(this, Ge2), n2 = "-" + this.consume(L2);
            break;
          default:
            Me2.call(this, 1, he2), Yt2.call(this, 2, Ge2), this.next(), n2 = this.substrToCursor(e2 + r2 + 1);
        }
      } else if (this.tokenType === z2) {
        const r2 = this.charCodeAt(this.tokenStart), i2 = r2 === Ee2 || r2 === he2;
        let o2 = this.tokenStart + i2;
        for (; o2 < this.tokenEnd && Q2(this.charCodeAt(o2)); o2++)
          ;
        o2 === this.tokenStart + i2 && this.error("Integer is expected", this.tokenStart + i2), Me2.call(this, o2 - this.tokenStart, Kt2), t3 = this.substring(e2, o2), o2 + 1 === this.tokenEnd ? (this.next(), n2 = jn2.call(this)) : (Me2.call(this, o2 - this.tokenStart + 1, he2), o2 + 2 === this.tokenEnd ? (this.next(), this.skipSC(), st2.call(this, Ge2), n2 = "-" + this.consume(L2)) : (Yt2.call(this, o2 - this.tokenStart + 2, Ge2), this.next(), n2 = this.substrToCursor(o2 + 1)));
      } else
        this.error();
      return t3 !== null && t3.charCodeAt(0) === Ee2 && (t3 = t3.substr(1)), n2 !== null && n2.charCodeAt(0) === Ee2 && (n2 = n2.substr(1)), {
        type: "AnPlusB",
        loc: this.getLocation(e2, this.tokenStart),
        a: t3,
        b: n2
      };
    }
    function iu(e2) {
      if (e2.a) {
        const t3 = e2.a === "+1" && "n" || e2.a === "1" && "n" || e2.a === "-1" && "-n" || e2.a + "n";
        if (e2.b) {
          const n2 = e2.b[0] === "-" || e2.b[0] === "+" ? e2.b : "+" + e2.b;
          this.tokenize(t3 + n2);
        } else
          this.tokenize(t3);
      } else
        this.tokenize(e2.b);
    }
    const ou = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: iu,
      name: nu,
      parse: Qo,
      structure: ru
    }, Symbol.toStringTag, { value: "Module" }));
    function Ai2() {
      return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
    }
    function su() {
      for (let e2 = 1, t3; t3 = this.lookupType(e2); e2++) {
        if (t3 === ue2)
          return true;
        if (t3 === V2 || t3 === G2)
          return false;
      }
      return false;
    }
    const au = "Atrule", lu = "atrule", cu = {
      name: String,
      prelude: ["AtrulePrelude", "Raw", null],
      block: ["Block", null]
    };
    function Xo(e2 = false) {
      const t3 = this.tokenStart;
      let n2, r2, i2 = null, o2 = null;
      switch (this.eat(G2), n2 = this.substrToCursor(t3 + 1), r2 = n2.toLowerCase(), this.skipSC(), this.eof === false && this.tokenType !== V2 && this.tokenType !== re2 && (this.parseAtrulePrelude ? i2 = this.parseWithFallback(this.AtrulePrelude.bind(this, n2, e2), Ai2) : i2 = Ai2.call(this, this.tokenIndex), this.skipSC()), this.tokenType) {
        case re2:
          this.next();
          break;
        case V2:
          this.eat(V2), hasOwnProperty.call(this.atrule, r2) && typeof this.atrule[r2].block == "function" ? o2 = this.atrule[r2].block.call(this, e2) : o2 = this.Block(su.call(this)), this.eof || this.eat(ue2);
          break;
      }
      return {
        type: "Atrule",
        loc: this.getLocation(t3, this.tokenStart),
        name: n2,
        prelude: i2,
        block: o2
      };
    }
    function uu(e2) {
      this.token(G2, "@" + e2.name), e2.prelude !== null && this.node(e2.prelude), e2.block ? (this.token(V2, "{"), this.node(e2.block), this.token(ue2, "}")) : this.token(re2, ";");
    }
    const hu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: uu,
      name: au,
      parse: Xo,
      structure: cu,
      walkContext: lu
    }, Symbol.toStringTag, { value: "Module" })), pu = "AtrulePrelude", fu = "atrulePrelude", du = {
      children: [[]]
    };
    function Zo(e2) {
      let t3 = null;
      return e2 !== null && (e2 = e2.toLowerCase()), this.skipSC(), hasOwnProperty.call(this.atrule, e2) && typeof this.atrule[e2].prelude == "function" ? t3 = this.atrule[e2].prelude.call(this) : t3 = this.readSequence(this.scope.AtrulePrelude), this.skipSC(), this.eof !== true && this.tokenType !== V2 && this.tokenType !== re2 && this.error("Semicolon or block is expected"), {
        type: "AtrulePrelude",
        loc: this.getLocationFromList(t3),
        children: t3
      };
    }
    function mu(e2) {
      this.children(e2);
    }
    const gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: mu,
      name: pu,
      parse: Zo,
      structure: du,
      walkContext: fu
    }, Symbol.toStringTag, { value: "Module" })), bu = 36, Jo = 42, Qt2 = 61, yu = 94, rr2 = 124, ku = 126;
    function xu() {
      this.eof && this.error("Unexpected end of input");
      const e2 = this.tokenStart;
      let t3 = false;
      return this.isDelim(Jo) ? (t3 = true, this.next()) : this.isDelim(rr2) || this.eat(y2), this.isDelim(rr2) ? this.charCodeAt(this.tokenStart + 1) !== Qt2 ? (this.next(), this.eat(y2)) : t3 && this.error("Identifier is expected", this.tokenEnd) : t3 && this.error("Vertical line is expected"), {
        type: "Identifier",
        loc: this.getLocation(e2, this.tokenStart),
        name: this.substrToCursor(e2)
      };
    }
    function wu() {
      const e2 = this.tokenStart, t3 = this.charCodeAt(e2);
      return t3 !== Qt2 && // =
      t3 !== ku && // ~=
      t3 !== yu && // ^=
      t3 !== bu && // $=
      t3 !== Jo && // *=
      t3 !== rr2 && this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected"), this.next(), t3 !== Qt2 && (this.isDelim(Qt2) || this.error("Equal sign is expected"), this.next()), this.substrToCursor(e2);
    }
    const vu = "AttributeSelector", Su = {
      name: "Identifier",
      matcher: [String, null],
      value: ["String", "Identifier", null],
      flags: [String, null]
    };
    function es() {
      const e2 = this.tokenStart;
      let t3, n2 = null, r2 = null, i2 = null;
      return this.eat(fe2), this.skipSC(), t3 = xu.call(this), this.skipSC(), this.tokenType !== Se2 && (this.tokenType !== y2 && (n2 = wu.call(this), this.skipSC(), r2 = this.tokenType === Te2 ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === y2 && (i2 = this.consume(y2), this.skipSC())), this.eat(Se2), {
        type: "AttributeSelector",
        loc: this.getLocation(e2, this.tokenStart),
        name: t3,
        matcher: n2,
        value: r2,
        flags: i2
      };
    }
    function Cu(e2) {
      this.token(I2, "["), this.node(e2.name), e2.matcher !== null && (this.tokenize(e2.matcher), this.node(e2.value)), e2.flags !== null && this.token(y2, e2.flags), this.token(I2, "]");
    }
    const Tu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Cu,
      name: vu,
      parse: es,
      structure: Su
    }, Symbol.toStringTag, { value: "Module" })), Au = 38;
    function ts() {
      return this.Raw(null, true);
    }
    function Oi2() {
      return this.parseWithFallback(this.Rule, ts);
    }
    function Ei2() {
      return this.Raw(this.consumeUntilSemicolonIncluded, true);
    }
    function Ou() {
      if (this.tokenType === re2)
        return Ei2.call(this, this.tokenIndex);
      const e2 = this.parseWithFallback(this.Declaration, Ei2);
      return this.tokenType === re2 && this.next(), e2;
    }
    const Eu = "Block", Lu = "block", $u = {
      children: [[
        "Atrule",
        "Rule",
        "Declaration"
      ]]
    };
    function ns(e2) {
      const t3 = e2 ? Ou : Oi2, n2 = this.tokenStart;
      let r2 = this.createList();
      e:
        for (; !this.eof; )
          switch (this.tokenType) {
            case ue2:
              break e;
            case W2:
            case X2:
              this.next();
              break;
            case G2:
              r2.push(this.parseWithFallback(this.Atrule.bind(this, e2), ts));
              break;
            default:
              e2 && this.isDelim(Au) ? r2.push(Oi2.call(this)) : r2.push(t3.call(this));
          }
      return {
        type: "Block",
        loc: this.getLocation(n2, this.tokenStart),
        children: r2
      };
    }
    function _u(e2) {
      this.children(e2, (t3) => {
        t3.type === "Declaration" && this.token(re2, ";");
      });
    }
    const Pu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: _u,
      name: Eu,
      parse: ns,
      structure: $u,
      walkContext: Lu
    }, Symbol.toStringTag, { value: "Module" })), zu = "Brackets", Iu = {
      children: [[]]
    };
    function rs(e2, t3) {
      const n2 = this.tokenStart;
      let r2 = null;
      return this.eat(fe2), r2 = e2.call(this, t3), this.eof || this.eat(Se2), {
        type: "Brackets",
        loc: this.getLocation(n2, this.tokenStart),
        children: r2
      };
    }
    function Ru(e2) {
      this.token(I2, "["), this.children(e2), this.token(I2, "]");
    }
    const Mu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Ru,
      name: zu,
      parse: rs,
      structure: Iu
    }, Symbol.toStringTag, { value: "Module" })), Nu = "CDC", Du = [];
    function is() {
      const e2 = this.tokenStart;
      return this.eat(ae2), {
        type: "CDC",
        loc: this.getLocation(e2, this.tokenStart)
      };
    }
    function ju() {
      this.token(ae2, "-->");
    }
    const Fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: ju,
      name: Nu,
      parse: is,
      structure: Du
    }, Symbol.toStringTag, { value: "Module" })), Bu = "CDO", Wu = [];
    function os() {
      const e2 = this.tokenStart;
      return this.eat(Rt2), {
        type: "CDO",
        loc: this.getLocation(e2, this.tokenStart)
      };
    }
    function Hu() {
      this.token(Rt2, "<!--");
    }
    const Uu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Hu,
      name: Bu,
      parse: os,
      structure: Wu
    }, Symbol.toStringTag, { value: "Module" })), qu = 46, Gu = "ClassSelector", Vu = {
      name: String
    };
    function ss() {
      return this.eatDelim(qu), {
        type: "ClassSelector",
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(y2)
      };
    }
    function Ku(e2) {
      this.token(I2, "."), this.token(y2, e2.name);
    }
    const Yu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Ku,
      name: Gu,
      parse: ss,
      structure: Vu
    }, Symbol.toStringTag, { value: "Module" })), Qu = 43, Li2 = 47, Xu = 62, Zu = 126, Ju = "Combinator", eh = {
      name: String
    };
    function as() {
      const e2 = this.tokenStart;
      let t3;
      switch (this.tokenType) {
        case W2:
          t3 = " ";
          break;
        case I2:
          switch (this.charCodeAt(this.tokenStart)) {
            case Xu:
            case Qu:
            case Zu:
              this.next();
              break;
            case Li2:
              this.next(), this.eatIdent("deep"), this.eatDelim(Li2);
              break;
            default:
              this.error("Combinator is expected");
          }
          t3 = this.substrToCursor(e2);
          break;
      }
      return {
        type: "Combinator",
        loc: this.getLocation(e2, this.tokenStart),
        name: t3
      };
    }
    function th(e2) {
      this.tokenize(e2.name);
    }
    const nh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: th,
      name: Ju,
      parse: as,
      structure: eh
    }, Symbol.toStringTag, { value: "Module" })), rh = 42, ih = 47, oh = "Comment", sh = {
      value: String
    };
    function ls() {
      const e2 = this.tokenStart;
      let t3 = this.tokenEnd;
      return this.eat(X2), t3 - e2 + 2 >= 2 && this.charCodeAt(t3 - 2) === rh && this.charCodeAt(t3 - 1) === ih && (t3 -= 2), {
        type: "Comment",
        loc: this.getLocation(e2, this.tokenStart),
        value: this.substring(e2 + 2, t3)
      };
    }
    function ah(e2) {
      this.token(X2, "/*" + e2.value + "*/");
    }
    const lh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: ah,
      name: oh,
      parse: ls,
      structure: sh
    }, Symbol.toStringTag, { value: "Module" })), ch = /* @__PURE__ */ new Set([ne2, E2, De2]), uh = "Condition", hh = {
      kind: String,
      children: [[
        "Identifier",
        "Feature",
        "FeatureFunction",
        "FeatureRange",
        "SupportsDeclaration"
      ]]
    };
    function $i2(e2) {
      return this.lookupTypeNonSC(1) === y2 && ch.has(this.lookupTypeNonSC(2)) ? this.Feature(e2) : this.FeatureRange(e2);
    }
    const ph = {
      media: $i2,
      container: $i2,
      supports() {
        return this.SupportsDeclaration();
      }
    };
    function cs(e2 = "media") {
      const t3 = this.createList();
      e: for (; !this.eof; )
        switch (this.tokenType) {
          case X2:
          case W2:
            this.next();
            continue;
          case y2:
            t3.push(this.Identifier());
            break;
          case M2: {
            let n2 = this.parseWithFallback(
              () => ph[e2].call(this, e2),
              () => null
            );
            n2 || (n2 = this.parseWithFallback(
              () => {
                this.eat(M2);
                const r2 = this.Condition(e2);
                return this.eat(E2), r2;
              },
              () => this.GeneralEnclosed(e2)
            )), t3.push(n2);
            break;
          }
          case $5: {
            let n2 = this.parseWithFallback(
              () => this.FeatureFunction(e2),
              () => null
            );
            n2 || (n2 = this.GeneralEnclosed(e2)), t3.push(n2);
            break;
          }
          default:
            break e;
        }
      return t3.isEmpty && this.error("Condition is expected"), {
        type: "Condition",
        loc: this.getLocationFromList(t3),
        kind: e2,
        children: t3
      };
    }
    function fh(e2) {
      e2.children.forEach((t3) => {
        t3.type === "Condition" ? (this.token(M2, "("), this.node(t3), this.token(E2, ")")) : this.node(t3);
      });
    }
    const dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: fh,
      name: uh,
      parse: cs,
      structure: hh
    }, Symbol.toStringTag, { value: "Module" })), us = 33, mh = 35, gh = 36, bh = 38, yh = 42, kh = 43, _i2 = 47;
    function xh() {
      return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
    }
    function wh() {
      return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
    }
    function vh() {
      const e2 = this.tokenIndex, t3 = this.Value();
      return t3.type !== "Raw" && this.eof === false && this.tokenType !== re2 && this.isDelim(us) === false && this.isBalanceEdge(e2) === false && this.error(), t3;
    }
    const Sh = "Declaration", Ch = "declaration", Th = {
      important: [Boolean, String],
      property: String,
      value: ["Value", "Raw"]
    };
    function hs() {
      const e2 = this.tokenStart, t3 = this.tokenIndex, n2 = Oh.call(this), r2 = Cr2(n2), i2 = r2 ? this.parseCustomProperty : this.parseValue, o2 = r2 ? wh : xh;
      let s2 = false, c2;
      this.skipSC(), this.eat(ne2);
      const l2 = this.tokenIndex;
      if (r2 || this.skipSC(), i2 ? c2 = this.parseWithFallback(vh, o2) : c2 = o2.call(this, this.tokenIndex), r2 && c2.type === "Value" && c2.children.isEmpty) {
        for (let a2 = l2 - this.tokenIndex; a2 <= 0; a2++)
          if (this.lookupType(a2) === W2) {
            c2.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
      }
      return this.isDelim(us) && (s2 = Eh.call(this), this.skipSC()), this.eof === false && this.tokenType !== re2 && this.isBalanceEdge(t3) === false && this.error(), {
        type: "Declaration",
        loc: this.getLocation(e2, this.tokenStart),
        important: s2,
        property: n2,
        value: c2
      };
    }
    function Ah(e2) {
      this.token(y2, e2.property), this.token(ne2, ":"), this.node(e2.value), e2.important && (this.token(I2, "!"), this.token(y2, e2.important === true ? "important" : e2.important));
    }
    function Oh() {
      const e2 = this.tokenStart;
      if (this.tokenType === I2)
        switch (this.charCodeAt(this.tokenStart)) {
          case yh:
          case gh:
          case kh:
          case mh:
          case bh:
            this.next();
            break;
          case _i2:
            this.next(), this.isDelim(_i2) && this.next();
            break;
        }
      return this.tokenType === F2 ? this.eat(F2) : this.eat(y2), this.substrToCursor(e2);
    }
    function Eh() {
      this.eat(I2), this.skipSC();
      const e2 = this.consume(y2);
      return e2 === "important" ? true : e2;
    }
    const Lh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Ah,
      name: Sh,
      parse: hs,
      structure: Th,
      walkContext: Ch
    }, Symbol.toStringTag, { value: "Module" })), $h = 38;
    function Fn2() {
      return this.Raw(this.consumeUntilSemicolonIncluded, true);
    }
    const _h = "DeclarationList", Ph = {
      children: [[
        "Declaration",
        "Atrule",
        "Rule"
      ]]
    };
    function ps() {
      const e2 = this.createList();
      for (; !this.eof; )
        switch (this.tokenType) {
          case W2:
          case X2:
          case re2:
            this.next();
            break;
          case G2:
            e2.push(this.parseWithFallback(this.Atrule.bind(this, true), Fn2));
            break;
          default:
            this.isDelim($h) ? e2.push(this.parseWithFallback(this.Rule, Fn2)) : e2.push(this.parseWithFallback(this.Declaration, Fn2));
        }
      return {
        type: "DeclarationList",
        loc: this.getLocationFromList(e2),
        children: e2
      };
    }
    function zh(e2) {
      this.children(e2, (t3) => {
        t3.type === "Declaration" && this.token(re2, ";");
      });
    }
    const Ih = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: zh,
      name: _h,
      parse: ps,
      structure: Ph
    }, Symbol.toStringTag, { value: "Module" })), Rh = "Dimension", Mh = {
      value: String,
      unit: String
    };
    function fs() {
      const e2 = this.tokenStart, t3 = this.consumeNumber(z2);
      return {
        type: "Dimension",
        loc: this.getLocation(e2, this.tokenStart),
        value: t3,
        unit: this.substring(e2 + t3.length, this.tokenStart)
      };
    }
    function Nh(e2) {
      this.token(z2, e2.value + e2.unit);
    }
    const Dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Nh,
      name: Rh,
      parse: fs,
      structure: Mh
    }, Symbol.toStringTag, { value: "Module" })), jh = 47, Fh = "Feature", Bh = {
      kind: String,
      name: String,
      value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
    };
    function ds(e2) {
      const t3 = this.tokenStart;
      let n2, r2 = null;
      if (this.eat(M2), this.skipSC(), n2 = this.consume(y2), this.skipSC(), this.tokenType !== E2) {
        switch (this.eat(ne2), this.skipSC(), this.tokenType) {
          case L2:
            this.lookupNonWSType(1) === I2 ? r2 = this.Ratio() : r2 = this.Number();
            break;
          case z2:
            r2 = this.Dimension();
            break;
          case y2:
            r2 = this.Identifier();
            break;
          case $5:
            r2 = this.parseWithFallback(
              () => {
                const i2 = this.Function(this.readSequence, this.scope.Value);
                return this.skipSC(), this.isDelim(jh) && this.error(), i2;
              },
              () => this.Ratio()
            );
            break;
          default:
            this.error("Number, dimension, ratio or identifier is expected");
        }
        this.skipSC();
      }
      return this.eof || this.eat(E2), {
        type: "Feature",
        loc: this.getLocation(t3, this.tokenStart),
        kind: e2,
        name: n2,
        value: r2
      };
    }
    function Wh(e2) {
      this.token(M2, "("), this.token(y2, e2.name), e2.value !== null && (this.token(ne2, ":"), this.node(e2.value)), this.token(E2, ")");
    }
    const Hh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Wh,
      name: Fh,
      parse: ds,
      structure: Bh
    }, Symbol.toStringTag, { value: "Module" })), Uh = "FeatureFunction", qh = {
      kind: String,
      feature: String,
      value: ["Declaration", "Selector"]
    };
    function Gh(e2, t3) {
      const r2 = (this.features[e2] || {})[t3];
      return typeof r2 != "function" && this.error(`Unknown feature ${t3}()`), r2;
    }
    function ms(e2 = "unknown") {
      const t3 = this.tokenStart, n2 = this.consumeFunctionName(), r2 = Gh.call(this, e2, n2.toLowerCase());
      this.skipSC();
      const i2 = this.parseWithFallback(
        () => {
          const o2 = this.tokenIndex, s2 = r2.call(this);
          return this.eof === false && this.isBalanceEdge(o2) === false && this.error(), s2;
        },
        () => this.Raw(null, false)
      );
      return this.eof || this.eat(E2), {
        type: "FeatureFunction",
        loc: this.getLocation(t3, this.tokenStart),
        kind: e2,
        feature: n2,
        value: i2
      };
    }
    function Vh(e2) {
      this.token($5, e2.feature + "("), this.node(e2.value), this.token(E2, ")");
    }
    const Kh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Vh,
      name: Uh,
      parse: ms,
      structure: qh
    }, Symbol.toStringTag, { value: "Module" })), Pi2 = 47, Yh = 60, zi2 = 61, Qh = 62, Xh = "FeatureRange", Zh = {
      kind: String,
      left: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
      leftComparison: String,
      middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
      rightComparison: [String, null],
      right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
    };
    function Bn2() {
      switch (this.skipSC(), this.tokenType) {
        case L2:
          return this.isDelim(Pi2, this.lookupOffsetNonSC(1)) ? this.Ratio() : this.Number();
        case z2:
          return this.Dimension();
        case y2:
          return this.Identifier();
        case $5:
          return this.parseWithFallback(
            () => {
              const e2 = this.Function(this.readSequence, this.scope.Value);
              return this.skipSC(), this.isDelim(Pi2) && this.error(), e2;
            },
            () => this.Ratio()
          );
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
    }
    function Ii2(e2) {
      if (this.skipSC(), this.isDelim(Yh) || this.isDelim(Qh)) {
        const t3 = this.source[this.tokenStart];
        return this.next(), this.isDelim(zi2) ? (this.next(), t3 + "=") : t3;
      }
      if (this.isDelim(zi2))
        return "=";
      this.error(`Expected ${e2 ? '":", ' : ""}"<", ">", "=" or ")"`);
    }
    function gs(e2 = "unknown") {
      const t3 = this.tokenStart;
      this.skipSC(), this.eat(M2);
      const n2 = Bn2.call(this), r2 = Ii2.call(this, n2.type === "Identifier"), i2 = Bn2.call(this);
      let o2 = null, s2 = null;
      return this.lookupNonWSType(0) !== E2 && (o2 = Ii2.call(this), s2 = Bn2.call(this)), this.skipSC(), this.eat(E2), {
        type: "FeatureRange",
        loc: this.getLocation(t3, this.tokenStart),
        kind: e2,
        left: n2,
        leftComparison: r2,
        middle: i2,
        rightComparison: o2,
        right: s2
      };
    }
    function Jh(e2) {
      this.token(M2, "("), this.node(e2.left), this.tokenize(e2.leftComparison), this.node(e2.middle), e2.right && (this.tokenize(e2.rightComparison), this.node(e2.right)), this.token(E2, ")");
    }
    const ep = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Jh,
      name: Xh,
      parse: gs,
      structure: Zh
    }, Symbol.toStringTag, { value: "Module" })), tp = "Function", np = "function", rp = {
      name: String,
      children: [[]]
    };
    function bs(e2, t3) {
      const n2 = this.tokenStart, r2 = this.consumeFunctionName(), i2 = r2.toLowerCase();
      let o2;
      return o2 = t3.hasOwnProperty(i2) ? t3[i2].call(this, t3) : e2.call(this, t3), this.eof || this.eat(E2), {
        type: "Function",
        loc: this.getLocation(n2, this.tokenStart),
        name: r2,
        children: o2
      };
    }
    function ip(e2) {
      this.token($5, e2.name + "("), this.children(e2), this.token(E2, ")");
    }
    const op = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: ip,
      name: tp,
      parse: bs,
      structure: rp,
      walkContext: np
    }, Symbol.toStringTag, { value: "Module" })), sp = "GeneralEnclosed", ap = {
      kind: String,
      function: [String, null],
      children: [[]]
    };
    function ys(e2) {
      const t3 = this.tokenStart;
      let n2 = null;
      this.tokenType === $5 ? n2 = this.consumeFunctionName() : this.eat(M2);
      const r2 = this.parseWithFallback(
        () => {
          const i2 = this.tokenIndex, o2 = this.readSequence(this.scope.Value);
          return this.eof === false && this.isBalanceEdge(i2) === false && this.error(), o2;
        },
        () => this.createSingleNodeList(
          this.Raw(null, false)
        )
      );
      return this.eof || this.eat(E2), {
        type: "GeneralEnclosed",
        loc: this.getLocation(t3, this.tokenStart),
        kind: e2,
        function: n2,
        children: r2
      };
    }
    function lp(e2) {
      e2.function ? this.token($5, e2.function + "(") : this.token(M2, "("), this.children(e2), this.token(E2, ")");
    }
    const cp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: lp,
      name: sp,
      parse: ys,
      structure: ap
    }, Symbol.toStringTag, { value: "Module" })), up = "XXX", hp = "Hash", pp = {
      value: String
    };
    function ks() {
      const e2 = this.tokenStart;
      return this.eat(F2), {
        type: "Hash",
        loc: this.getLocation(e2, this.tokenStart),
        value: this.substrToCursor(e2 + 1)
      };
    }
    function fp(e2) {
      this.token(F2, "#" + e2.value);
    }
    const dp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: fp,
      name: hp,
      parse: ks,
      structure: pp,
      xxx: up
    }, Symbol.toStringTag, { value: "Module" })), mp = "Identifier", gp = {
      name: String
    };
    function xs() {
      return {
        type: "Identifier",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(y2)
      };
    }
    function bp(e2) {
      this.token(y2, e2.name);
    }
    const yp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: bp,
      name: mp,
      parse: xs,
      structure: gp
    }, Symbol.toStringTag, { value: "Module" })), kp = "IdSelector", xp = {
      name: String
    };
    function ws() {
      const e2 = this.tokenStart;
      return this.eat(F2), {
        type: "IdSelector",
        loc: this.getLocation(e2, this.tokenStart),
        name: this.substrToCursor(e2 + 1)
      };
    }
    function wp(e2) {
      this.token(I2, "#" + e2.name);
    }
    const vp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: wp,
      name: kp,
      parse: ws,
      structure: xp
    }, Symbol.toStringTag, { value: "Module" })), Sp = 46, Cp = "Layer", Tp = {
      name: String
    };
    function vs() {
      let e2 = this.consume(y2);
      for (; this.isDelim(Sp); )
        this.eat(I2), e2 += "." + this.consume(y2);
      return {
        type: "Layer",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: e2
      };
    }
    function Ap(e2) {
      this.tokenize(e2.name);
    }
    const Op = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Ap,
      name: Cp,
      parse: vs,
      structure: Tp
    }, Symbol.toStringTag, { value: "Module" })), Ep = "LayerList", Lp = {
      children: [[
        "Layer"
      ]]
    };
    function Ss() {
      const e2 = this.createList();
      for (this.skipSC(); !this.eof && (e2.push(this.Layer()), this.lookupTypeNonSC(0) === ce2); )
        this.skipSC(), this.next(), this.skipSC();
      return {
        type: "LayerList",
        loc: this.getLocationFromList(e2),
        children: e2
      };
    }
    function $p(e2) {
      this.children(e2, () => this.token(ce2, ","));
    }
    const _p = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: $p,
      name: Ep,
      parse: Ss,
      structure: Lp
    }, Symbol.toStringTag, { value: "Module" })), Pp = "MediaQuery", zp = {
      modifier: [String, null],
      mediaType: [String, null],
      condition: ["Condition", null]
    };
    function Cs() {
      const e2 = this.tokenStart;
      let t3 = null, n2 = null, r2 = null;
      if (this.skipSC(), this.tokenType === y2 && this.lookupTypeNonSC(1) !== M2) {
        const i2 = this.consume(y2), o2 = i2.toLowerCase();
        switch (o2 === "not" || o2 === "only" ? (this.skipSC(), t3 = o2, n2 = this.consume(y2)) : n2 = i2, this.lookupTypeNonSC(0)) {
          case y2: {
            this.skipSC(), this.eatIdent("and"), r2 = this.Condition("media");
            break;
          }
          case V2:
          case re2:
          case ce2:
          case De2:
            break;
          default:
            this.error("Identifier or parenthesis is expected");
        }
      } else
        switch (this.tokenType) {
          case y2:
          case M2:
          case $5: {
            r2 = this.Condition("media");
            break;
          }
          case V2:
          case re2:
          case De2:
            break;
          default:
            this.error("Identifier or parenthesis is expected");
        }
      return {
        type: "MediaQuery",
        loc: this.getLocation(e2, this.tokenStart),
        modifier: t3,
        mediaType: n2,
        condition: r2
      };
    }
    function Ip(e2) {
      e2.mediaType ? (e2.modifier && this.token(y2, e2.modifier), this.token(y2, e2.mediaType), e2.condition && (this.token(y2, "and"), this.node(e2.condition))) : e2.condition && this.node(e2.condition);
    }
    const Rp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Ip,
      name: Pp,
      parse: Cs,
      structure: zp
    }, Symbol.toStringTag, { value: "Module" })), Mp = "MediaQueryList", Np = {
      children: [[
        "MediaQuery"
      ]]
    };
    function Ts() {
      const e2 = this.createList();
      for (this.skipSC(); !this.eof && (e2.push(this.MediaQuery()), this.tokenType === ce2); )
        this.next();
      return {
        type: "MediaQueryList",
        loc: this.getLocationFromList(e2),
        children: e2
      };
    }
    function Dp(e2) {
      this.children(e2, () => this.token(ce2, ","));
    }
    const jp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Dp,
      name: Mp,
      parse: Ts,
      structure: Np
    }, Symbol.toStringTag, { value: "Module" })), Fp = 38, Bp = "NestingSelector", Wp = {};
    function As() {
      const e2 = this.tokenStart;
      return this.eatDelim(Fp), {
        type: "NestingSelector",
        loc: this.getLocation(e2, this.tokenStart)
      };
    }
    function Hp() {
      this.token(I2, "&");
    }
    const Up = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Hp,
      name: Bp,
      parse: As,
      structure: Wp
    }, Symbol.toStringTag, { value: "Module" })), qp = "Nth", Gp = {
      nth: ["AnPlusB", "Identifier"],
      selector: ["SelectorList", null]
    };
    function Os() {
      this.skipSC();
      const e2 = this.tokenStart;
      let t3 = e2, n2 = null, r2;
      return this.lookupValue(0, "odd") || this.lookupValue(0, "even") ? r2 = this.Identifier() : r2 = this.AnPlusB(), t3 = this.tokenStart, this.skipSC(), this.lookupValue(0, "of") && (this.next(), n2 = this.SelectorList(), t3 = this.tokenStart), {
        type: "Nth",
        loc: this.getLocation(e2, t3),
        nth: r2,
        selector: n2
      };
    }
    function Vp(e2) {
      this.node(e2.nth), e2.selector !== null && (this.token(y2, "of"), this.node(e2.selector));
    }
    const Kp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Vp,
      name: qp,
      parse: Os,
      structure: Gp
    }, Symbol.toStringTag, { value: "Module" })), Yp = "Number", Qp = {
      value: String
    };
    function Es() {
      return {
        type: "Number",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(L2)
      };
    }
    function Xp(e2) {
      this.token(L2, e2.value);
    }
    const Zp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Xp,
      name: Yp,
      parse: Es,
      structure: Qp
    }, Symbol.toStringTag, { value: "Module" })), Jp = "Operator", ef = {
      value: String
    };
    function Ls() {
      const e2 = this.tokenStart;
      return this.next(), {
        type: "Operator",
        loc: this.getLocation(e2, this.tokenStart),
        value: this.substrToCursor(e2)
      };
    }
    function tf(e2) {
      this.tokenize(e2.value);
    }
    const nf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: tf,
      name: Jp,
      parse: Ls,
      structure: ef
    }, Symbol.toStringTag, { value: "Module" })), rf = "Parentheses", of = {
      children: [[]]
    };
    function $s(e2, t3) {
      const n2 = this.tokenStart;
      let r2 = null;
      return this.eat(M2), r2 = e2.call(this, t3), this.eof || this.eat(E2), {
        type: "Parentheses",
        loc: this.getLocation(n2, this.tokenStart),
        children: r2
      };
    }
    function sf(e2) {
      this.token(M2, "("), this.children(e2), this.token(E2, ")");
    }
    const af = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: sf,
      name: rf,
      parse: $s,
      structure: of
    }, Symbol.toStringTag, { value: "Module" })), lf = "Percentage", cf = {
      value: String
    };
    function _s() {
      return {
        type: "Percentage",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(B2)
      };
    }
    function uf(e2) {
      this.token(B2, e2.value + "%");
    }
    const hf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: uf,
      name: lf,
      parse: _s,
      structure: cf
    }, Symbol.toStringTag, { value: "Module" })), pf = "PseudoClassSelector", ff = "function", df = {
      name: String,
      children: [["Raw"], null]
    };
    function Ps() {
      const e2 = this.tokenStart;
      let t3 = null, n2, r2;
      return this.eat(ne2), this.tokenType === $5 ? (n2 = this.consumeFunctionName(), r2 = n2.toLowerCase(), this.lookupNonWSType(0) == E2 ? t3 = this.createList() : hasOwnProperty.call(this.pseudo, r2) ? (this.skipSC(), t3 = this.pseudo[r2].call(this), this.skipSC()) : (t3 = this.createList(), t3.push(
        this.Raw(null, false)
      )), this.eat(E2)) : n2 = this.consume(y2), {
        type: "PseudoClassSelector",
        loc: this.getLocation(e2, this.tokenStart),
        name: n2,
        children: t3
      };
    }
    function mf(e2) {
      this.token(ne2, ":"), e2.children === null ? this.token(y2, e2.name) : (this.token($5, e2.name + "("), this.children(e2), this.token(E2, ")"));
    }
    const gf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: mf,
      name: pf,
      parse: Ps,
      structure: df,
      walkContext: ff
    }, Symbol.toStringTag, { value: "Module" })), bf = "PseudoElementSelector", yf = "function", kf = {
      name: String,
      children: [["Raw"], null]
    };
    function zs() {
      const e2 = this.tokenStart;
      let t3 = null, n2, r2;
      return this.eat(ne2), this.eat(ne2), this.tokenType === $5 ? (n2 = this.consumeFunctionName(), r2 = n2.toLowerCase(), this.lookupNonWSType(0) == E2 ? t3 = this.createList() : hasOwnProperty.call(this.pseudo, r2) ? (this.skipSC(), t3 = this.pseudo[r2].call(this), this.skipSC()) : (t3 = this.createList(), t3.push(
        this.Raw(null, false)
      )), this.eat(E2)) : n2 = this.consume(y2), {
        type: "PseudoElementSelector",
        loc: this.getLocation(e2, this.tokenStart),
        name: n2,
        children: t3
      };
    }
    function xf(e2) {
      this.token(ne2, ":"), this.token(ne2, ":"), e2.children === null ? this.token(y2, e2.name) : (this.token($5, e2.name + "("), this.children(e2), this.token(E2, ")"));
    }
    const wf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: xf,
      name: bf,
      parse: zs,
      structure: kf,
      walkContext: yf
    }, Symbol.toStringTag, { value: "Module" })), Ri2 = 47;
    function Mi2() {
      switch (this.skipSC(), this.tokenType) {
        case L2:
          return this.Number();
        case $5:
          return this.Function(this.readSequence, this.scope.Value);
        default:
          this.error("Number of function is expected");
      }
    }
    const vf = "Ratio", Sf = {
      left: ["Number", "Function"],
      right: ["Number", "Function", null]
    };
    function Is() {
      const e2 = this.tokenStart, t3 = Mi2.call(this);
      let n2 = null;
      return this.skipSC(), this.isDelim(Ri2) && (this.eatDelim(Ri2), n2 = Mi2.call(this)), {
        type: "Ratio",
        loc: this.getLocation(e2, this.tokenStart),
        left: t3,
        right: n2
      };
    }
    function Cf(e2) {
      this.node(e2.left), this.token(I2, "/"), e2.right ? this.node(e2.right) : this.node(L2, 1);
    }
    const Tf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Cf,
      name: vf,
      parse: Is,
      structure: Sf
    }, Symbol.toStringTag, { value: "Module" }));
    function Af() {
      return this.tokenIndex > 0 && this.lookupType(-1) === W2 ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart;
    }
    const Of = "Raw", Ef = {
      value: String
    };
    function Rs(e2, t3) {
      const n2 = this.getTokenStart(this.tokenIndex);
      let r2;
      return this.skipUntilBalanced(this.tokenIndex, e2 || this.consumeUntilBalanceEnd), t3 && this.tokenStart > n2 ? r2 = Af.call(this) : r2 = this.tokenStart, {
        type: "Raw",
        loc: this.getLocation(n2, r2),
        value: this.substring(n2, r2)
      };
    }
    function Lf(e2) {
      this.tokenize(e2.value);
    }
    const $f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Lf,
      name: Of,
      parse: Rs,
      structure: Ef
    }, Symbol.toStringTag, { value: "Module" }));
    function Ni2() {
      return this.Raw(this.consumeUntilLeftCurlyBracket, true);
    }
    function _f() {
      const e2 = this.SelectorList();
      return e2.type !== "Raw" && this.eof === false && this.tokenType !== V2 && this.error(), e2;
    }
    const Pf = "Rule", zf = "rule", If = {
      prelude: ["SelectorList", "Raw"],
      block: ["Block"]
    };
    function Ms() {
      const e2 = this.tokenIndex, t3 = this.tokenStart;
      let n2, r2;
      return this.parseRulePrelude ? n2 = this.parseWithFallback(_f, Ni2) : n2 = Ni2.call(this, e2), this.skipSC(), this.eat(V2), r2 = this.Block(true), this.eof || this.eat(ue2), {
        type: "Rule",
        loc: this.getLocation(t3, this.tokenStart),
        prelude: n2,
        block: r2
      };
    }
    function Rf(e2) {
      this.node(e2.prelude), this.token(V2, "{"), this.node(e2.block), this.token(ue2, "}");
    }
    const Mf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Rf,
      name: Pf,
      parse: Ms,
      structure: If,
      walkContext: zf
    }, Symbol.toStringTag, { value: "Module" })), Nf = "Scope", Df = {
      root: ["SelectorList", "Raw", null],
      limit: ["SelectorList", "Raw", null]
    };
    function Ns() {
      let e2 = null, t3 = null;
      this.skipSC();
      const n2 = this.tokenStart;
      return this.tokenType === M2 && (this.next(), this.skipSC(), e2 = this.parseWithFallback(
        this.SelectorList,
        () => this.Raw(false, true)
      ), this.skipSC(), this.eat(E2)), this.lookupNonWSType(0) === y2 && (this.skipSC(), this.eatIdent("to"), this.skipSC(), this.eat(M2), this.skipSC(), t3 = this.parseWithFallback(
        this.SelectorList,
        () => this.Raw(false, true)
      ), this.skipSC(), this.eat(E2)), {
        type: "Scope",
        loc: this.getLocation(n2, this.tokenStart),
        root: e2,
        limit: t3
      };
    }
    function jf(e2) {
      e2.root && (this.token(M2, "("), this.node(e2.root), this.token(E2, ")")), e2.limit && (this.token(y2, "to"), this.token(M2, "("), this.node(e2.limit), this.token(E2, ")"));
    }
    const Ff = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: jf,
      name: Nf,
      parse: Ns,
      structure: Df
    }, Symbol.toStringTag, { value: "Module" })), Bf = "Selector", Wf = {
      children: [[
        "TypeSelector",
        "IdSelector",
        "ClassSelector",
        "AttributeSelector",
        "PseudoClassSelector",
        "PseudoElementSelector",
        "Combinator"
      ]]
    };
    function Ds() {
      const e2 = this.readSequence(this.scope.Selector);
      return this.getFirstListNode(e2) === null && this.error("Selector is expected"), {
        type: "Selector",
        loc: this.getLocationFromList(e2),
        children: e2
      };
    }
    function Hf(e2) {
      this.children(e2);
    }
    const Uf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Hf,
      name: Bf,
      parse: Ds,
      structure: Wf
    }, Symbol.toStringTag, { value: "Module" })), qf = "SelectorList", Gf = "selector", Vf = {
      children: [[
        "Selector",
        "Raw"
      ]]
    };
    function js() {
      const e2 = this.createList();
      for (; !this.eof; ) {
        if (e2.push(this.Selector()), this.tokenType === ce2) {
          this.next();
          continue;
        }
        break;
      }
      return {
        type: "SelectorList",
        loc: this.getLocationFromList(e2),
        children: e2
      };
    }
    function Kf(e2) {
      this.children(e2, () => this.token(ce2, ","));
    }
    const Yf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Kf,
      name: qf,
      parse: js,
      structure: Vf,
      walkContext: Gf
    }, Symbol.toStringTag, { value: "Module" })), ir2 = 92, Fs = 34, Qf = 39;
    function Bs(e2) {
      const t3 = e2.length, n2 = e2.charCodeAt(0), r2 = n2 === Fs || n2 === Qf ? 1 : 0, i2 = r2 === 1 && t3 > 1 && e2.charCodeAt(t3 - 1) === n2 ? t3 - 2 : t3 - 1;
      let o2 = "";
      for (let s2 = r2; s2 <= i2; s2++) {
        let c2 = e2.charCodeAt(s2);
        if (c2 === ir2) {
          if (s2 === i2) {
            s2 !== t3 - 1 && (o2 = e2.substr(s2 + 1));
            break;
          }
          if (c2 = e2.charCodeAt(++s2), Le2(ir2, c2)) {
            const l2 = s2 - 1, a2 = ft2(e2, l2);
            s2 = a2 - 1, o2 += go(e2.substring(l2 + 1, a2));
          } else
            c2 === 13 && e2.charCodeAt(s2 + 1) === 10 && s2++;
        } else
          o2 += e2[s2];
      }
      return o2;
    }
    function Xf(e2, t3) {
      const n2 = '"', r2 = Fs;
      let i2 = "", o2 = false;
      for (let s2 = 0; s2 < e2.length; s2++) {
        const c2 = e2.charCodeAt(s2);
        if (c2 === 0) {
          i2 += "\uFFFD";
          continue;
        }
        if (c2 <= 31 || c2 === 127) {
          i2 += "\\" + c2.toString(16), o2 = true;
          continue;
        }
        c2 === r2 || c2 === ir2 ? (i2 += "\\" + e2.charAt(s2), o2 = false) : (o2 && (He2(c2) || Xe2(c2)) && (i2 += " "), i2 += e2.charAt(s2), o2 = false);
      }
      return n2 + i2 + n2;
    }
    const Zf = "String", Jf = {
      value: String
    };
    function Ws() {
      return {
        type: "String",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: Bs(this.consume(Te2))
      };
    }
    function ed(e2) {
      this.token(Te2, Xf(e2.value));
    }
    const td = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: ed,
      name: Zf,
      parse: Ws,
      structure: Jf
    }, Symbol.toStringTag, { value: "Module" })), nd = 33;
    function Di2() {
      return this.Raw(null, false);
    }
    const rd = "StyleSheet", id2 = "stylesheet", od = {
      children: [[
        "Comment",
        "CDO",
        "CDC",
        "Atrule",
        "Rule",
        "Raw"
      ]]
    };
    function Hs() {
      const e2 = this.tokenStart, t3 = this.createList();
      let n2;
      for (; !this.eof; ) {
        switch (this.tokenType) {
          case W2:
            this.next();
            continue;
          case X2:
            if (this.charCodeAt(this.tokenStart + 2) !== nd) {
              this.next();
              continue;
            }
            n2 = this.Comment();
            break;
          case Rt2:
            n2 = this.CDO();
            break;
          case ae2:
            n2 = this.CDC();
            break;
          case G2:
            n2 = this.parseWithFallback(this.Atrule, Di2);
            break;
          default:
            n2 = this.parseWithFallback(this.Rule, Di2);
        }
        t3.push(n2);
      }
      return {
        type: "StyleSheet",
        loc: this.getLocation(e2, this.tokenStart),
        children: t3
      };
    }
    function sd(e2) {
      this.children(e2);
    }
    const ad = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: sd,
      name: rd,
      parse: Hs,
      structure: od,
      walkContext: id2
    }, Symbol.toStringTag, { value: "Module" })), ld = "SupportsDeclaration", cd = {
      declaration: "Declaration"
    };
    function Us() {
      const e2 = this.tokenStart;
      this.eat(M2), this.skipSC();
      const t3 = this.Declaration();
      return this.eof || this.eat(E2), {
        type: "SupportsDeclaration",
        loc: this.getLocation(e2, this.tokenStart),
        declaration: t3
      };
    }
    function ud(e2) {
      this.token(M2, "("), this.node(e2.declaration), this.token(E2, ")");
    }
    const hd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: ud,
      name: ld,
      parse: Us,
      structure: cd
    }, Symbol.toStringTag, { value: "Module" })), pd = 42, ji2 = 124;
    function Wn2() {
      this.tokenType !== y2 && this.isDelim(pd) === false && this.error("Identifier or asterisk is expected"), this.next();
    }
    const fd = "TypeSelector", dd = {
      name: String
    };
    function qs() {
      const e2 = this.tokenStart;
      return this.isDelim(ji2) ? (this.next(), Wn2.call(this)) : (Wn2.call(this), this.isDelim(ji2) && (this.next(), Wn2.call(this))), {
        type: "TypeSelector",
        loc: this.getLocation(e2, this.tokenStart),
        name: this.substrToCursor(e2)
      };
    }
    function md(e2) {
      this.tokenize(e2.name);
    }
    const gd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: md,
      name: fd,
      parse: qs,
      structure: dd
    }, Symbol.toStringTag, { value: "Module" })), Gs = 43, Vs = 45, or2 = 63;
    function Ct2(e2, t3) {
      let n2 = 0;
      for (let r2 = this.tokenStart + e2; r2 < this.tokenEnd; r2++) {
        const i2 = this.charCodeAt(r2);
        if (i2 === Vs && t3 && n2 !== 0)
          return Ct2.call(this, e2 + n2 + 1, false), -1;
        He2(i2) || this.error(
          t3 && n2 !== 0 ? "Hyphen minus" + (n2 < 6 ? " or hex digit" : "") + " is expected" : n2 < 6 ? "Hex digit is expected" : "Unexpected input",
          r2
        ), ++n2 > 6 && this.error("Too many hex digits", r2);
      }
      return this.next(), n2;
    }
    function Wt2(e2) {
      let t3 = 0;
      for (; this.isDelim(or2); )
        ++t3 > e2 && this.error("Too many question marks"), this.next();
    }
    function bd(e2) {
      this.charCodeAt(this.tokenStart) !== e2 && this.error((e2 === Gs ? "Plus sign" : "Hyphen minus") + " is expected");
    }
    function yd() {
      let e2 = 0;
      switch (this.tokenType) {
        case L2:
          if (e2 = Ct2.call(this, 1, true), this.isDelim(or2)) {
            Wt2.call(this, 6 - e2);
            break;
          }
          if (this.tokenType === z2 || this.tokenType === L2) {
            bd.call(this, Vs), Ct2.call(this, 1, false);
            break;
          }
          break;
        case z2:
          e2 = Ct2.call(this, 1, true), e2 > 0 && Wt2.call(this, 6 - e2);
          break;
        default:
          if (this.eatDelim(Gs), this.tokenType === y2) {
            e2 = Ct2.call(this, 0, true), e2 > 0 && Wt2.call(this, 6 - e2);
            break;
          }
          if (this.isDelim(or2)) {
            this.next(), Wt2.call(this, 5);
            break;
          }
          this.error("Hex digit or question mark is expected");
      }
    }
    const kd = "UnicodeRange", xd = {
      value: String
    };
    function Ks() {
      const e2 = this.tokenStart;
      return this.eatIdent("u"), yd.call(this), {
        type: "UnicodeRange",
        loc: this.getLocation(e2, this.tokenStart),
        value: this.substrToCursor(e2)
      };
    }
    function wd(e2) {
      this.tokenize(e2.value);
    }
    const vd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: wd,
      name: kd,
      parse: Ks,
      structure: xd
    }, Symbol.toStringTag, { value: "Module" })), Sd = 32, sr2 = 92, Cd = 34, Td = 39, Ad = 40, Ys = 41;
    function Od(e2) {
      const t3 = e2.length;
      let n2 = 4, r2 = e2.charCodeAt(t3 - 1) === Ys ? t3 - 2 : t3 - 1, i2 = "";
      for (; n2 < r2 && Xe2(e2.charCodeAt(n2)); )
        n2++;
      for (; n2 < r2 && Xe2(e2.charCodeAt(r2)); )
        r2--;
      for (let o2 = n2; o2 <= r2; o2++) {
        let s2 = e2.charCodeAt(o2);
        if (s2 === sr2) {
          if (o2 === r2) {
            o2 !== t3 - 1 && (i2 = e2.substr(o2 + 1));
            break;
          }
          if (s2 = e2.charCodeAt(++o2), Le2(sr2, s2)) {
            const c2 = o2 - 1, l2 = ft2(e2, c2);
            o2 = l2 - 1, i2 += go(e2.substring(c2 + 1, l2));
          } else
            s2 === 13 && e2.charCodeAt(o2 + 1) === 10 && o2++;
        } else
          i2 += e2[o2];
      }
      return i2;
    }
    function Ed(e2) {
      let t3 = "", n2 = false;
      for (let r2 = 0; r2 < e2.length; r2++) {
        const i2 = e2.charCodeAt(r2);
        if (i2 === 0) {
          t3 += "\uFFFD";
          continue;
        }
        if (i2 <= 31 || i2 === 127) {
          t3 += "\\" + i2.toString(16), n2 = true;
          continue;
        }
        i2 === Sd || i2 === sr2 || i2 === Cd || i2 === Td || i2 === Ad || i2 === Ys ? (t3 += "\\" + e2.charAt(r2), n2 = false) : (n2 && He2(i2) && (t3 += " "), t3 += e2.charAt(r2), n2 = false);
      }
      return "url(" + t3 + ")";
    }
    const Ld = "Url", $d = {
      value: String
    };
    function Qs() {
      const e2 = this.tokenStart;
      let t3;
      switch (this.tokenType) {
        case te2:
          t3 = Od(this.consume(te2));
          break;
        case $5:
          this.cmpStr(this.tokenStart, this.tokenEnd, "url(") || this.error("Function name must be `url`"), this.eat($5), this.skipSC(), t3 = Bs(this.consume(Te2)), this.skipSC(), this.eof || this.eat(E2);
          break;
        default:
          this.error("Url or Function is expected");
      }
      return {
        type: "Url",
        loc: this.getLocation(e2, this.tokenStart),
        value: t3
      };
    }
    function _d(e2) {
      this.token(te2, Ed(e2.value));
    }
    const Pd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: _d,
      name: Ld,
      parse: Qs,
      structure: $d
    }, Symbol.toStringTag, { value: "Module" })), zd = "Value", Id = {
      children: [[]]
    };
    function Xs() {
      const e2 = this.tokenStart, t3 = this.readSequence(this.scope.Value);
      return {
        type: "Value",
        loc: this.getLocation(e2, this.tokenStart),
        children: t3
      };
    }
    function Rd(e2) {
      this.children(e2);
    }
    const Md = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Rd,
      name: zd,
      parse: Xs,
      structure: Id
    }, Symbol.toStringTag, { value: "Module" })), Nd = Object.freeze({
      type: "WhiteSpace",
      loc: null,
      value: " "
    }), Dd = "WhiteSpace", jd = {
      value: String
    };
    function Zs() {
      return this.eat(W2), Nd;
    }
    function Fd(e2) {
      this.token(W2, e2.value);
    }
    const Bd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      generate: Fd,
      name: Dd,
      parse: Zs,
      structure: jd
    }, Symbol.toStringTag, { value: "Module" })), Js = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      AnPlusB: ou,
      Atrule: hu,
      AtrulePrelude: gu,
      AttributeSelector: Tu,
      Block: Pu,
      Brackets: Mu,
      CDC: Fu,
      CDO: Uu,
      ClassSelector: Yu,
      Combinator: nh,
      Comment: lh,
      Condition: dh,
      Declaration: Lh,
      DeclarationList: Ih,
      Dimension: Dh,
      Feature: Hh,
      FeatureFunction: Kh,
      FeatureRange: ep,
      Function: op,
      GeneralEnclosed: cp,
      Hash: dp,
      IdSelector: vp,
      Identifier: yp,
      Layer: Op,
      LayerList: _p,
      MediaQuery: Rp,
      MediaQueryList: jp,
      NestingSelector: Up,
      Nth: Kp,
      Number: Zp,
      Operator: nf,
      Parentheses: af,
      Percentage: hf,
      PseudoClassSelector: gf,
      PseudoElementSelector: wf,
      Ratio: Tf,
      Raw: $f,
      Rule: Mf,
      Scope: Ff,
      Selector: Uf,
      SelectorList: Yf,
      String: td,
      StyleSheet: ad,
      SupportsDeclaration: hd,
      TypeSelector: gd,
      UnicodeRange: vd,
      Url: Pd,
      Value: Md,
      WhiteSpace: Bd
    }, Symbol.toStringTag, { value: "Module" })), Wd = Z2(_2({
      generic: true
    }, eu), {
      node: Js
    }), Hd = 35, Ud = 42, Fi2 = 43, qd = 45, Gd = 47, Vd = 117;
    function ea(e2) {
      switch (this.tokenType) {
        case F2:
          return this.Hash();
        case ce2:
          return this.Operator();
        case M2:
          return this.Parentheses(this.readSequence, e2.recognizer);
        case fe2:
          return this.Brackets(this.readSequence, e2.recognizer);
        case Te2:
          return this.String();
        case z2:
          return this.Dimension();
        case B2:
          return this.Percentage();
        case L2:
          return this.Number();
        case $5:
          return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, e2.recognizer);
        case te2:
          return this.Url();
        case y2:
          return this.cmpChar(this.tokenStart, Vd) && this.cmpChar(this.tokenStart + 1, Fi2) ? this.UnicodeRange() : this.Identifier();
        case I2: {
          const t3 = this.charCodeAt(this.tokenStart);
          if (t3 === Gd || t3 === Ud || t3 === Fi2 || t3 === qd)
            return this.Operator();
          t3 === Hd && this.error("Hex or identifier is expected", this.tokenStart + 1);
          break;
        }
      }
    }
    const Kd = {
      getNode: ea
    }, Yd = 35, Qd = 38, Xd = 42, Zd = 43, Jd = 47, Bi2 = 46, em = 62, tm = 124, nm = 126;
    function rm(e2, t3) {
      t3.last !== null && t3.last.type !== "Combinator" && e2 !== null && e2.type !== "Combinator" && t3.push({
        // FIXME: this.Combinator() should be used instead
        type: "Combinator",
        loc: null,
        name: " "
      });
    }
    function im() {
      switch (this.tokenType) {
        case fe2:
          return this.AttributeSelector();
        case F2:
          return this.IdSelector();
        case ne2:
          return this.lookupType(1) === ne2 ? this.PseudoElementSelector() : this.PseudoClassSelector();
        case y2:
          return this.TypeSelector();
        case L2:
        case B2:
          return this.Percentage();
        case z2:
          this.charCodeAt(this.tokenStart) === Bi2 && this.error("Identifier is expected", this.tokenStart + 1);
          break;
        case I2: {
          switch (this.charCodeAt(this.tokenStart)) {
            case Zd:
            case em:
            case nm:
            case Jd:
              return this.Combinator();
            case Bi2:
              return this.ClassSelector();
            case Xd:
            case tm:
              return this.TypeSelector();
            case Yd:
              return this.IdSelector();
            case Qd:
              return this.NestingSelector();
          }
          break;
        }
      }
    }
    const om = {
      onWhiteSpace: rm,
      getNode: im
    };
    function sm() {
      return this.createSingleNodeList(
        this.Raw(null, false)
      );
    }
    function am() {
      const e2 = this.createList();
      if (this.skipSC(), e2.push(this.Identifier()), this.skipSC(), this.tokenType === ce2) {
        e2.push(this.Operator());
        const t3 = this.tokenIndex, n2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
        if (n2.type === "Value" && n2.children.isEmpty) {
          for (let r2 = t3 - this.tokenIndex; r2 <= 0; r2++)
            if (this.lookupType(r2) === W2) {
              n2.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
        }
        e2.push(n2);
      }
      return e2;
    }
    function Wi2(e2) {
      return e2 !== null && e2.type === "Operator" && (e2.value[e2.value.length - 1] === "-" || e2.value[e2.value.length - 1] === "+");
    }
    const lm = {
      getNode: ea,
      onWhiteSpace(e2, t3) {
        Wi2(e2) && (e2.value = " " + e2.value), Wi2(t3.last) && (t3.last.value += " ");
      },
      expression: sm,
      var: am
    }, cm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      AtrulePrelude: Kd,
      Selector: om,
      Value: lm
    }, Symbol.toStringTag, { value: "Module" })), um = /* @__PURE__ */ new Set(["none", "and", "not", "or"]), hm = {
      parse: {
        prelude() {
          const e2 = this.createList();
          if (this.tokenType === y2) {
            const t3 = this.substring(this.tokenStart, this.tokenEnd);
            um.has(t3.toLowerCase()) || e2.push(this.Identifier());
          }
          return e2.push(this.Condition("container")), e2;
        },
        block(e2 = false) {
          return this.Block(e2);
        }
      }
    }, pm = {
      parse: {
        prelude: null,
        block() {
          return this.Block(true);
        }
      }
    };
    function Hn2(e2, t3) {
      return this.parseWithFallback(
        () => {
          try {
            return e2.call(this);
          } finally {
            this.skipSC(), this.lookupNonWSType(0) !== E2 && this.error();
          }
        },
        t3 || (() => this.Raw(null, true))
      );
    }
    const Hi2 = {
      layer() {
        this.skipSC();
        const e2 = this.createList(), t3 = Hn2.call(this, this.Layer);
        return (t3.type !== "Raw" || t3.value !== "") && e2.push(t3), e2;
      },
      supports() {
        this.skipSC();
        const e2 = this.createList(), t3 = Hn2.call(
          this,
          this.Declaration,
          () => Hn2.call(this, () => this.Condition("supports"))
        );
        return (t3.type !== "Raw" || t3.value !== "") && e2.push(t3), e2;
      }
    }, fm = {
      parse: {
        prelude() {
          const e2 = this.createList();
          switch (this.tokenType) {
            case Te2:
              e2.push(this.String());
              break;
            case te2:
            case $5:
              e2.push(this.Url());
              break;
            default:
              this.error("String or url() is expected");
          }
          return this.skipSC(), this.tokenType === y2 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer") ? e2.push(this.Identifier()) : this.tokenType === $5 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(") && e2.push(this.Function(null, Hi2)), this.skipSC(), this.tokenType === $5 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(") && e2.push(this.Function(null, Hi2)), (this.lookupNonWSType(0) === y2 || this.lookupNonWSType(0) === M2) && e2.push(this.MediaQueryList()), e2;
        },
        block: null
      }
    }, dm = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.LayerList()
          );
        },
        block() {
          return this.Block(false);
        }
      }
    }, mm = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.MediaQueryList()
          );
        },
        block(e2 = false) {
          return this.Block(e2);
        }
      }
    }, gm = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    }, bm = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    }, ym = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.Scope()
          );
        },
        block(e2 = false) {
          return this.Block(e2);
        }
      }
    }, km = {
      parse: {
        prelude: null,
        block(e2 = false) {
          return this.Block(e2);
        }
      }
    }, xm = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.Condition("supports")
          );
        },
        block(e2 = false) {
          return this.Block(e2);
        }
      }
    }, wm = {
      container: hm,
      "font-face": pm,
      import: fm,
      layer: dm,
      media: mm,
      nest: gm,
      page: bm,
      scope: ym,
      "starting-style": km,
      supports: xm
    };
    function vm() {
      const e2 = this.createList();
      this.skipSC();
      e: for (; !this.eof; ) {
        switch (this.tokenType) {
          case y2:
            e2.push(this.Identifier());
            break;
          case Te2:
            e2.push(this.String());
            break;
          case ce2:
            e2.push(this.Operator());
            break;
          case E2:
            break e;
          default:
            this.error("Identifier, string or comma is expected");
        }
        this.skipSC();
      }
      return e2;
    }
    const qe2 = {
      parse() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    }, Un2 = {
      parse() {
        return this.createSingleNodeList(
          this.Selector()
        );
      }
    }, Sm = {
      parse() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    }, Cm = {
      parse: vm
    }, Ht2 = {
      parse() {
        return this.createSingleNodeList(
          this.Nth()
        );
      }
    }, Tm = {
      dir: Sm,
      has: qe2,
      lang: Cm,
      matches: qe2,
      is: qe2,
      "-moz-any": qe2,
      "-webkit-any": qe2,
      where: qe2,
      not: qe2,
      "nth-child": Ht2,
      "nth-last-child": Ht2,
      "nth-last-of-type": Ht2,
      "nth-of-type": Ht2,
      slotted: Un2,
      host: Un2,
      "host-context": Un2
    }, Am = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      AnPlusB: Qo,
      Atrule: Xo,
      AtrulePrelude: Zo,
      AttributeSelector: es,
      Block: ns,
      Brackets: rs,
      CDC: is,
      CDO: os,
      ClassSelector: ss,
      Combinator: as,
      Comment: ls,
      Condition: cs,
      Declaration: hs,
      DeclarationList: ps,
      Dimension: fs,
      Feature: ds,
      FeatureFunction: ms,
      FeatureRange: gs,
      Function: bs,
      GeneralEnclosed: ys,
      Hash: ks,
      IdSelector: ws,
      Identifier: xs,
      Layer: vs,
      LayerList: Ss,
      MediaQuery: Cs,
      MediaQueryList: Ts,
      NestingSelector: As,
      Nth: Os,
      Number: Es,
      Operator: Ls,
      Parentheses: $s,
      Percentage: _s,
      PseudoClassSelector: Ps,
      PseudoElementSelector: zs,
      Ratio: Is,
      Raw: Rs,
      Rule: Ms,
      Scope: Ns,
      Selector: Ds,
      SelectorList: js,
      String: Ws,
      StyleSheet: Hs,
      SupportsDeclaration: Us,
      TypeSelector: qs,
      UnicodeRange: Ks,
      Url: Qs,
      Value: Xs,
      WhiteSpace: Zs
    }, Symbol.toStringTag, { value: "Module" })), Om = {
      parseContext: {
        default: "StyleSheet",
        stylesheet: "StyleSheet",
        atrule: "Atrule",
        atrulePrelude(e2) {
          return this.AtrulePrelude(e2.atrule ? String(e2.atrule) : null);
        },
        mediaQueryList: "MediaQueryList",
        mediaQuery: "MediaQuery",
        condition(e2) {
          return this.Condition(e2.kind);
        },
        rule: "Rule",
        selectorList: "SelectorList",
        selector: "Selector",
        block() {
          return this.Block(true);
        },
        declarationList: "DeclarationList",
        declaration: "Declaration",
        value: "Value"
      },
      features: {
        supports: {
          selector() {
            return this.Selector();
          }
        },
        container: {
          style() {
            return this.Declaration();
          }
        }
      },
      scope: cm,
      atrule: wm,
      pseudo: Tm,
      node: Am
    }, Em = {
      node: Js
    }, Lm = Jc(_2(_2(_2({}, Wd), Om), Em));
    function un2(e2) {
      const t3 = {};
      for (const n2 of Object.keys(e2)) {
        let r2 = e2[n2];
        r2 && (Array.isArray(r2) || r2 instanceof q2 ? r2 = r2.map(un2) : r2.constructor === Object && (r2 = un2(r2))), t3[n2] = r2;
      }
      return t3;
    }
    const {
      tokenize: Zg,
      parse: $m,
      generate: _m,
      lexer: Jg,
      createLexer: eb,
      walk: Fe2,
      find: tb,
      findLast: nb,
      findAll: rb,
      toPlainObject: ib,
      fromPlainObject: ob,
      fork: sb
    } = Lm;
    let Pm = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", ke2 = (e2 = 21) => {
      let t3 = "", n2 = e2;
      for (; n2--; )
        t3 += Pm[Math.random() * 64 | 0];
      return t3;
    };
    const oe2 = ke2();
    function Ir2(e2) {
      return !!(e2 && e2.type === "Function" && e2.name === "anchor");
    }
    function Be2(e2) {
      return $m(e2, {
        parseAtrulePrelude: false,
        parseCustomProperty: true
      });
    }
    function le2(e2) {
      return _m(e2, {
        // Default `safe` adds extra (potentially breaking) spaces for compatibility
        // with old browsers.
        mode: "spec"
      });
    }
    function zm(e2) {
      return e2.type === "Declaration";
    }
    function Im(e2) {
      return e2.toArray().reduce(
        (t3, n2) => n2.type === "Operator" && n2.value === "," ? (t3.push([]), t3) : (n2.type === "Identifier" && t3[t3.length - 1].push(n2), t3),
        [[]]
      );
    }
    function ar2(e2) {
      return e2 ? e2.children.map((t3) => {
        var i2;
        let n2;
        ((i2 = t3.children.last) == null ? void 0 : i2.type) === "PseudoElementSelector" && (t3 = un2(t3), n2 = le2(t3.children.last), t3.children.pop());
        const r2 = le2(t3);
        return {
          selector: r2 + (n2 != null ? n2 : ""),
          elementPart: r2,
          pseudoElementPart: n2
        };
      }).toArray() : [];
    }
    const lr2 = {
      "position-anchor": `--position-anchor-${oe2}`,
      "anchor-scope": `--anchor-scope-${oe2}`,
      "anchor-name": `--anchor-name-${oe2}`,
      left: `--left-${oe2}`,
      right: `--right-${oe2}`,
      top: `--top-${oe2}`,
      bottom: `--bottom-${oe2}`,
      "inset-block-start": `--inset-block-start-${oe2}`,
      "inset-block-end": `--inset-block-end-${oe2}`,
      "inset-inline-start": `--inset-inline-start-${oe2}`,
      "inset-inline-end": `--inset-inline-end-${oe2}`,
      "inset-block": `--inset-block-${oe2}`,
      "inset-inline": `--inset-inline-${oe2}`,
      inset: `--inset-${oe2}`
    };
    function Rm(e2, t3) {
      return zm(e2) && lr2[e2.property] && t3 ? (t3.children.appendData(Z2(_2({}, e2), {
        property: lr2[e2.property]
      })), { updated: true }) : {};
    }
    function Mm(e2) {
      for (const t3 of e2) {
        let n2 = false;
        const r2 = Be2(t3.css);
        Fe2(r2, {
          visit: "Declaration",
          enter(i2) {
            var c2;
            const o2 = (c2 = this.rule) == null ? void 0 : c2.block, { updated: s2 } = Rm(i2, o2);
            s2 && (n2 = true);
          }
        }), n2 && (t3.css = le2(r2), t3.changed = true);
      }
      return e2.some((t3) => t3.changed === true);
    }
    var ta = /* @__PURE__ */ ((e2) => (e2.All = "all", e2.None = "none", e2))(ta || {});
    function Ce2(e2, t3) {
      var r2;
      return t3 = (r2 = lr2[t3]) != null ? r2 : t3, (e2 instanceof HTMLElement ? getComputedStyle(e2) : e2.computedStyle).getPropertyValue(t3).trim();
    }
    function gt2(e2, t3, n2) {
      return Ce2(e2, t3) === n2;
    }
    function Nm(e2, { selector: t3, pseudoElementPart: n2 }) {
      const r2 = getComputedStyle(e2, n2), i2 = document.createElement("div"), o2 = document.createElement("style");
      i2.id = `fake-pseudo-element-${ke2()}`;
      for (const c2 of Array.from(r2)) {
        const l2 = r2.getPropertyValue(c2);
        i2.style.setProperty(c2, l2);
      }
      o2.textContent += `#${i2.id}${n2} { content: ${r2.content}; }`, o2.textContent += `${t3} { display: none !important; }`, document.head.append(o2);
      const s2 = n2 === "::before" ? "afterbegin" : "beforeend";
      return e2.insertAdjacentElement(s2, i2), { fakePseudoElement: i2, sheet: o2, computedStyle: r2 };
    }
    function Dm(e2) {
      let t3 = e2;
      for (; t3; ) {
        if (gt2(t3, "overflow", "scroll"))
          return t3;
        t3 = t3.parentElement;
      }
      return t3;
    }
    function jm(e2) {
      let t3 = Dm(e2);
      return t3 === document.documentElement && (t3 = null), t3 != null ? t3 : { scrollTop: 0, scrollLeft: 0 };
    }
    function Fm(e2) {
      const { elementPart: t3, pseudoElementPart: n2 } = e2, r2 = [];
      if (n2 && !(n2 === "::before" || n2 === "::after")) return r2;
      const s2 = Array.from(
        document.querySelectorAll(t3)
      );
      if (!n2)
        return r2.push(...s2), r2;
      for (const c2 of s2) {
        const { fakePseudoElement: l2, sheet: a2, computedStyle: u2 } = Nm(
          c2,
          e2
        ), h2 = l2.getBoundingClientRect(), { scrollY: d2, scrollX: m2 } = globalThis, w2 = jm(c2);
        r2.push({
          fakePseudoElement: l2,
          computedStyle: u2,
          removeFakePseudoElement() {
            l2.remove(), a2.remove();
          },
          // For https://floating-ui.com/docs/autoupdate#ancestorscroll to work on
          // `VirtualElement`s.
          contextElement: c2,
          // https://floating-ui.com/docs/virtual-elements
          getBoundingClientRect() {
            const { scrollY: k2, scrollX: C2 } = globalThis, { scrollTop: b2, scrollLeft: x2 } = w2;
            return DOMRect.fromRect({
              y: h2.y + (d2 - k2) + (w2.scrollTop - b2),
              x: h2.x + (m2 - C2) + (w2.scrollLeft - x2),
              width: h2.width,
              height: h2.height
            });
          }
        });
      }
      return r2;
    }
    function Bm(e2, t3) {
      const n2 = Ce2(e2, "anchor-name");
      return t3 ? n2.split(",").map((r2) => r2.trim()).includes(t3) : !n2;
    }
    function Wm(e2, t3) {
      const n2 = Ce2(e2, "anchor-scope");
      return n2 === t3 || n2 === "all";
    }
    const Ui2 = "InvalidMimeType";
    function Hm(e2) {
      return !!((e2.type === "text/css" || e2.rel === "stylesheet") && e2.href);
    }
    function Um(e2) {
      const t3 = new URL(e2.href, document.baseURI);
      if (Hm(e2) && t3.origin === location.origin)
        return t3;
    }
    function qm(e2) {
      return H2(this, null, function* () {
        return (yield Promise.all(
          e2.map((n2) => H2(this, null, function* () {
            var r2;
            if (!n2.url)
              return n2;
            if ((r2 = n2.el) != null && r2.disabled)
              return null;
            try {
              const i2 = yield fetch(n2.url.toString()), o2 = i2.headers.get("content-type");
              if (!(o2 != null && o2.startsWith("text/css"))) {
                const c2 = new Error(
                  `Error loading ${n2.url}: expected content-type "text/css", got "${o2}".`
                );
                throw c2.name = Ui2, c2;
              }
              const s2 = yield i2.text();
              return Z2(_2({}, n2), { css: s2 });
            } catch (i2) {
              if (i2 instanceof Error && i2.name === Ui2)
                return console.warn(i2), null;
              throw i2;
            }
          }))
        )).filter((n2) => n2 !== null);
      });
    }
    const qi2 = '[style*="anchor"]';
    function Gm(e2) {
      const t3 = e2 ? e2.filter(
        (r2) => r2 instanceof HTMLElement && r2.matches(qi2)
      ) : Array.from(
        document.querySelectorAll(qi2)
      ), n2 = [];
      return t3.filter((r2) => r2 instanceof HTMLElement).forEach((r2) => {
        const i2 = ke2(12), o2 = "data-has-inline-styles";
        r2.setAttribute(o2, i2);
        const s2 = r2.getAttribute("style"), c2 = `[${o2}="${i2}"] { ${s2} }`;
        n2.push({ el: r2, css: c2 });
      }), n2;
    }
    function Vm(e2, t3) {
      return H2(this, null, function* () {
        const n2 = e2 != null ? e2 : Array.from(document.querySelectorAll("link, style")), r2 = [];
        n2.filter((s2) => s2 instanceof HTMLElement).forEach((s2) => {
          if (s2.tagName.toLowerCase() === "link") {
            const c2 = Um(s2);
            c2 && r2.push({ el: s2, url: c2 });
          }
          s2.tagName.toLowerCase() === "style" && r2.push({ el: s2, css: s2.innerHTML });
        });
        const i2 = t3 ? e2 != null ? e2 : [] : void 0, o2 = Gm(i2);
        return yield qm([...r2, ...o2]);
      });
    }
    const na = [
      "left",
      "right",
      "top",
      "bottom",
      "inset-block-start",
      "inset-block-end",
      "inset-inline-start",
      "inset-inline-end",
      "inset-block",
      "inset-inline",
      "inset"
    ];
    function zt2(e2) {
      return na.includes(e2);
    }
    const ra = [
      "margin-block-start",
      "margin-block-end",
      "margin-block",
      "margin-inline-start",
      "margin-inline-end",
      "margin-inline",
      "margin-bottom",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin"
    ];
    function Km(e2) {
      return ra.includes(e2);
    }
    const ia = [
      "width",
      "height",
      "min-width",
      "min-height",
      "max-width",
      "max-height",
      "block-size",
      "inline-size",
      "min-block-size",
      "min-inline-size",
      "max-block-size",
      "max-inline-size"
    ];
    function vn2(e2) {
      return ia.includes(e2);
    }
    const oa = [
      "justify-self",
      "align-self",
      "place-self"
    ];
    function Ym(e2) {
      return oa.includes(e2);
    }
    const Qm = [
      ...na,
      ...ra,
      ...ia,
      ...oa,
      "position-anchor",
      "position-area"
    ], Xm = [
      "top",
      "left",
      "right",
      "bottom",
      "start",
      "end",
      "self-start",
      "self-end",
      "center"
    ];
    function sa(e2) {
      return Xm.includes(e2);
    }
    const Zm = [
      "width",
      "height",
      "block",
      "inline",
      "self-block",
      "self-inline"
    ];
    function Jm(e2) {
      return Zm.includes(e2);
    }
    const eg = [
      "left",
      "center",
      "right",
      "span-left",
      "span-right",
      "x-start",
      "x-end",
      "span-x-start",
      "span-x-end",
      "x-self-start",
      "x-self-end",
      "span-x-self-start",
      "span-x-self-end",
      "span-all",
      "top",
      "bottom",
      "span-top",
      "span-bottom",
      "y-start",
      "y-end",
      "span-y-start",
      "span-y-end",
      "y-self-start",
      "y-self-end",
      "span-y-self-start",
      "span-y-self-end",
      "block-start",
      "block-end",
      "span-block-start",
      "span-block-end",
      "inline-start",
      "inline-end",
      "span-inline-start",
      "span-inline-end",
      "self-block-start",
      "self-block-end",
      "span-self-block-start",
      "span-self-block-end",
      "self-inline-start",
      "self-inline-end",
      "span-self-inline-start",
      "span-self-inline-end",
      "start",
      "end",
      "span-start",
      "span-end",
      "self-start",
      "self-end",
      "span-self-start",
      "span-self-end"
    ], tg = [
      "normal",
      "most-width",
      "most-height",
      "most-block-size",
      "most-inline-size"
    ], ng = [
      "flip-block",
      "flip-inline",
      "flip-start"
    ];
    function aa(e2) {
      return eg.includes(e2);
    }
    function rg(e2) {
      return e2.type === "Declaration";
    }
    function ig(e2) {
      return e2.type === "Declaration" && e2.property === "position-try-fallbacks";
    }
    function og(e2) {
      return e2.type === "Declaration" && e2.property === "position-try-order";
    }
    function sg(e2) {
      return e2.type === "Declaration" && e2.property === "position-try";
    }
    function ag(e2) {
      return e2.type === "Atrule" && e2.name === "position-try";
    }
    function lg(e2) {
      return ng.includes(e2);
    }
    function cg(e2) {
      return tg.includes(e2);
    }
    function ug(e2, t3) {
      const n2 = document.querySelector(e2);
      if (n2) {
        let r2 = pg(n2);
        return t3.forEach((i2) => {
          r2 = la(r2, i2);
        }), r2;
      }
    }
    function hg(e2, t3) {
      let n2 = e2.declarations;
      return t3.forEach((r2) => {
        n2 = la(n2, r2);
      }), n2;
    }
    function pg(e2) {
      const t3 = {};
      return Qm.forEach((n2) => {
        const r2 = Ce2(
          e2,
          `--${n2}-${oe2}`
        );
        r2 && (t3[n2] = r2);
      }), t3;
    }
    const fg = {
      "flip-block": {
        top: "bottom",
        bottom: "top",
        "inset-block-start": "inset-block-end",
        "inset-block-end": "inset-block-start",
        "margin-top": "margin-bottom",
        "margin-bottom": "margin-top"
      },
      "flip-inline": {
        left: "right",
        right: "left",
        "inset-inline-start": "inset-inline-end",
        "inset-inline-end": "inset-inline-start",
        "margin-left": "margin-right",
        "margin-right": "margin-left"
      },
      "flip-start": {
        left: "top",
        right: "bottom",
        top: "left",
        bottom: "right",
        "inset-block-start": "inset-block-end",
        "inset-block-end": "inset-block-start",
        "inset-inline-start": "inset-inline-end",
        "inset-inline-end": "inset-inline-start",
        "inset-block": "inset-inline",
        "inset-inline": "inset-block"
      }
    }, dg = {
      "flip-block": {
        top: "bottom",
        bottom: "top",
        start: "end",
        end: "start",
        "self-end": "self-start",
        "self-start": "self-end"
      },
      "flip-inline": {
        left: "right",
        right: "left",
        start: "end",
        end: "start",
        "self-end": "self-start",
        "self-start": "self-end"
      },
      "flip-start": {
        top: "left",
        left: "top",
        right: "bottom",
        bottom: "right"
      }
    }, mg = {
      "flip-block": {
        top: "bottom",
        bottom: "top",
        start: "end",
        end: "start"
      },
      "flip-inline": {
        left: "right",
        right: "left",
        start: "end",
        end: "start"
      },
      "flip-start": {
        // TODO: Requires fuller logic
      }
    };
    function gg(e2, t3) {
      return fg[t3][e2] || e2;
    }
    function bg(e2, t3) {
      return dg[t3][e2] || e2;
    }
    function yg(e2, t3) {
      if (t3 === "flip-start")
        return e2;
      {
        const n2 = mg[t3];
        return e2.split("-").map((r2) => n2[r2] || r2).join("-");
      }
    }
    function kg(e2, t3, n2) {
      if (e2 === "margin") {
        const [r2, i2, o2, s2] = t3.children.toArray();
        n2 === "flip-block" ? s2 ? t3.children.fromArray([o2, i2, r2, s2]) : o2 && t3.children.fromArray([o2, i2, r2]) : n2 === "flip-inline" && s2 && t3.children.fromArray([r2, s2, o2, i2]);
      } else if (e2 === "margin-block") {
        const [r2, i2] = t3.children.toArray();
        n2 === "flip-block" && i2 && t3.children.fromArray([i2, r2]);
      } else if (e2 === "margin-inline") {
        const [r2, i2] = t3.children.toArray();
        n2 === "flip-inline" && i2 && t3.children.fromArray([i2, r2]);
      }
    }
    const xg = (e2, t3) => {
      var i2;
      return ((i2 = Be2(`#id{${e2}: ${t3};}`).children.first) == null ? void 0 : i2.block.children.first).value;
    };
    function la(e2, t3) {
      const n2 = {};
      return Object.entries(e2).forEach(([r2, i2]) => {
        var l2;
        const o2 = r2, s2 = xg(o2, i2), c2 = gg(o2, t3);
        c2 !== o2 && ((l2 = n2[o2]) != null || (n2[o2] = "revert")), Fe2(s2, {
          visit: "Function",
          enter(a2) {
            Ir2(a2) && a2.children.forEach((u2) => {
              Ot2(u2) && sa(u2.name) && (u2.name = bg(u2.name, t3));
            });
          }
        }), o2 === "position-area" && s2.children.forEach((a2) => {
          Ot2(a2) && aa(a2.name) && (a2.name = yg(a2.name, t3));
        }), o2.startsWith("margin") && kg(o2, s2, t3), n2[c2] = le2(s2);
      }), n2;
    }
    function ca(e2) {
      const t3 = Im(e2), n2 = [];
      return t3.forEach((r2) => {
        const i2 = {
          atRules: [],
          tactics: [],
          positionAreas: []
        };
        r2.forEach((o2) => {
          lg(o2.name) ? i2.tactics.push(o2.name) : o2.name.startsWith("--") ? i2.atRules.push(o2.name) : aa(o2.name) && i2.positionAreas.push(o2.name);
        }), i2.positionAreas.length ? n2.push({
          positionArea: i2.positionAreas[0],
          type: "position-area"
        }) : i2.atRules.length && i2.tactics.length ? n2.push({
          tactics: i2.tactics,
          atRule: i2.atRules[0],
          type: "at-rule-with-try-tactic"
        }) : i2.atRules.length ? n2.push({
          atRule: i2.atRules[0],
          type: "at-rule"
        }) : i2.tactics.length && n2.push({
          tactics: i2.tactics,
          type: "try-tactic"
        });
      }), n2;
    }
    function wg(e2) {
      return ig(e2) && e2.value.children.first ? ca(e2.value.children) : [];
    }
    function vg(e2) {
      if (sg(e2) && e2.value.children.first) {
        const t3 = un2(e2);
        let n2;
        const r2 = t3.value.children.first.name;
        r2 && cg(r2) && (n2 = r2, t3.value.children.shift());
        const i2 = ca(t3.value.children);
        return { order: n2, options: i2 };
      }
      return {};
    }
    function Sg(e2) {
      return og(e2) && e2.value.children.first ? {
        order: e2.value.children.first.name
      } : {};
    }
    function Cg(e2) {
      const { order: t3, options: n2 } = vg(e2);
      if (t3 || n2)
        return { order: t3, options: n2 };
      const { order: r2 } = Sg(e2), i2 = wg(e2);
      return r2 || i2 ? { order: r2, options: i2 } : {};
    }
    function Tg(e2) {
      return zt2(e2.property) || Km(e2.property) || vn2(e2.property) || Ym(e2.property) || ["position-anchor", "position-area"].includes(e2.property);
    }
    function Ag(e2) {
      var t3, n2;
      if (ag(e2) && ((t3 = e2.prelude) != null && t3.value) && ((n2 = e2.block) != null && n2.children)) {
        const r2 = e2.prelude.value, i2 = e2.block.children.filter(
          (s2) => rg(s2) && Tg(s2)
        ), o2 = {
          uuid: `${r2}-try-${ke2(12)}`,
          declarations: Object.fromEntries(
            i2.map((s2) => [s2.property, le2(s2.value)])
          )
        };
        return { name: r2, tryBlock: o2 };
      }
      return {};
    }
    function Og(e2) {
      const t3 = {}, n2 = {}, r2 = {};
      for (const i2 of e2) {
        const o2 = Be2(i2.css);
        Fe2(o2, {
          visit: "Atrule",
          enter(s2) {
            const { name: c2, tryBlock: l2 } = Ag(s2);
            c2 && l2 && (t3[c2] = l2);
          }
        });
      }
      for (const i2 of e2) {
        let o2 = false;
        const s2 = /* @__PURE__ */ new Set(), c2 = Be2(i2.css);
        Fe2(c2, {
          visit: "Declaration",
          enter(l2) {
            var w2;
            const a2 = (w2 = this.rule) == null ? void 0 : w2.prelude, u2 = ar2(a2);
            if (!u2.length) return;
            const { order: h2, options: d2 } = Cg(l2), m2 = {};
            h2 && (m2.order = h2), u2.forEach(({ selector: k2 }) => {
              var C2, b2;
              d2 == null || d2.forEach((x2) => {
                var v2, A2, P2;
                let T2;
                if (x2.type === "at-rule")
                  T2 = x2.atRule;
                else if (x2.type === "try-tactic") {
                  T2 = `${k2}-${x2.tactics.join("-")}`;
                  const O2 = ug(
                    k2,
                    x2.tactics
                  );
                  O2 && (t3[T2] = {
                    uuid: `${k2}-${x2.tactics.join("-")}-try-${ke2(12)}`,
                    declarations: O2
                  });
                } else if (x2.type === "at-rule-with-try-tactic") {
                  T2 = `${k2}-${x2.atRule}-${x2.tactics.join("-")}`;
                  const O2 = t3[x2.atRule], p2 = hg(
                    O2,
                    x2.tactics
                  );
                  p2 && (t3[T2] = {
                    uuid: `${k2}-${x2.atRule}-${x2.tactics.join("-")}-try-${ke2(12)}`,
                    declarations: p2
                  });
                }
                if (T2 && t3[T2]) {
                  const O2 = `[data-anchor-polyfill="${t3[T2].uuid}"]`;
                  (v2 = n2[O2]) != null || (n2[O2] = []), n2[O2].push(k2), s2.has(T2) || ((A2 = m2.fallbacks) != null || (m2.fallbacks = []), m2.fallbacks.push(t3[T2]), s2.add(T2), (P2 = this.stylesheet) == null || P2.children.prependData({
                    type: "Rule",
                    prelude: {
                      type: "Raw",
                      value: O2
                    },
                    block: {
                      type: "Block",
                      children: new q2().fromArray(
                        Object.entries(t3[T2].declarations).map(
                          ([p2, f2]) => ({
                            type: "Declaration",
                            important: true,
                            property: p2,
                            value: {
                              type: "Raw",
                              value: f2
                            }
                          })
                        )
                      )
                    }
                  }), o2 = true);
                }
              }), Object.keys(m2).length > 0 && (r2[k2] ? (m2.order && (r2[k2].order = m2.order), m2.fallbacks && ((b2 = (C2 = r2[k2]).fallbacks) != null || (C2.fallbacks = []), r2[k2].fallbacks.push(
                ...m2.fallbacks
              ))) : r2[k2] = m2);
            });
          }
        }), o2 && (i2.css = le2(c2), i2.changed = true);
      }
      return { fallbackTargets: n2, validPositions: r2 };
    }
    function Eg(e2, t3) {
      return !e2 || e2 === t3 ? false : ua(e2) ? e2.document.contains(t3) : e2.contains(t3);
    }
    function ua(e2) {
      return !!(e2 && e2 === e2.window);
    }
    function Lg(e2) {
      return gt2(e2, "position", "fixed");
    }
    function cr2(e2) {
      return !!(e2 && (Lg(e2) || gt2(e2, "position", "absolute")));
    }
    function Gi2(e2, t3) {
      return e2.compareDocumentPosition(t3) & Node.DOCUMENT_POSITION_FOLLOWING;
    }
    function $g(e2) {
      return H2(this, null, function* () {
        return yield ee2.getOffsetParent(e2);
      });
    }
    function qn2(e2) {
      return H2(this, null, function* () {
        if (!["absolute", "fixed"].includes(Ce2(e2, "position")))
          return yield $g(e2);
        let t3 = e2.parentElement;
        for (; t3; ) {
          if (!gt2(t3, "position", "static") && gt2(t3, "display", "block"))
            return t3;
          t3 = t3.parentElement;
        }
        return window;
      });
    }
    function _g(e2, t3, n2, r2) {
      return H2(this, null, function* () {
        const i2 = yield qn2(e2), o2 = yield qn2(n2);
        if (!(Eg(o2, e2) || ua(o2)) || i2 === o2 && !(!cr2(e2) || Gi2(e2, n2)))
          return false;
        if (i2 !== o2) {
          let s2;
          const c2 = [];
          for (s2 = i2; s2 && s2 !== o2 && s2 !== window; )
            c2.push(s2), s2 = yield qn2(s2);
          const l2 = c2[c2.length - 1];
          if (l2 instanceof HTMLElement && !(!cr2(l2) || Gi2(l2, n2)))
            return false;
        }
        {
          let s2 = e2.parentElement;
          for (; s2; ) {
            if (gt2(s2, "content-visibility", "hidden"))
              return false;
            s2 = s2.parentElement;
          }
        }
        return !(t3 && r2 && Vi2(e2, t3, r2) !== Vi2(n2, t3, r2));
      });
    }
    function Vi2(e2, t3, n2) {
      for (; !(e2.matches(n2) && Wm(e2, t3)); ) {
        if (!e2.parentElement)
          return null;
        e2 = e2.parentElement;
      }
      return e2;
    }
    function Pg(e2, t3, n2, r2) {
      return H2(this, null, function* () {
        if (!(e2 instanceof HTMLElement && n2.length && cr2(e2)))
          return null;
        const i2 = n2.flatMap(Fm).filter((s2) => Bm(s2, t3)), o2 = r2.map((s2) => s2.selector).join(",") || null;
        for (let s2 = i2.length - 1; s2 >= 0; s2--) {
          const c2 = i2[s2], l2 = "fakePseudoElement" in c2;
          if (yield _g(
            l2 ? c2.fakePseudoElement : c2,
            t3,
            e2,
            o2
          ))
            return l2 && c2.removeFakePseudoElement(), c2;
        }
        return null;
      });
    }
    function zg(e2) {
      return e2.type === "Declaration" && e2.property === "anchor-name";
    }
    function Ig(e2) {
      return e2.type === "Declaration" && e2.property === "anchor-scope";
    }
    function ha(e2) {
      return !!(e2 && e2.type === "Function" && e2.name === "anchor-size");
    }
    function Xt2(e2) {
      return !!(e2 && e2.type === "Function" && e2.name === "var");
    }
    function Ot2(e2) {
      return !!(e2.type === "Identifier" && e2.name);
    }
    function Rg(e2) {
      return !!(e2.type === "Percentage" && e2.value);
    }
    function Ki2(e2, t3) {
      let n2, r2, i2, o2 = "", s2 = false, c2;
      const l2 = [];
      e2.children.toArray().forEach((d2) => {
        if (s2) {
          o2 = `${o2}${le2(d2)}`;
          return;
        }
        if (d2.type === "Operator" && d2.value === ",") {
          s2 = true;
          return;
        }
        l2.push(d2);
      });
      let [a2, u2] = l2;
      if (u2 || (u2 = a2, a2 = void 0), a2 && (Ot2(a2) && a2.name.startsWith("--") ? n2 = a2.name : Xt2(a2) && a2.children.first && (c2 = a2.children.first.name)), u2)
        if (Ir2(e2)) {
          if (Ot2(u2) && sa(u2.name))
            r2 = u2.name;
          else if (Rg(u2)) {
            const d2 = Number(u2.value);
            r2 = Number.isNaN(d2) ? void 0 : d2;
          }
        } else ha(e2) && Ot2(u2) && Jm(u2.name) && (i2 = u2.name);
      const h2 = `--anchor-${ke2(12)}`;
      return Object.assign(e2, {
        type: "Raw",
        value: `var(${h2})`,
        children: null
      }), Reflect.deleteProperty(e2, "name"), {
        anchorName: n2,
        anchorSide: r2,
        anchorSize: i2,
        fallbackValue: o2 || "0px",
        customPropName: c2,
        uuid: h2
      };
    }
    function Yi2(e2) {
      return e2.value.children.map(
        ({ name: t3 }) => t3
      );
    }
    let at2 = {}, je2 = {}, Ke2 = {}, Et2 = {}, Ve2 = {};
    function Mg() {
      at2 = {}, je2 = {}, Ke2 = {}, Et2 = {}, Ve2 = {};
    }
    function Ng(e2, t3) {
      var n2;
      if ((Ir2(e2) || ha(e2)) && t3) {
        if (t3.property.startsWith("--")) {
          const r2 = le2(t3.value), i2 = Ki2(e2);
          return Et2[i2.uuid] = r2, Ke2[t3.property] = [
            ...(n2 = Ke2[t3.property]) != null ? n2 : [],
            i2
          ], { changed: true };
        }
        if (zt2(t3.property) || vn2(t3.property)) {
          const r2 = Ki2(e2);
          return { prop: t3.property, data: r2, changed: true };
        }
      }
      return {};
    }
    function Dg(e2, t3) {
      return H2(this, null, function* () {
        let n2 = t3.anchorName;
        const r2 = t3.customPropName;
        if (e2 && !n2) {
          const c2 = Ce2(
            e2,
            "position-anchor"
          );
          c2 ? n2 = c2 : r2 && (n2 = Ce2(e2, r2));
        }
        const i2 = n2 ? at2[n2] || [] : [], o2 = n2 ? je2[ta.All] || [] : [], s2 = n2 ? je2[n2] || [] : [];
        return yield Pg(
          e2,
          n2 || null,
          i2,
          [...o2, ...s2]
        );
      });
    }
    function jg(e2) {
      return H2(this, null, function* () {
        var l2, a2, u2, h2, d2, m2, w2;
        const t3 = {};
        Mg();
        const { fallbackTargets: n2, validPositions: r2 } = Og(e2);
        for (const k2 of e2) {
          let C2 = false;
          const b2 = Be2(k2.css);
          Fe2(b2, function(x2) {
            var p2, f2, S2, g2, K2;
            const T2 = (p2 = this.rule) == null ? void 0 : p2.prelude, v2 = ar2(T2);
            if (zg(x2) && v2.length)
              for (const R2 of Yi2(x2))
                (f2 = at2[R2]) != null || (at2[R2] = []), at2[R2].push(...v2);
            if (Ig(x2) && v2.length)
              for (const R2 of Yi2(x2))
                (S2 = je2[R2]) != null || (je2[R2] = []), je2[R2].push(...v2);
            const {
              prop: A2,
              data: P2,
              changed: O2
            } = Ng(x2, this.declaration);
            if (A2 && P2 && v2.length)
              for (const { selector: R2 } of v2)
                t3[R2] = Z2(_2({}, t3[R2]), {
                  [A2]: [...(K2 = (g2 = t3[R2]) == null ? void 0 : g2[A2]) != null ? K2 : [], P2]
                });
            O2 && (C2 = true);
          }), C2 && (k2.css = le2(b2), k2.changed = true);
        }
        const i2 = new Set(Object.keys(Ke2)), o2 = {}, s2 = (k2) => {
          var x2, T2, v2, A2, P2;
          const C2 = [], b2 = new Set((T2 = (x2 = o2[k2]) == null ? void 0 : x2.names) != null ? T2 : []);
          for (; b2.size > 0; )
            for (const O2 of b2)
              C2.push(...(v2 = Ke2[O2]) != null ? v2 : []), b2.delete(O2), (P2 = (A2 = o2[O2]) == null ? void 0 : A2.names) != null && P2.length && o2[O2].names.forEach((p2) => b2.add(p2));
          return C2;
        };
        for (; i2.size > 0; ) {
          const k2 = [];
          for (const C2 of e2) {
            let b2 = false;
            const x2 = Be2(C2.css);
            Fe2(x2, {
              visit: "Function",
              enter(T2) {
                var O2, p2;
                const v2 = (O2 = this.rule) == null ? void 0 : O2.prelude, A2 = this.declaration, P2 = A2 == null ? void 0 : A2.property;
                if ((v2 == null ? void 0 : v2.children.isEmpty) === false && Xt2(T2) && A2 && P2 && T2.children.first && i2.has(
                  T2.children.first.name
                ) && // For now, we only want assignments to other CSS custom properties
                P2.startsWith("--")) {
                  const f2 = T2.children.first, S2 = (p2 = Ke2[f2.name]) != null ? p2 : [], g2 = s2(f2.name);
                  if (!(S2.length || g2.length))
                    return;
                  const K2 = `${f2.name}-anchor-${ke2(12)}`, R2 = le2(A2.value);
                  Et2[K2] = R2, o2[P2] || (o2[P2] = { names: [], uuids: [] });
                  const be2 = o2[P2];
                  be2.names.includes(f2.name) || be2.names.push(f2.name), be2.uuids.push(K2), k2.push(P2), f2.name = K2, b2 = true;
                }
              }
            }), b2 && (C2.css = le2(x2), C2.changed = true);
          }
          i2.clear(), k2.forEach((C2) => i2.add(C2));
        }
        for (const k2 of e2) {
          let C2 = false;
          const b2 = Be2(k2.css);
          Fe2(b2, {
            visit: "Function",
            enter(x2) {
              var P2, O2, p2, f2, S2, g2, K2;
              const T2 = (P2 = this.rule) == null ? void 0 : P2.prelude, v2 = this.declaration, A2 = v2 == null ? void 0 : v2.property;
              if ((T2 == null ? void 0 : T2.children.isEmpty) === false && Xt2(x2) && v2 && A2 && x2.children.first && // Now we only want assignments to inset/sizing properties
              (zt2(A2) || vn2(A2))) {
                const R2 = x2.children.first, be2 = (O2 = Ke2[R2.name]) != null ? O2 : [], Y2 = s2(R2.name);
                if (!(be2.length || Y2.length))
                  return;
                const ze2 = `${A2}-${ke2(12)}`;
                if (Y2.length) {
                  const Ze2 = /* @__PURE__ */ new Set([R2.name]);
                  for (; Ze2.size > 0; )
                    for (const Je2 of Ze2) {
                      const ie2 = o2[Je2];
                      if ((p2 = ie2 == null ? void 0 : ie2.names) != null && p2.length && ((f2 = ie2 == null ? void 0 : ie2.uuids) != null && f2.length))
                        for (const et2 of ie2.names)
                          for (const tt2 of ie2.uuids)
                            Ve2[tt2] = Z2(_2({}, Ve2[tt2]), {
                              // - `key` (`propUuid`) is the property-specific
                              //   uuid to append to the new custom property name
                              // - `value` is the new property-specific custom
                              //   property value to use
                              [ze2]: `${et2}-${ze2}`
                            });
                      Ze2.delete(Je2), (S2 = ie2 == null ? void 0 : ie2.names) != null && S2.length && ie2.names.forEach((et2) => Ze2.add(et2));
                    }
                }
                const Ue2 = ar2(T2);
                for (const Ze2 of [...be2, ...Y2]) {
                  const Je2 = _2({}, Ze2), ie2 = `--anchor-${ke2(12)}-${A2}`, et2 = Je2.uuid;
                  Je2.uuid = ie2;
                  for (const { selector: tt2 } of Ue2)
                    t3[tt2] = Z2(_2({}, t3[tt2]), {
                      [A2]: [...(K2 = (g2 = t3[tt2]) == null ? void 0 : g2[A2]) != null ? K2 : [], Je2]
                    });
                  Ve2[et2] = Z2(_2({}, Ve2[et2]), {
                    // - `key` (`propUuid`) is the property-specific
                    //   uuid to append to the new custom property name
                    // - `value` is the new property-specific custom
                    //   property value to use
                    [ze2]: ie2
                  });
                }
                R2.name = `${R2.name}-${ze2}`, C2 = true;
              }
            }
          }), C2 && (k2.css = le2(b2), k2.changed = true);
        }
        if (Object.keys(Ve2).length > 0)
          for (const k2 of e2) {
            let C2 = false;
            const b2 = Be2(k2.css);
            Fe2(b2, {
              visit: "Function",
              enter(x2) {
                var T2, v2, A2, P2;
                if (Xt2(x2) && ((v2 = (T2 = x2.children.first) == null ? void 0 : T2.name) != null && v2.startsWith(
                  "--"
                )) && ((P2 = (A2 = this.declaration) == null ? void 0 : A2.property) != null && P2.startsWith("--")) && this.block) {
                  const O2 = x2.children.first, p2 = Ve2[O2.name];
                  if (p2)
                    for (const [f2, S2] of Object.entries(p2))
                      this.block.children.appendData({
                        type: "Declaration",
                        important: false,
                        property: `${this.declaration.property}-${f2}`,
                        value: {
                          type: "Raw",
                          value: le2(this.declaration.value).replace(
                            `var(${O2.name})`,
                            `var(${S2})`
                          )
                        }
                      }), C2 = true;
                  Et2[O2.name] && (this.declaration.value = {
                    type: "Raw",
                    value: Et2[O2.name]
                  }, C2 = true);
                }
              }
            }), C2 && (k2.css = le2(b2), k2.changed = true);
          }
        const c2 = /* @__PURE__ */ new Map();
        for (const [k2, C2] of Object.entries(t3)) {
          let b2;
          k2.startsWith("[data-anchor-polyfill=") && ((l2 = n2[k2]) != null && l2.length) ? b2 = document.querySelectorAll(n2[k2].join(",")) : b2 = document.querySelectorAll(k2);
          for (const [x2, T2] of Object.entries(C2))
            for (const v2 of T2)
              for (const A2 of b2) {
                const P2 = yield Dg(A2, v2), O2 = `--anchor-${ke2(12)}`;
                c2.set(A2, Z2(_2({}, (a2 = c2.get(A2)) != null ? a2 : {}), {
                  [v2.uuid]: O2
                })), A2.setAttribute(
                  "style",
                  `${v2.uuid}: var(${O2}); ${(u2 = A2.getAttribute("style")) != null ? u2 : ""}`
                ), r2[k2] = Z2(_2({}, r2[k2]), {
                  declarations: Z2(_2({}, (h2 = r2[k2]) == null ? void 0 : h2.declarations), {
                    [x2]: [
                      ...(w2 = (m2 = (d2 = r2[k2]) == null ? void 0 : d2.declarations) == null ? void 0 : m2[x2]) != null ? w2 : [],
                      Z2(_2({}, v2), { anchorEl: P2, targetEl: A2, uuid: O2 })
                    ]
                  })
                });
              }
        }
        return { rules: r2, inlineStyles: c2, anchorScopes: je2 };
      });
    }
    const Fg = [
      "crossorigin",
      "href",
      "integrity",
      "referrerpolicy"
    ];
    function Qi2(e2, t3, n2 = false) {
      return H2(this, null, function* () {
        const r2 = [];
        for (const { el: i2, css: o2, changed: s2 } of e2) {
          const c2 = { el: i2, css: o2, changed: false };
          if (s2) {
            if (i2.tagName.toLowerCase() === "style")
              i2.innerHTML = o2;
            else if (i2 instanceof HTMLLinkElement) {
              const l2 = new Blob([o2], { type: "text/css" }), a2 = URL.createObjectURL(l2), u2 = document.createElement("link");
              for (const d2 of i2.getAttributeNames())
                if (!d2.startsWith("on") && !Fg.includes(d2)) {
                  const m2 = i2.getAttribute(d2);
                  m2 !== null && u2.setAttribute(d2, m2);
                }
              u2.setAttribute("href", a2);
              const h2 = new Promise((d2) => {
                u2.onload = d2;
              });
              i2.insertAdjacentElement("beforebegin", u2), yield h2, i2.remove(), c2.el = u2;
            } else if (i2.hasAttribute("data-has-inline-styles")) {
              const l2 = i2.getAttribute("data-has-inline-styles");
              if (l2) {
                const a2 = `[data-has-inline-styles="${l2}"]{`;
                let h2 = o2.slice(a2.length, 0 - "}".length);
                const d2 = t3 == null ? void 0 : t3.get(i2);
                if (d2)
                  for (const [m2, w2] of Object.entries(d2))
                    h2 = `${m2}: var(${w2}); ${h2}`;
                i2.setAttribute("style", h2);
              }
            }
          }
          n2 && i2.hasAttribute("data-has-inline-styles") && i2.removeAttribute("data-has-inline-styles"), r2.push(c2);
        }
        return r2;
      });
    }
    const Bg = Z2(_2({}, ee2), { _c: /* @__PURE__ */ new Map() }), pa = (e2) => H2(Rr2, null, function* () {
      var n2, r2, i2;
      let t3 = yield (n2 = ee2.getOffsetParent) == null ? void 0 : n2.call(ee2, e2);
      return (yield (r2 = ee2.isElement) == null ? void 0 : r2.call(ee2, t3)) || (t3 = (yield (i2 = ee2.getDocumentElement) == null ? void 0 : i2.call(ee2, e2)) || window.document.documentElement), t3;
    }), Wg = (e2, t3) => {
      let n2;
      switch (e2) {
        case "start":
        case "self-start":
          n2 = 0;
          break;
        case "end":
        case "self-end":
          n2 = 100;
          break;
        default:
          typeof e2 == "number" && !Number.isNaN(e2) && (n2 = e2);
      }
      if (n2 !== void 0)
        return t3 ? 100 - n2 : n2;
    }, Hg = (e2, t3) => {
      let n2;
      switch (e2) {
        case "block":
        case "self-block":
          n2 = t3 ? "width" : "height";
          break;
        case "inline":
        case "self-inline":
          n2 = t3 ? "height" : "width";
          break;
      }
      return n2;
    }, Xi2 = (e2) => {
      switch (e2) {
        case "top":
        case "bottom":
          return "y";
        case "left":
        case "right":
          return "x";
      }
      return null;
    }, Ug = (e2) => {
      switch (e2) {
        case "x":
          return "width";
        case "y":
          return "height";
      }
      return null;
    }, Zi2 = (e2) => Ce2(e2, "display") === "inline", Ji2 = (e2, t3) => (t3 === "x" ? ["border-left-width", "border-right-width"] : ["border-top-width", "border-bottom-width"]).reduce(
      (r2, i2) => r2 + parseInt(Ce2(e2, i2), 10),
      0
    ) || 0, Ut2 = (e2, t3) => parseInt(Ce2(e2, `margin-${t3}`), 10) || 0, qg = (e2) => ({
      top: Ut2(e2, "top"),
      right: Ut2(e2, "right"),
      bottom: Ut2(e2, "bottom"),
      left: Ut2(e2, "left")
    }), eo2 = (s2) => H2(Rr2, [s2], function* ({
      targetEl: e2,
      targetProperty: t3,
      anchorRect: n2,
      anchorSide: r2,
      anchorSize: i2,
      fallback: o2
    }) {
      var c2;
      if (!((i2 || r2 !== void 0) && e2 && n2))
        return o2;
      if (i2) {
        if (!vn2(t3))
          return o2;
        let l2;
        switch (i2) {
          case "width":
          case "height":
            l2 = i2;
            break;
          default: {
            let a2 = false;
            const u2 = Ce2(e2, "writing-mode");
            a2 = u2.startsWith("vertical-") || u2.startsWith("sideways-"), l2 = Hg(i2, a2);
          }
        }
        return l2 ? `${n2[l2]}px` : o2;
      }
      if (r2 !== void 0) {
        let l2, a2;
        const u2 = Xi2(t3);
        if (!(zt2(t3) && u2 && (!zt2(r2) || u2 === Xi2(r2))))
          return o2;
        switch (r2) {
          case "left":
            l2 = 0;
            break;
          case "right":
            l2 = 100;
            break;
          case "top":
            l2 = 0;
            break;
          case "bottom":
            l2 = 100;
            break;
          case "center":
            l2 = 50;
            break;
          default:
            if (e2) {
              const m2 = (yield (c2 = ee2.isRTL) == null ? void 0 : c2.call(ee2, e2)) || false;
              l2 = Wg(r2, m2);
            }
        }
        const h2 = typeof l2 == "number" && !Number.isNaN(l2), d2 = Ug(u2);
        if (h2 && d2) {
          (t3 === "bottom" || t3 === "right") && (a2 = yield pa(e2));
          let m2 = n2[u2] + n2[d2] * (l2 / 100);
          switch (t3) {
            case "bottom": {
              if (!a2)
                break;
              let w2 = a2.clientHeight;
              if (w2 === 0 && Zi2(a2)) {
                const k2 = Ji2(a2, u2);
                w2 = a2.offsetHeight - k2;
              }
              m2 = w2 - m2;
              break;
            }
            case "right": {
              if (!a2)
                break;
              let w2 = a2.clientWidth;
              if (w2 === 0 && Zi2(a2)) {
                const k2 = Ji2(a2, u2);
                w2 = a2.offsetWidth - k2;
              }
              m2 = w2 - m2;
              break;
            }
          }
          return `${m2}px`;
        }
      }
      return o2;
    });
    function Gg(e2, t3 = false) {
      return H2(this, null, function* () {
        const n2 = document.documentElement;
        for (const [r2, i2] of Object.entries(e2))
          for (const o2 of i2) {
            const s2 = o2.anchorEl, c2 = o2.targetEl;
            if (s2 && c2)
              uo(
                s2,
                c2,
                () => H2(this, null, function* () {
                  const l2 = yield ee2.getElementRects({
                    reference: s2,
                    floating: c2,
                    strategy: "absolute"
                  }), a2 = yield eo2({
                    targetEl: c2,
                    targetProperty: r2,
                    anchorRect: l2.reference,
                    anchorSide: o2.anchorSide,
                    anchorSize: o2.anchorSize,
                    fallback: o2.fallbackValue
                  });
                  n2.style.setProperty(o2.uuid, a2);
                }),
                { animationFrame: t3 }
              );
            else {
              const l2 = yield eo2({
                targetProperty: r2,
                anchorSide: o2.anchorSide,
                anchorSize: o2.anchorSize,
                fallback: o2.fallbackValue
              });
              n2.style.setProperty(o2.uuid, l2);
            }
          }
      });
    }
    function to2(e2, t3) {
      return H2(this, null, function* () {
        const n2 = yield ee2.getElementRects({
          reference: e2,
          floating: e2,
          strategy: "absolute"
        });
        return yield ja(
          {
            x: e2.offsetLeft,
            y: e2.offsetTop,
            platform: Bg,
            rects: n2,
            elements: { floating: e2 },
            strategy: "absolute"
          },
          {
            boundary: t3,
            rootBoundary: "document",
            padding: qg(e2)
          }
        );
      });
    }
    function Vg(e2, t3, n2 = false) {
      return H2(this, null, function* () {
        if (!t3.length)
          return;
        const r2 = document.querySelectorAll(e2);
        for (const i2 of r2) {
          let o2 = false;
          const s2 = yield pa(i2);
          uo(
            // We're just checking whether the target element overflows, so we don't
            // care about the position of the anchor element in this case. Passing in
            // an empty object instead of a reference element avoids unnecessarily
            // watching for irrelevant changes.
            {},
            i2,
            () => H2(this, null, function* () {
              if (o2)
                return;
              o2 = true, i2.removeAttribute("data-anchor-polyfill");
              const c2 = yield to2(i2, s2);
              if (Object.values(c2).every((l2) => l2 <= 0)) {
                i2.removeAttribute("data-anchor-polyfill-last-successful"), o2 = false;
                return;
              }
              for (const [l2, { uuid: a2 }] of t3.entries()) {
                i2.setAttribute("data-anchor-polyfill", a2);
                const u2 = yield to2(i2, s2);
                if (Object.values(u2).every((h2) => h2 <= 0)) {
                  i2.setAttribute("data-anchor-polyfill-last-successful", a2), o2 = false;
                  break;
                }
                if (l2 === t3.length - 1) {
                  const h2 = i2.getAttribute(
                    "data-anchor-polyfill-last-successful"
                  );
                  h2 ? i2.setAttribute("data-anchor-polyfill", h2) : i2.removeAttribute("data-anchor-polyfill"), o2 = false;
                  break;
                }
              }
            }),
            { animationFrame: n2, layoutShift: false }
          );
        }
      });
    }
    function Kg(e2, t3 = false) {
      return H2(this, null, function* () {
        var n2, r2;
        for (const i2 of Object.values(e2))
          yield Gg((n2 = i2.declarations) != null ? n2 : {}, t3);
        for (const [i2, o2] of Object.entries(e2))
          yield Vg(
            i2,
            (r2 = o2.fallbacks) != null ? r2 : [],
            t3
          );
      });
    }
    function Yg(e2 = {}) {
      const t3 = typeof e2 == "boolean" ? { useAnimationFrame: e2 } : e2, n2 = t3.useAnimationFrame === void 0 ? !!window.UPDATE_ANCHOR_ON_ANIMATION_FRAME : t3.useAnimationFrame;
      return Array.isArray(t3.elements) || (t3.elements = void 0), Object.assign(t3, { useAnimationFrame: n2 });
    }
    function no2(e2) {
      return H2(this, null, function* () {
        const t3 = Yg(
          window.ANCHOR_POSITIONING_POLYFILL_OPTIONS
        );
        let n2 = yield Vm(t3.elements, t3.excludeInlineStyles);
        (yield Mm(n2)) && (n2 = yield Qi2(n2));
        const { rules: i2, inlineStyles: o2 } = yield jg(n2);
        return Object.values(i2).length && (yield Qi2(n2, o2, true), yield Kg(i2, t3.useAnimationFrame)), i2;
      });
    }
    document.readyState !== "complete" ? window.addEventListener("load", () => {
      no2();
    }) : no2();
  });
  var css_anchor_positioning_default = Qg();
})();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.0
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-05-11T18:29Z
   *)

selectize/dist/js/selectize.min.js:
  (*! selectize.js - v0.12.6 | https://github.com/selectize/selectize.js | Apache License (v2) *)

trix/dist/trix.esm.min.js:
  (*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.2
  Copyright © 2024 37signals LLC
   *)
*/
//# sourceMappingURL=/assets/administrate/application.js.map
